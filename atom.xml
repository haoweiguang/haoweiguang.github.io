<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>微光的Notes</title>
  
  <subtitle>梦想是要有的，万一实现了呢</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haoweiguang.me/"/>
  <updated>2019-10-26T15:20:05.310Z</updated>
  <id>http://haoweiguang.me/</id>
  
  <author>
    <name>Light微光</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>产品经理应具备的能力（读张小龙有感）</title>
    <link href="http://haoweiguang.me/2019/10/16/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%BA%94%E5%85%B7%E5%A4%87%E7%9A%84%E8%83%BD%E5%8A%9B%EF%BC%88%E8%AF%BB%E5%BC%A0%E5%B0%8F%E9%BE%99%E6%9C%89%E6%84%9F%EF%BC%89/"/>
    <id>http://haoweiguang.me/2019/10/16/产品经理应具备的能力（读张小龙有感）/</id>
    <published>2019-10-16T10:38:11.000Z</published>
    <updated>2019-10-26T15:20:05.310Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读有关张小龙的材料，觉着最真实、最有价值的还数龙哥在还未封神之前饭否的言论啦。花了好几天，断断续续的读完，泪流满面啊，龙哥牛逼，研究产品都搞到哲学、人性层面了，但感觉自己能吸收的东西了了。那就先写下自己当前的想法，另记下认为比较经典的话，以后可以常来翻一翻，常看常新吧。</p><blockquote><p>产品人是站在上帝身边的人</p></blockquote><p>产品经理看到这句，心里肯定会乐开了花，但权利越大，责任越大啊。龙哥为啥这样说呢，一是来奉承产品经理，二是产品经理确实是洞悉人性，满足用户欲望，设计规则，并让产品和人群按照规则演化的主，想想是不是有点像上帝。</p><blockquote><p>所以我后来发现,人不是培养出来的,是给他们土壤,然后,有才能的人自己会成长起来的。甚至不需要我分享什么。后来我就不培养人了,只观察人了。 </p></blockquote><p>优秀的人，有了土壤，自己就会长起来，其他职业也是。</p><blockquote><p> 如果工作不是被好奇心驱动,不如回家卖红薯。</p><p> 做产品,最要紧是保持十年如一日的新鲜感。</p><p>好奇心和发现是最值得珍惜的品德。</p></blockquote><p>好奇心很重要，这是人最原始的东西，也最能持久。</p><blockquote><p> 以后招产品经理,直接给他一个小电器,比如mp3播放器,让他写个产品使用手册,就知道行不行了。</p><p> 要提防那些Blog写得好的产品经理,因为在Blog上花的时间越多,在产品上花的时间就越少。原来还以为有例外,现在看起来无一例外。</p></blockquote><p>咳咳，Fenng老师，你怎么看？</p><blockquote><p> 做产品,就是跟用户谈一场恋爱,否则只是一场商业交易而已。产品人是多么的博爱啊。</p><p> 面试产品经理,所有技能合格后,要问,你喜欢摇滚吗。回答否的,就算了。</p><p> 我在生活上不是一个有洁癖的人,但对待产品却分毫必究,介大概就是传说中的精神分裂吧。</p><p> 很多人看到MJ的海报说pm心中有爱。不是爱,是愤怒。</p></blockquote><p>产品不应该仅仅是功能（需求）的堆砌，应该还要有“温度”，可能包含了产品经理的价值观、爱、愤怒或者其他，那样才有灵魂。</p><blockquote><p> 老乔是Intel的葛洛夫的唯有偏执狂才能生存的证明人。 偏执需要权力的辅佐才能进行到底。</p></blockquote><p>我还是想活的久一点，当个普通人也未尝不可吧。就像龙哥说的“ think less,live more（想得少，活得更久）”。</p><blockquote><p>要知道用户的心理，并且知道用一个什么样的规则去引导他。为什么这么说呢？规则是很简单的，只有简单的规则才可以演化出一个非常复杂的事件出来。所以我经常很不认同说，在很多做产品里面，一开始就做一个复杂的规则出来，最后没有任何演化的空间。……像Twitter之类的产品都非常简单，……，但是这样的东西是最有生命力的。</p><p>我们要做的工作是在群体里面做一个加速器、催化剂，是做这一类的工作，而不是把这一块钉死了之后，用户进来以后，只能怎么样，一步一步的走。</p></blockquote><p>设计出简单规则的能力</p><blockquote><p>让用户保持饥饿，让他们保持愚蠢。…….对我们的用户来说，我们是要想办法让他们知道他们的饥渴在哪里。</p><p>我们要满足他们的贪嗔痴。贪是贪婪，嗔是嫉妒，痴是执着。</p><p>那我们要洞察这一点，是因为我们的产品对用户产生黏性，就是让用户对你的产品产生贪，产生嗔，产生痴。</p><p>我们给大家各种钻，钻体现了什么心理？其实都体现了人性的这几个弱点，各种黄钻、绿钻，他会贪，他要升级；他会嗔，他会跟人比较，说你的钻比我的等级高，所以我也要升上去；他会痴，觉得我一定要把所有的钻给收齐。……就像苹果的手机，它同样的会对用户产生这样的吸引力……这是人性本身的一个共同的弱点</p><p>所以当我们在做一个产品的时候，我们在研究人性，而不是说在研究一个产品的逻辑。</p><p>所有的产品都需要有人性的研究。……..你可以对每一个好的产品都提出来问题，那么它背后肯定都是从人性的角度来说的，而不是从别的理由来说的。</p></blockquote><p>深刻的理解人性</p><blockquote><p>我们做产品要找到用户心理诉求的本质。……用户上微博干什么？<strong>用户上微博的原因是为了炫耀，是因为害怕孤独，不是利群而离群，是用它有追感。</strong>……<strong>实际上微博是一个构筑另一个自我的地方，构筑一个自我。</strong>…….一个内心强大的人是不需要写微博的。</p><p>功能是做需求，定位是做一种心理诉求，也就是说定位是更底层的一些心理供给。</p><p>让他<strong>获得安慰感、排除孤独感，让他获得成就感，让他在里面更加的自信</strong>，让他在里面像一个敌人一样的，要做到这些诉求。</p></blockquote><p>善于抓住用户心理诉求的本质，挖掘到底层的需求</p><blockquote><p>我们引用老乔的一句话，产品是技术和艺术的结合，或者产品是技术和人文的结合…..但是你怎么样在你的产品里面去包含这种人文或者艺术的成分？这是挺不容易的。</p><p>对于一个产品经理来说，需要提高自身修养的一个方向，在技术之外的人文方面有一些自己的认识</p><p>其实产品是可以表达产品经理自己情感的地方，如果大家用得好的话。……所以你看如果你把你个人的情感包含到产品里面，是一件很爽的事情。</p></blockquote><p>除了技术之外也需要提升自己的人文修养</p><blockquote><p><strong>所以有的时候，我们的产品经理经常是在做坏事，不是做好事，因为他拼命的引入新的功能进来，后面反正又不用自己写代码就不管，然后就把开发的累死了。</strong>……因为我们要冒出一个想法来，太容易了；但是我们要知道这个东西是一个正确的想法，就太难了。</p></blockquote><p>控制需求的能力</p><blockquote><p>其实研究客户心理就是研究自我，很多时候我们是瞄准自我的需求来做产品的。……当我们研究不到用户需求时，我们就会说只要让我们自己用得爽…..怎么样让用户用得爽呢？……一个比较简单的方法，把自己当作一个傻瓜来用产品，傻瓜心态。……他没有这么多的背景，他们用这个东西只是第一眼的感觉或者用一次，一、两分钟的体验就决定了。</p></blockquote><p>把自己当傻瓜用产品，傻瓜心态，一秒变傻瓜的能力</p><blockquote><p>使他（用户）感受趋势才是最重要的，因为用户只能够对过去的事情产生认知，未来的东西才是趋势，你怎么<strong>知道下一阶段会流行什么样的潮流，那才是最重要的</strong>。我们怎么去了解这个趋势是什么？有很多方法，很多人去分析数据【分析数据也有弊端，举了修理飞机的例子】</p><p>感知趋势是来自于我们的各种渠道，包括生活中的各种渠道，或者微博上的各种渠道。我自己的个人喜好我会看一些论坛或者微博这样的东西，去看这些离我很远的用户，他们在什么样的氛围、什么样的场景里面去用我们的产品。</p><p>坚持一个习惯，以前提过1000、100、10这样的习惯，就是说每周要去看1000个帖子，不管是微博的，还是哪里的。要看100天博客，要做10个CE这样子的。</p><p>之前就有一句话说web已经死掉了，大概从移动互联网的发展趋势来说，确实是有这个趋势。…..因为PC的不增长和手机的快速增长，这个对比实在是太强烈了。……而手机端的话，浏览器可能不是一个主要的入口，可能APP才是。</p><p>而且APP的趋势，不是要做一个大而全的APP，而是说做成尽可能小的APP。为什么不是大而全的呢？因为用户很懒，我要看天气，我就点天气的APP。我要看股票，就点股票的APP。我不会跑到腾讯所有服务的APP里面去，然后钻到里面去找天气、找股票。</p></blockquote><p>感知趋势的能力</p><blockquote><p>用户要什么我们就给什么，这个在很高层的用户里面甚至也会出现这个问题。比如说你的上级可能会给你说，你看用户给你提出这个需求了，你为什么不做？……为什么不做？因为我们觉得不能用户要什么就给他什么，要变个花样给他，用户要的不一定是对的。…..所以这种需求挺多的，但是我想表达的是如果我们针对需求一个人去满足，你可能获取了这部分用户，但是得罪了另外一部分用户。</p></blockquote><p>把控需求的能力，不要人云亦云，要有自己的思考</p><blockquote><p>但产品也是，一个产品里面很简单的一个产品可能也包含了上百个功能在里面，这些功能你可以像写代码一样的，你可以按一个线性的方式把它串起来，但是也可以做成一个很有架构在里面的东西。…….我们心中一定要有一个产品的架构在这里，而不是说我们这个产品就是一大堆功能的集合，只是一个无序的集合那样就很糟糕了。</p></blockquote><p>产品架构的能力，产品不仅仅是功能的堆砌</p><blockquote><p>一个产品技能的心态，这也是我感触比较深的，就是跟人讨论问题的时候会争论起来。<strong>对产品性能来说我觉得它是抱着一种求知的态度来讨论</strong>，而不是争论谁赢了谁输了这样一个观点。如果是这种求知的话，当别人说服了你，辩赢了你，那你很高兴，因为你接触到了新的知识。应该是说很鼓励这种辩驳，但不是为了自尊心而战。</p></blockquote><p>抱着求知的心态看待和讨论产品</p><blockquote><p>作为产品经理来说，一方面是自身要保持饥渴，保持一个觉得自己很无知的状态。</p><p>最后说的就是——我所说的都是错的。</p></blockquote><p>总结一下</p><ol><li>拥有好奇心，洞悉人性，理解贪嗔痴，善于抓住用户心理诉求的本质，挖掘到底层的需求</li><li>基于用户体验的产品思路，变傻瓜的能力</li><li>感知趋势的能力</li><li>设计出简单规则的能力</li><li><p>打造有“温度”、有“骨架”、有“灵魂”（PM的爱恨情仇）产品的能力</p></li><li><p>除了技术之外也需要提升自己的人文修养</p></li></ol><p>产品不应该是冰冷的工具，乔老爷子如是说：“产品是技术和艺术的结合，或者产品是技术和人文的结合”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在读有关张小龙的材料，觉着最真实、最有价值的还数龙哥在还未封神之前饭否的言论啦。花了好几天，断断续续的读完，泪流满面啊，龙哥牛逼，研究产品都搞到哲学、人性层面了，但感觉自己能吸收的东西了了。那就先写下自己当前的想法，另记下认为比较经典的话，以后可以常来翻一翻，常看常新吧
      
    
    </summary>
    
      <category term="产品设计" scheme="http://haoweiguang.me/categories/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="张小龙" scheme="http://haoweiguang.me/tags/%E5%BC%A0%E5%B0%8F%E9%BE%99/"/>
    
      <category term="产品经理" scheme="http://haoweiguang.me/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>张小龙饭否摘抄</title>
    <link href="http://haoweiguang.me/2019/10/16/%E5%BC%A0%E5%B0%8F%E9%BE%99%E9%A5%AD%E5%90%A6%E6%91%98%E6%8A%84/"/>
    <id>http://haoweiguang.me/2019/10/16/张小龙饭否摘抄/</id>
    <published>2019-10-16T06:11:52.000Z</published>
    <updated>2019-10-16T06:17:13.638Z</updated>
    
    <content type="html"><![CDATA[<p><strong>网络&amp;群体</strong></p><p>你的价值在于一个集体对你的认证,这是很多人具备的意识。然后这个意识再被sns网站利用,又增强了这个意识。 </p><p>物种多样性:一个物种并没有进化为全能生物,相反,只加强它独具的一个功能才能让它生存。 </p><p>动物会向中心聚集,处在边缘的动物会有被天敌吃掉的危险。成千上万人在一个时间段看和谈论一部最新的电影,也是同样的心理:不看的人会地处文化的边缘,隐性地影响交配权。 </p><p>将来每个人需要两个微博,一个是社交型微博,一个是自我表达型微博。 </p><p>社交网络,并不是好友越多越好。 </p><p>sns上,一下子给我100个好友,怎能给我一个一个去发现和找到好友的乐趣呢。 </p><p>社会是所大学,选修表演专业者众。 </p><p>陌生人组成的社区,虽然冰冷,但是去掉了熟人社区的温情和虚伪,多了规则。 </p><p>评论的意义:一个人如果自顾自写东西会写到离谱,评论相当于自动控制系统的负反馈,让人从偏激中收缩,趋于稳定。最终一个社区的个体互相影响,形成一个稳定的中庸的气场。 </p><p>人分熟人,半熟的人,陌生人。沟通方式有广播,群展示,群聊,单聊。排列组合是满足不到人们的需求的,因为基因的选择策略不是这么机械。重要的是,让人不自觉地掉进圈套,而不是让他建立圈子。 </p><p><strong>人性</strong></p><p>用手指同步自己的话到各个微博,原来是基于一种自我肯定和自我赞赏的快感,在paste的时候有机会欣赏到作品的复制和传播,这种快感源自基因的“复制和传播是第一目的”。任何自动同步工具都是扼杀这种快感的,因此会被基因排斥,这种同步产品注定失败。 </p><p>往往能够获胜的,不是真善美,而是贪嗔痴。因为后者更给力。 </p><p>你说的每一句话都是炫耀。因为,当你想说一句话的时候,你的意识里其实有1亿个念头在动,它们像精子一样争先恐后,最终,最炫的那个念头胜利了,成为了那句话,成为了冠军,获得了从你口里说出来的权力。 </p><p>方向盘是手的延伸,油门刹车是脚的延伸。汽车并不单是个运输工具, 而更像人工肢体。开车和坐车是不同的。对驾驶者来说,汽车是有生命的。 </p><p>手机是人的最重要的人工器官。 </p><p>手机是人的躯体的延伸,手机发博才是躯体对世界的回应,越来越感觉如此。 </p><p>人们等待一个平板电脑的发布,因为那是他们的第三支手第三只眼,所以,重量和分辨率是头等重要的。 </p><p>这么多年了,我还在做通讯工具,这让我相信一个宿命,每一个不善沟通的孩子都有强大的帮助别人沟通的内在力量。 </p><p>做自己的人又分两种,一种不断打破自己,一种沉溺于自己。 </p><p>人会集中注意力做一件事情,因为这样可以避免胡思乱想。这是一种基于生存本能的自我保护动作。 </p><p>人只是基因操作的一台机器,绝大部分的生存和选择策略,已经被写在基因的程序库里。人只是不自觉地听从这些基因制定的策略的指挥,却以为是自己的头脑做的选择。少数人可以挣脱并产生自己的选择策略 </p><p>基本人性需求,不应该压抑。谢安听说打破苻坚的军团之后,强行忍住了得瑟的冲动,结果把自己木屐的齿都折断了。谢安是宰相,折木屐。普通人的话,恐怕太压抑会折JJ的说。 </p><p>好战是人的天性,所以任何一个团队或者产品都要树立一个敌人来提振精神,哪怕没有敌人都要找一个假想敌。 </p><p>人就是环境。人就像变色龙,进入到环境就会去适应,最终成为那个环境的一部分。比如在微博上,环境就是听众,发表的言论自然就是适合粉丝听的言论。环境就是个天然的过滤器。 </p><p><strong>产品</strong></p><p>还是你们用户爽,哪里爽到哪里,苦的是做互联网的,要整天分析你们的阴暗心理好让你们更爽,还不能明说。 </p><p>一个产品,要加多少的功能,才能成为一个垃圾产品啊! </p><p>产品往往是做着做着,就主旋律了,因为跟着用户走,用户爱听主旋律的歌。 </p><p>虽然人人都说简单是美,但没有几个人真正喜欢简单的。看看这个越来越复杂的世界就知道了。 </p><p>产品就象一个生物,有它自然的进化之道。最重要的,是制定好产品的内在基因的“竞争策略”,让竞争策略在进化中再自行演化为具体的表现形态。如何搞?没想清楚。 </p><p>异议就象基因的突变,有突变才能滋生出更强的新一代基因。 </p><p>基因并不会思考,它们只是漫无目的的胡乱产生变异,有些碰巧更有利于生存,就存活下来了。 </p><p>如果说产品做的一切都在满足用户的虚荣,热闹,逃避,贪恋等,那么,大众同样都有受虐的心理,为什么不做一款产品去虐待他们? </p><p>平均每天收到一张iTunes Store的帐单。我要在apple上疯狂消费,来赎回以前在windows上狂用盗版的罪。【张小龙在app store体验了很多应用】 </p><p>twitter的创始人起先无所事事,就去钓鱼,看到鱼儿成群结队的拥挤,生怕掉队,于是得到启发,便开发了twitter,方便人们成群结队。 </p><p>网络尚未普及的时候,产品必须依靠功能多来取胜,并且产品是自成一体的。网络普及后,才催生出一种新的产品形态:产品极简,反而有利于在网络这个大生命体中自我繁衍,并且产品是面向连接的。</p><p>好的网络产品,必然是无法预料其会不会成功的。成功的产品,刚好是“碰巧”成功了。但这个碰巧并不是创造者的运气,而是,这个产品刚好能在网络生命体中生存和繁殖。就像我们无法知道一个小孩为什么成长如此迅速一样,我们无法知道一个网络产品为什么会成功,即使做的人,也应该感谢主。 </p><p>如果说一个细菌能够自然粘上另一个细菌是细菌的“意识”,一个极简的产品元素的能够连通另一个用户的接口,就是一种连接“意识”。那么这个接口就是有“意识”的。接口是主人,人是接口要使用的对象。 </p><p>一个被人预见必然会成功的产品,必然会是个失败的产品。成功的产品是不能预见的。至少,是不能被人所预见的。机器来预见还有可能。 </p><p>因为我们无从知道复杂生命体的运作规律。 </p><p>缘起,性空。 </p><p>互联网产品应该是由用户推动，而不是产品经理来推动。产品经理的作 用只是找到四两拨千斤的地方稍微用点力。 </p><p>流通正在取代内容本身,内容变得更小更方便传播。mp3取代唱片,微博取代书本,短信取代信件。我怀疑有一天,微小的内容也没有了,大家直接通过网络交换荷尔蒙。 </p><p>和“敌人比我们自己更了解我们”相对应的是,用户比我们自己更了解我们的产品。产品是有人用才成为有灵魂的产品,图纸和代码堆出来的只是躯壳。 </p><p>你问我们和竞争对手比有什么区别,我说我们没有他们那些臃肿艳俗的部分。 </p><p>FaWave这类工具,汇集了多个产品的数据和功能,看似提高效率,但人毕竟不只是效率工具,汇集类工具脱离了原产品的气息后,就丢失了对产品的情感认同。 </p><p>心有千千结,每种结都是一个产品。关系千万重,每种关系都是一个产品。未来世界,应该是每个人都会做一个十个用户的产品的时代。 </p><p>网站的发展趋势是,内容有标题的都不行了,没有标题的才兴起,如twitter,facebook。我现在好奇的是,quora的是有标题,还是没标题? </p><p>哥做的不是产品,哥做的是发挥潜力的自由。 </p><p>IM是没有前景的,因为破坏了“让人更轻松互连”的定律。IM可能需要尽快将双向关系转换到单向关注体系中。 </p><p>用户的忍耐力太强了,最后就不辩美丑了 </p><p>美女们是否爱用,是产品能否流行起来的风向标。特别是天上人间的。 </p><p>一晚上没睡着,想明白了一件事:单对单聊天是通讯工具,多人聊天是社区。 </p><p>手机开发,对体验的要求更高了,一寸短,一寸险。 </p><p>以后招产品经理,直接给他一个小电器,比如mp3播放器,让他写个产品使用手册,就知道行不行了。 </p><p>程序员当然不知道产品的走向,但产品人员就知道吗?也不知道。不同的是,程序员会盲目创造出100个尝试后,总有一个胜出并生存下来。生存的这个就是走向。 </p><p>facebook为什么在国外这么火?因为他们的生活是在是太单调了。 </p><p>产品总是会包含功能之外的价值观的。因此不能指望天朝设计的产品能被世界认同。 </p><p>哥喜欢的不是产品,是战争。 </p><p>互联网产品,好友是如何来的?必须是用户自己手把手拉来的。任何的批量好友导入,都是收效不大的。 </p><p>原来产品的气质,无非是说做产品要带些文艺。 </p><p>互联网的最终目的,是让关系学见鬼去。 </p><p>产品人是站在上帝身边的人 </p><p>think less,live more </p><p>信息越透明,整合的作用就越小。不在单点突破,而希望依靠整合来成事,是老套路了。所以N合一的东西一般很垃圾。网络的使命,包含了取缔整合。整合是系统来自然演绎的,不应该是人干的事。 </p><p>做产品,最要紧是保持十年如一日的新鲜感。 </p><p>怎么能跟战略部的人谈产品呢,他们面对的是评论家,我们面对用户。 </p><p>周国平说,即使产品是个悲剧,我们也要做得有滋有味。即使用户都是傻逼,我们也要帮他们装得有声有色。 </p><p>深夜,突然悟到Jobs说的“Stay hungry , stay foolish”,原来本意是对用户说的,“让你们保持饥渴,让你们保持愚蠢”。 </p><p>要提防那些Blog写得好的产品经理,因为在Blog上花的时间越多,在产品上花的时间就越少。原来还以为有例外,现在看起来无一例外。 </p><p>告诉大家一个秘密,苹果为什么崇尚白色?崇尚一个按钮的设计?因为他们的首席设计师乔纳森之前搞工业设计是浴室用品领域。想想马桶吧。 </p><p>互联网的产品,哪怕任何一个非常小的产品,其实都想一场战争,一场瓜分资源的战争。用户就是待瓜分的资源。 </p><p>做产品,就是跟用户谈一场恋爱,否则只是一场商业交易而已。产品人是多么的博爱啊。 </p><p>面试产品经理,所有技能合格后,要问,你喜欢摇滚吗。回答否的,就算了。 </p><p>我在生活上不是一个有洁癖的人,但对待产品却分毫必究,介大概就是传说中的精神分裂吧。 </p><p>很多人看到MJ的海报说pm心中有爱。不是爱,是愤怒。 </p><p>从前的理论是,市场营销是炮弹,打炮才能带动销量。现在的情况是, 产品本身是炮弹,只要爆炸力强就能炸晕一片用户。 </p><p>Instapaper本来就是小众,走收费路线可以理解。whatsapp那才叫牛逼,大众软件依然收费。【小众软件可以收费】 </p><p>如果社会进步到没有商人了,生产的人直接赚钱,该是种进步吧。appstore所以好。 </p><p><strong>用户体验</strong></p><p>原研哉:设计是为了让人在高速的现代生活节奏中更轻松,而非更紧张。 </p><p>原研哉:古人需要复杂的物品装饰图案和式样来吓唬敌人和统治民众, 现代人不再需要装饰有这类作用,因此流行简约设计。我感觉我生活在古代,因为我也不能完全接受简约。 </p><p>检验你是否真的接受简约的方法是,把家里装修成现代简约风,如果你住上几个月没疯,就通过了。 </p><p>我们遵循一个很古老的设计原则:UI人员禁止使用同类产品,但PM必须博采众长,PM将需求转述给UI去设计。这样避免UI进入思维定势 </p><p>多任务,在windows上是alt tab,在iphone上是双击马桶按钮,在macO S上是四个指头往下一撸。原始的就是人性的。 </p><p>需要说明书的产品不是好产品。需要弹tip告知用户如何使用的功能不是好功能。 </p><p>每天都有很多产品发布或升级,介绍都是罗列功能指标。用户又不是按功能来付费的,你列那么多新功能去完成kpi没有问题,去糊弄用户就不对了。 </p><p>我不喜欢的UI例子:弹tip;半透明遮盖;页面上来一块固定toolbar;令人不解的数字;etc </p><p><strong>创新</strong></p><p>问:深泽直人,为什么无印良品要创新呢?答:战后日本刚开始也都是模仿,因为模仿就可以在市场立足了。但是后来用户逐渐不买模仿的帐了,自然,企业必须要创新才能生存了。所以,创新是用户逼的。 </p><p>关于创新：1,创新是无稽之谈。创新不是决定取舍的理由。创新一般都是空想。创新是靠不住的,死得很快的。2,要的,是把握用户心理。其结果,才被观察为创新。3,创新是件碰运气的事,你只是蝴蝶,剩下的交给云。ppt over。 </p><p>指望中国人比西方更创新,是不太靠谱的。创新是基于用户环境的,比如我们都还没有普及智能手机,自然不会催生出一个智能手机普及环境下的创新应用。 </p><p>大部分的所谓创新,都是把问题搞复杂化而已。 </p><p><strong>思维</strong></p><p>程序设计最近20年的发展,是引入了更“自然”的思维方法:万事万物有其“基本类型”,高级类型是从基本类型派生出来的,并呈多态性,高级的个体是高级类型的实例,个体之间是通过消息来通讯的。这就是C++的全貌,虽然很多C++程序员对此理解不深。我想说的是,这也是PM分析问题的法宝。 </p><p>思维习惯和思维方法,其实是可以训练出来的。那么,为什么大学没有做产品这门课呢? </p><p>词语只是金属表面散射出来的一点点光,虽然能汇集成为耀眼变换的光,却还只是变换的光。 </p><p>《黑天鹅》里总结得太好了:人有天生的归纳能力来将复杂事物模型化。但这也导致人的认知误区,没有见过黑天鹅就认为天鹅都是白的。 </p><p>《黑天鹅》让我知道我是如何被我的经验和直觉所愚弄了。 </p><p>成功是个概率事件,这些传记可以当故事看,但不能当推理看。 </p><p>勤奋只是一种长年形成的癖好。 </p><p>程序语言和自然语言一样,都是对想法的整理和表达。因此我现在面试程序员,不让他写程序做题了,改为聊天。 </p><p>无欲则刚,一欲则强,多欲则乱</p><p>Think Different!我经常用这句话来提醒自己,我没有乔老爷的才,一定不能因为要think different而走火入魔。 </p><p>好奇心和发现是最值得珍惜的品德。 </p><p><strong>其他一些思考</strong></p><p>这两年,我博览了群书和群山,路过了死亡之谷和罪恶之源,现在终于可以坐下来喘口粗气了。 </p><p>少用电脑多看书,多看电影少上网 </p><p>你看到一本说出你心里话的经验之谈的书,然后会很痛苦,因为这类书是于人无益的:能明白的,不看此书也自然会明白。不明白的,看了此书也不会有改变。 </p><p>所以我后来发现,人不是培养出来的,是给他们土壤,然后,有才能的人自己会成长起来的。甚至不需要我分享什么。后来我就不培养人了,只观察人了。 </p><p>一个热衷于打勾的国度。源自对盖印的崇拜。盖印又源自宝塔葱白。 </p><p>古时候,男人出去打猎,是没有计划的,遇到什么打什么,也可能空手而回。今天的男人每天规定必须要打几只狼回来,就焦虑了。 </p><p>原来光有好的想法没用,还要有渠道才能传播出去。问题是,渠道反过来又会选择性传播和放大不该传播的。 </p><p>想法如同基因,有生存价值的想法最终会取得传播的胜利。这是《自私的基因》里关于文化基因的观点。 </p><p>整天将KPI挂在嘴上,以KPI为目标来工作的leader,都是不合格的,庸俗的,没有想法的,令人痛苦的,无法言语的。 </p><p>转:“人们往往出于责任做慈善,但事实是,做慈善有益于自己的身心, 有助于自己了解生活。我从难民身上学到了最多东西,比如如何当母亲、做一个坚强的人并生存下去,所以我只是希望能回报一些东西。”– 安吉丽娜朱莉 </p><p>我们总说每个人都是独一无二的,但同时又要求每个人都有一样的能力,因为不能提供给每个人独一无二的职业。 </p><p>人多了做事情就痛苦。哥的理想是,以后一个人弄一个很大面积的办公室,养花种草写程序,一个人做,爱怎么搞怎么搞。 </p><p>马太效应揭示出,不光是人会往人多的地方走,就连金钱都是这样。 </p><p>太初,人太自由了,于是,要有约束,便有了节日。大大小小的节日。 </p><p>如果工作不是被好奇心驱动,不如回家卖红薯。 </p><p>在一个平庸的人群里,需要有人独断专行 </p><p>转:人生的成长过程之中,要是不彻底的绝望一次,就不知道自己身上什么东西,决不可放弃,也就不知道什么是真正的快乐。——吉本芭娜娜《厨房》 </p><p>如果不是有乔老爷这只黑天鹅,我差点就相信三十岁以上的人都已经属于被时代脉搏淘汰的人了。 </p><p>愚人节的真是含义是,让人自省一下自己其实是个愚人。这一天,每个人都应该戴个驴面具上街的。 </p><p>人一成功,就喜欢将归纳法当作推导出真理的方法。 </p><p>人要成功很难,比成功更难的是,知道自己的成功是偶然的。 </p><p>归纳法来推导结论是错误的。所以很多时候,比拼的是谁更能独断专行。不过独断专行也是依赖在历史经验的基础上归纳出来的思路。 </p><p>陪练要找高手。 </p><p>群体互联时代,靠个人或者中心影响力来做宣传,显得不合失宜。 </p><p>没有压力和压力过重,都会导致不可承受的轻。 </p><p>王阳明是个了不起的人。看他的著作,不如在实践中尝试无畏。 </p><p>为了证明人是环境的反应器,在自然环境中才会产生更多的想法,我做了个实验,用语音记事本记录了今天在路上的十分钟产生的想法,结果发现,路上的思维很活跃。 </p><p>与其说乔布斯的强大在于对市场,商业,管理的洞察,不如说是对人性的洞察。 </p><p>我相信将来会有一种随时随地的微博形态来取代现在的微博。因为人在环境中实时产生的反应才是丰富而有实感的,而坐在电脑前产生的反应,是对电脑里的虚拟思维做二次反应。 </p><p>如果不能做一些特别的事情,那做它有什么意义呢。 </p><p>上帝让众生平庸,是不想看到他们都变成精神病 </p><p>一个理想的人生应该这么过,四十岁前把所有的欲望满足一遍,四十岁后过没有欲望的生活 </p><p>幸福感不一定和财富成正比,却和无知度成正比。 </p><p>丹·艾瑞里在《怪诞行为学》中,用大量的历史案例与实践经验证明:在很多时候,不是消费者的购买意愿影响市场价格,而是市场价格影响了消费者的预期,进而影响购买。 </p><p>在这本书中,高汀断言,我们已经进入了一个消费者几乎已经拥有了所必需的一切、很难有东西能激起其消费欲望的后消费时代,传统的面向大众的产品定位和老的营销法则即将衰亡,在这个需求饱和的时代,一种产品想要卖得出去——遑论获取成功——必须是值得注意的、例外的、全新的、有趣的 </p><p>从前的理论是,市场营销是炮弹,打炮才能带动销量。现在的情况是, 产品本身是炮弹,只要爆炸力强就能炸晕一片用户。 </p><p>要么你让市场营销人员去前线大炮,费钱费精力。要么你直接让用户打炮,一劳永逸。 </p><p>老乔是Intel的葛洛夫的唯有偏执狂才能生存的证明人。 </p><p>偏执需要权力的辅佐才能进行到底。 </p><p>中国的教育是扼杀好奇心的完美历程。 </p><p>写文章,做网站,写代码,要求的能力都是一样的,就是条理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;网络&amp;amp;群体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你的价值在于一个集体对你的认证,这是很多人具备的意识。然后这个意识再被sns网站利用,又增强了这个意识。 &lt;/p&gt;
&lt;p&gt;物种多样性:一个物种并没有进化为全能生物,相反,只加强它独具的一个功能才能让它生存。
      
    
    </summary>
    
      <category term="产品设计" scheme="http://haoweiguang.me/categories/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="张小龙" scheme="http://haoweiguang.me/tags/%E5%BC%A0%E5%B0%8F%E9%BE%99/"/>
    
  </entry>
  
  <entry>
    <title>我为什么写作</title>
    <link href="http://haoweiguang.me/2019/08/29/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E4%BD%9C/"/>
    <id>http://haoweiguang.me/2019/08/29/我为什么写作/</id>
    <published>2019-08-29T05:55:18.000Z</published>
    <updated>2019-10-17T05:57:40.761Z</updated>
    
    <content type="html"><![CDATA[<p>其实我对写作有很大的心里恐惧。还记刚上初中时，因为作文写不好彻夜难眠，也哭了无数次。有一次考试作文竟然只憋出来了6行，得了6分，至今难忘。但是我认为写作还是很有用处，所以也就硬着头皮写吧，以下说说我对写作的理解。</p><p>写作大概能分为两种，一种是为自己而写，主要想通过写作来更好的学习、思考、记录、复盘等；一种是为他人而写，通过写作扩大影响力、赚钱等等。我的目标是“<strong>为自己而写</strong>”。</p><p><strong>为了深度思考</strong>，把自己学的东西。通过写作，将自己的思考转换为文字后，很多实践经验和总结往往才能够真正的系统化和结构化，同时完成整个思维的抽象和升华过程。写作有时候像教人，能把一件事写明白了，证明自己掌握的也挺好的了。</p><p><strong>让自己慢下来</strong>，平时看的太多，太杂，除了通过写作来梳理，为了更好的吸收，其实<strong>写作是真正能够让人平静下来的事情</strong>，写作是在安静的时候，一个人，自己和自己的心灵的对话，让自己听到自己内心的声音。</p><p>也有一些<strong>交流的需要</strong>，我现在有个习惯，就是如果觉着一个人思想还不错，我就会去找他的博客、公众号等，把他写的文章看一遍，就能大概了解这个人了，减少了沟通的成本。</p><p>你们有没有觉着回忆是不准确的，我们经常修改和美化自己的记忆，以验证自己当下的判断（就像“禀赋效应”那样）。所以记录下来，回头再看，是对自己成长过程最好的交代。另外，记录当时状态对于人生也是一份宝贵的财富。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="noopener">为什么你应该（从现在开始就）-刘未鹏</a></li><li><a href="https://fatesinger.com/100080" target="_blank" rel="noopener">当我谈博客时我在谈些什么-Fatesinger</a></li><li><a href="https://yukunwu.wordpress.com/why-write-blogs/" target="_blank" rel="noopener">为何写作-zero</a></li></ul><h3 id="Revision-history"><a href="#Revision-history" class="headerlink" title="Revision history"></a>Revision history</h3><p>2019.8.29 开写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实我对写作有很大的心里恐惧。还记刚上初中时，因为作文写不好彻夜难眠，也哭了无数次。有一次考试作文竟然只憋出来了6行，得了6分，至今难忘。但是我认为写作还是很有用处，所以也就硬着头皮写吧，以下说说我对写作的理解。&lt;/p&gt;
&lt;p&gt;写作大概能分为两种，一种是为自己而写，主要想通
      
    
    </summary>
    
      <category term="随笔" scheme="http://haoweiguang.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="写作" scheme="http://haoweiguang.me/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>程序员健康生活指南总目录</title>
    <link href="http://haoweiguang.me/2019/04/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%81%A5%E5%BA%B7%E7%94%9F%E6%B4%BB%E6%8C%87%E5%8D%97%E6%80%BB%E7%9B%AE%E5%BD%95/"/>
    <id>http://haoweiguang.me/2019/04/22/程序员健康生活指南总目录/</id>
    <published>2019-04-22T07:07:16.000Z</published>
    <updated>2019-04-22T07:07:16.971Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git分支策略-我的实践</title>
    <link href="http://haoweiguang.me/2019/03/18/Git%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5-%E6%88%91%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://haoweiguang.me/2019/03/18/Git分支策略-我的实践/</id>
    <published>2019-03-18T08:23:59.000Z</published>
    <updated>2019-10-18T08:58:55.137Z</updated>
    
    <content type="html"><![CDATA[<p>具体策略还是要根据项目的大小和复杂度来定。遵循的原则是先简单，然后根据项目情况不断的精细化，不要上来就搞一个特别复杂的规则。</p><p>这样做的好处：</p><ul><li>简单，团队更容易接受、执行，更易操作</li><li>简单也更不容易出错</li></ul><p>如果是个全新的项目，我觉着保留一个主干master，和线上代码一致，仅用来发布新版本。不用非得维护一个develop分支，这样反而麻烦。在项目上线之前，规则都相对简单。但是等项目上线后，问题就慢慢复杂了。因为你分支策略还得考虑怎么保证master和线上一致。我们分多个场景来讲：</p><h3 id="场景1-我们要添加一个新功能"><a href="#场景1-我们要添加一个新功能" class="headerlink" title="场景1 我们要添加一个新功能"></a>场景1 我们要添加一个新功能</h3><h4 id="场景1-1-当前没有并行的功能"><a href="#场景1-1-当前没有并行的功能" class="headerlink" title="场景1.1 当前没有并行的功能"></a>场景1.1 当前没有并行的功能</h4><p>1.开发的时候先从master建一个功能分支，命名：Feature-xxx，后续在此基础上做开发就行了，视情况决定是否建个人分支（命名：Feature-xxx-light）</p><p>2.功能开发完成，准备提测，如果是按照瀑布模型开发，可以直接把Feature分支的代码部署到测试环境（QA），发现bug直接在此分支修改就行，然后部署到测试环境；如果是敏捷开发，那最好分出来一个测试分支，因为该功能分支还得继续开发，可能会包含未完成的功能，这时候如果拿功能分支部署测试环境，会遇到问题。如果开辟了一个测试分支，这样就把开发跟测试隔离了，测试环境的bug什么都可以在测试分支搞定。</p><p>3.（可选）  开发测试完成提交到pre-production</p><p>4.（可选）  进一步测试没有问题提交到release分支</p><p>5.后续就是上线，则合并到master分支，并在master分支上做发布</p><p>6.（可选）  如果需要延迟发布则新建production分支（比如，等待iOS审核，需遵守upstream first）</p><h4 id="场景1-2-有多个功能并行"><a href="#场景1-2-有多个功能并行" class="headerlink" title="场景1.2 有多个功能并行"></a>场景1.2 有多个功能并行</h4><p>可能有个极端情况就是两个团队需要开发同一个功能，我觉着这种情况在前期任务划分的时候就应该尽量避免掉，实在无法避免，可以让一个团队负责开发，并暴露接口供另一个团队调用</p><p>其实流程跟场景1.1差不多，就是从哪里新开分支，怎么合并会遇到些问题？</p><p>还是从master创建分支。合并的时候根据项目情况选择是合并到pre-production或release，反正最终要合并到master分支并做发布。</p><h3 id="场景2-发现了线上bug"><a href="#场景2-发现了线上bug" class="headerlink" title="场景2 发现了线上bug"></a>场景2 发现了线上bug</h3><p>最重要的是记得记得保存当前的代码，别一着急把当前的代码丢了，那真会欲哭无泪。<br>1.如果本地还在开发，记得先使用git stash暂存，以免切换到master后代码丢失</p><p>2.从master创建本地bug分支，命名：bugfix-xxx</p><p>3.修复bug</p><p>4.（可选）修改测试完成后依次同步到pre-produciton和release分支</p><p>5.各个环境的测试通过，合并到master，并在master上做发布</p><p>6.切换到自己的开发分支，使用git stash恢复暂存，继续工作</p><p>但这些也不够全面，想到哪写到哪，后续持续迭代吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体策略还是要根据项目的大小和复杂度来定。遵循的原则是先简单，然后根据项目情况不断的精细化，不要上来就搞一个特别复杂的规则。&lt;/p&gt;
&lt;p&gt;这样做的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单，团队更容易接受、执行，更易操作&lt;/li&gt;
&lt;li&gt;简单也更不容易出错&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
      <category term="利器" scheme="http://haoweiguang.me/categories/%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="Git" scheme="http://haoweiguang.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>比特币的前世今生</title>
    <link href="http://haoweiguang.me/2018/06/25/bition-history/"/>
    <id>http://haoweiguang.me/2018/06/25/bition-history/</id>
    <published>2018-06-25T13:54:01.000Z</published>
    <updated>2018-06-27T15:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="比特币诞生的背景？"><a href="#比特币诞生的背景？" class="headerlink" title="比特币诞生的背景？"></a>比特币诞生的背景？</h3><p>2008年，金融危机，当时政府和银行管理经济的能力遭到各方质疑，信用降入谷底。美国政府向华尔街和底特律汽车公司注入大笔资金，美联储推出“量化宽松”政策，本质上就是大量印美钞刺激经济，金价上涨。相当于政府拿民众的钱来补贴这些资本家。</p><h3 id="为什么要创建加密电子货币？"><a href="#为什么要创建加密电子货币？" class="headerlink" title="为什么要创建加密电子货币？"></a>为什么要创建加密电子货币？</h3><p>其实一直有一帮自由主义者密码极客希望创建一种完全去中心化的电子现金系统。可以脱离政府自由流通和发展。</p><p>因为之前的信用卡或者货币都存在诸多问题。比如信用卡需要用户的真实身份，对于用户的隐私保护不够。货币就存在超发的情况，政府通过这种方式从民众手里掠夺财富。</p><h3 id="加密电子货币的坎坷之路"><a href="#加密电子货币的坎坷之路" class="headerlink" title="加密电子货币的坎坷之路"></a>加密电子货币的坎坷之路</h3><p>1983年大卫·乔姆（David Chaum）最早提出把加密技术运用于现金上的想法。写了论文《不可被追踪的交易》，使用盲签（blind signature）的技术来实现匿名的网络支付系统。1989年大卫·乔姆创建了数字现金公司；在之前系统基础上创建了电子现金（Ecash）系统，这个系统还有一个别名为网络现金（cyberbucks）系统。得到了微软和visa等巨头的支持。但是因为理念太超前，未得到大范围的支持，另外，该系统支持企业对企业转账也是其失败的原因。</p><p>1998年，戴伟（Wei Dai）阐述了一种匿名的、分布式的电子现金系统：b-money。B.money强调点对点的交易和不可更改的交易记录。每个交易者都保持对交易追踪的权力。但是B.money系统中，大卫并没有解决账本同步的问题。</p><p>1998年，尼克·萨博（Nick Szabo）发明了比特黄金（BitGold），提出了工作量证明机制。</p><p>哈尔·芬尼（Hal Finney）发明了哈希现金（HashCash）则把该机制进一步完善为一种”可重复<br>利用的工作量证明（RPOW）“。“RPOW”的特色在于可重复使用，且虽然控管权集中，但发行者没有通胀压力。</p><p>2008年10月31日，名不见经传的中本聪在metzdowd.com的密码学邮件组列表中发表了比特币白皮书《Bitcoin: A Peer-to-Peer Electronic Cash System》（《比特币：一种点对点的现金支付系统》)。</p><p>2009年1月3日，比特币网络诞生，中本聪本人发布了开源的第一版比特币客户端。</p><p>2009年1月3日，比特币网络的第一个区块诞生了。<br><img src="http://oo501cyv7.bkt.clouddn.com/15301134448308.jpg" alt></p><p>2009年1月9日，中本聪本人发布了开源的0.1版比特币客户端。<br><img src="http://oo501cyv7.bkt.clouddn.com/15301134591691.jpg" alt></p><p>2009年1月12日，第一笔比特币交易，中本聪发送了 10 比特币给开发者、密码学活动份子，Hal Finney（哈尔·芬尼）。</p><p>2009年10月5日，有记录的最早比特币汇率： 1 美元 = 1309.03 比特币。</p><p>参考：<br><a href="https://en.wikipedia.org/wiki/Ecash" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ecash</a><br><a href="https://daimajia.com/2018/02/10/blockchain-share-in-freesfund" target="_blank" rel="noopener">https://daimajia.com/2018/02/10/blockchain-share-in-freesfund</a><br><a href="https://zhuanlan.zhihu.com/p/32754317" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32754317</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;比特币诞生的背景？&quot;&gt;&lt;a href=&quot;#比特币诞生的背景？&quot; class=&quot;headerlink&quot; title=&quot;比特币诞生的背景？&quot;&gt;&lt;/a&gt;比特币诞生的背景？&lt;/h3&gt;&lt;p&gt;2008年，金融危机，当时政府和银行管理经济的能力遭到各方质疑，信用降入谷底。美国政
      
    
    </summary>
    
      <category term="区块链" scheme="http://haoweiguang.me/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="比特币" scheme="http://haoweiguang.me/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链和生产关系</title>
    <link href="http://haoweiguang.me/2018/03/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E7%94%9F%E4%BA%A7%E5%85%B3%E7%B3%BB/"/>
    <id>http://haoweiguang.me/2018/03/11/区块链和生产关系/</id>
    <published>2018-03-11T09:04:27.000Z</published>
    <updated>2018-03-11T09:04:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>之所以说区块链是生产关系，就是因为区块链技术可以很完美地为不同参与者分配利益。各方人对这种利益的分配规则的认可，就是一种共识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之所以说区块链是生产关系，就是因为区块链技术可以很完美地为不同参与者分配利益。各方人对这种利益的分配规则的认可，就是一种共识。&lt;/p&gt;

      
    
    </summary>
    
      <category term="区块链" scheme="http://haoweiguang.me/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://haoweiguang.me/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>《数字黄金》读书笔记</title>
    <link href="http://haoweiguang.me/2018/02/04/2018-02-04/"/>
    <id>http://haoweiguang.me/2018/02/04/2018-02-04/</id>
    <published>2018-02-04T13:42:26.000Z</published>
    <updated>2018-02-04T14:41:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比特币的优势"><a href="#比特币的优势" class="headerlink" title="比特币的优势"></a>比特币的优势</h2><ul><li>匿名</li><li>绝对个人所有</li><li>跨境支付，速度快，手续费低</li><li>抗通货膨胀</li></ul><p>相比于现有货币，具备稀缺，分割性更强，耐用性更强，流通性更强</p><h2 id="比特币的价格"><a href="#比特币的价格" class="headerlink" title="比特币的价格"></a>比特币的价格</h2><p>全世界的黄金的价值应该是7万亿美元。假如比特币在全世界一半的地区流行，每个比特币的价格应该在50万美元</p><p>全球货币种类：170种（来自于维基百科），大概只有5%比较有价值，8种左右，美元、欧元、人民币、日元、英镑</p><h2 id="比特币的价值"><a href="#比特币的价值" class="headerlink" title="比特币的价值"></a>比特币的价值</h2><p>比特币的价值在于存储价值，不一定在交易上有多强悍的功能，类似黄金，比特币它自身有支付功能，但重点不在支付。它的重点是资产，是资产带支付，而不是支付带资产，反过来。什么意思呢？就是这个东西本身像黄金，也是一个商品嘛。但黄金有没有免费的支付，黄金从这边搬到那边要把它搬过去的 ，黄金没有脚不会走过去。比特币就不同，比特币是资产啊，但你叫它走过去，它可以自己走过去的。因为移动数字很便宜，没有成本嘛。所以它是资产带支付。</p><p>13年的时候百度的云保安服务就开始接收比特币支付，这个还挺让人惊奇的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;比特币的优势&quot;&gt;&lt;a href=&quot;#比特币的优势&quot; class=&quot;headerlink&quot; title=&quot;比特币的优势&quot;&gt;&lt;/a&gt;比特币的优势&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;匿名&lt;/li&gt;
&lt;li&gt;绝对个人所有&lt;/li&gt;
&lt;li&gt;跨境支付，速度快，手续费低&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="区块链" scheme="http://haoweiguang.me/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="比特币" scheme="http://haoweiguang.me/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="区块链" scheme="http://haoweiguang.me/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="读书笔记" scheme="http://haoweiguang.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习笔记——配置监听</title>
    <link href="http://haoweiguang.me/2017/09/26/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%9B%91%E5%90%AC/"/>
    <id>http://haoweiguang.me/2017/09/26/Oracle学习笔记——配置监听/</id>
    <published>2017-09-26T07:58:26.000Z</published>
    <updated>2017-09-26T07:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是监听"><a href="#什么是监听" class="headerlink" title="什么是监听"></a>什么是监听</h3><p>如果你做过网络开发，对于监听listen就比较熟悉了，监听是什么，在网络开发中，就是监听某个端口，等待客户端的连接。同理，在Oracle中，监听的意思也和这差不多。</p><p>在Oracle数据库服务器中，通过一个叫“监听器”的组件接收来自客户端的连接请求，它是客户端和 服务器端中间的桥梁。监听器虽然在Oracle服务器端，但是它和Oracle主进程并不绑定，它是一个独立运行在服务器端的后台进程，独立于数据库运行。它负责对客户端传入的连接请求进行监听，并且对服务器端的连接负荷进行调整。当客户端准备建立一个到服务器端的连接时，监听器接收客户端的连接请求， 然后再将这个客户端连接请求交给服务器进行处理，一旦客户端和服务器建立连接，客户端和服务器以后就直接进行通信，而不再需要监听器的参与，这就好比师傅 领进门，修行靠个人。就如下图所示：<br><img src="http://oo501cyv7.bkt.clouddn.com/15064117419478.png" alt></p><ol><li>客户端向服务器端发出连接请求，监听器监听到客户端的连接请求；</li><li>监听器把客户端的连接请求交给数据库服务器进行处理；</li><li>经过监听器建立连接以后，客户端与服务器端就可以直接进行通信，而不再需要监听器的参与了。<br>以上就是监听器干的活，也就是说，你对数据库服务器的第一次，肯定会给监听器，如果监听器没有配好，你就甭想连数据库了。那么，怎么才能配好监听器呢？主要涉及以下三个文件：</li></ol><p><strong>listener.ora、sqlnet.ora和tnsnames.ora文件</strong></p><h4 id="listener-ora文件"><a href="#listener-ora文件" class="headerlink" title="listener.ora文件"></a>listener.ora文件</h4><p>打开listener.ora文件看看，贴上一部分有代表性的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#这是一个名为LISTENER1的监听器</span><br><span class="line">#监听的协议是TCP协议</span><br><span class="line">#监听的主机IP是127.0.0.1</span><br><span class="line">#监听的端口是1521端口</span><br><span class="line">LISTENER1 =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">    (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#记录了监听器LISTENER1服务的全局数据库名、数据库路径和数据库实例名</span><br><span class="line">SID_LIST_LISTENER1 =</span><br><span class="line">    (SID_LIST =</span><br><span class="line">        (SID_DESC =</span><br><span class="line">            (GLOBAL_DBNAME = ORCL)</span><br><span class="line">            (ORACLE_HOME = C:\Oracle11g\product\11.2.0\dbhome_1)</span><br><span class="line">            (SID_NAME = ORCL)</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="sqlnet-ora文件"><a href="#sqlnet-ora文件" class="headerlink" title="sqlnet.ora文件"></a>sqlnet.ora文件</h4><p>打开sqlnet.ora文件看看，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQLNET.AUTHENTICATION_SERVICES= (NTS)</span><br><span class="line">NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT)</span><br></pre></td></tr></table></figure><p>这个sqlnet.ora文件实际上就是一个配置文件，主要是和接下来说的tnsnames.ora配合使用。</p><h4 id="tnsnames-ora文件"><a href="#tnsnames-ora文件" class="headerlink" title="tnsnames.ora文件"></a>tnsnames.ora文件</h4><p>tnsnames.ora文件存放于客户端机器上，和sqlnet.ora文件配合使用。可以简单的看看tnsnames.ora文件中的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ORCL是个别名</span><br><span class="line">#这条信息记录了我们使用TCP协议，去连接IP地址为127.0.0.1，端口号为1521的数据库主机上服务名为orcl的数据库</span><br><span class="line">ORCL =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">        (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</span><br><span class="line">        (CONNECT_DATA =</span><br><span class="line">            (SERVER = DEDICATED)</span><br><span class="line">            (SERVICE_NAME = orcl)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">以后，我们还会配置更多的数据库连接信息，比如我要连接192.168.10.2主机上的数据库，我们只需要在tnsnames.ora中继续追加新的连接信息即可，比如：</span><br><span class="line"></span><br><span class="line">STDB =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">        (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.10.2)(PORT = 1521))</span><br><span class="line">        (CONNECT_DATA =</span><br><span class="line">            (SERVER = DEDICATED)</span><br><span class="line">            (SERVICE_NAME = stdb)</span><br><span class="line">        )</span><br><span class="line">     )</span><br></pre></td></tr></table></figure><h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><p>直接编辑listener.ora，就像下面这样，配置一个新的监听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LISTENER =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">    (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SID_LIST_LISTENER =</span><br><span class="line">    (SID_LIST =</span><br><span class="line">        (SID_DESC =</span><br><span class="line">            (GLOBAL_DBNAME = ORCL)</span><br><span class="line">            (ORACLE_HOME = C:\Oracle11g\product\11.2.0\dbhome_1)</span><br><span class="line">            (SID_NAME = ORCL)</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>你想在哪个数据库上配置一个新的监听，就修改对应的内容即可。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>启动监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl start &lt;监听器的名字&gt;</span><br><span class="line"></span><br><span class="line">// 启动名为LISTENER的监听器</span><br><span class="line">lsnrctl start LISTENER</span><br></pre></td></tr></table></figure><p>当我们不指定监听器的名字时，就默认启动LISTENER监听器；</p><p>关闭监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl stop &lt;监听器的名字&gt;</span><br><span class="line"></span><br><span class="line">// 关闭名为LISTENER的监听器</span><br><span class="line">lsnrctl stop LISTENER</span><br></pre></td></tr></table></figure><p>当我们不指定监听器的名字时，就默认关闭LISTENER监听器；</p><p>查看监听器的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl status &lt;监听器的名字&gt;</span><br><span class="line"></span><br><span class="line">// 查看名为LISTENER的监听器的运行状态</span><br><span class="line">lsnrctl status LISTENER</span><br></pre></td></tr></table></figure><p>当我们不指定监听器的名字时，就默认查看LISTENER监听器的状态。</p><p>测试连通性<br>可以使用工具<code>TNSPING</code></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.jellythink.com/archives/985" target="_blank" rel="noopener">Oracle学习笔记——配置监听</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是监听&quot;&gt;&lt;a href=&quot;#什么是监听&quot; class=&quot;headerlink&quot; title=&quot;什么是监听&quot;&gt;&lt;/a&gt;什么是监听&lt;/h3&gt;&lt;p&gt;如果你做过网络开发，对于监听listen就比较熟悉了，监听是什么，在网络开发中，就是监听某个端口，等待客户端的连接。
      
    
    </summary>
    
      <category term="数据库" scheme="http://haoweiguang.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://haoweiguang.me/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习笔记——Linux设置Oracle环境变量</title>
    <link href="http://haoweiguang.me/2017/09/25/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Linux%E8%AE%BE%E7%BD%AEOracle%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://haoweiguang.me/2017/09/25/Oracle学习笔记——Linux设置Oracle环境变量/</id>
    <published>2017-09-25T08:32:06.000Z</published>
    <updated>2019-10-16T06:20:51.270Z</updated>
    
    <content type="html"><![CDATA[<p>有三种设置方法，具体如下：</p><p>方法一：直接运行export命令定义变量,<strong>该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的</strong>，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p><p>以设置oracle环境变量为例<br><img src="http://oo501cyv7.bkt.clouddn.com/15063281966273.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export ORACLE_BASE=/data/app/oracle; </span><br><span class="line">export ORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1; </span><br><span class="line">export ORACLE_SID=orcl; </span><br><span class="line">export PATH=$ORACLE_HOME/bin:$PATH;</span><br></pre></td></tr></table></figure><p>方法二：在用户目录下的.bash_profile文件中增加变量，改变量<strong>仅会对当前用户有效</strong>，并且是“永久的”。</p><p><img src="http://oo501cyv7.bkt.clouddn.com/15063282260029.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/data/app/oracle;                          export ORACLE_BASE</span><br><span class="line">ORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1;      export ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl;                                       export ORACLE_SID</span><br><span class="line">PATH=$ORACLE_HOME/bin:$PATH;                           export PATH</span><br></pre></td></tr></table></figure><p>方法三： 在/etc/profile文件中添加变量，该变量将<strong>会对Linux下所有用户有效</strong>，并且是“永久的”。</p><p><img src="http://oo501cyv7.bkt.clouddn.com/15063282550340.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/data/app/oracle;                        export ORACLE_BASE</span><br><span class="line">ORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1;    export ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl;                                     export ORACLE_SID</span><br><span class="line">PATH=$ORACLE_HOME/bin:$PATH;                         export PATH</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有三种设置方法，具体如下：&lt;/p&gt;
&lt;p&gt;方法一：直接运行export命令定义变量,&lt;strong&gt;该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的&lt;/strong&gt;，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用
      
    
    </summary>
    
      <category term="数据库" scheme="http://haoweiguang.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://haoweiguang.me/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境变量总结</title>
    <link href="http://haoweiguang.me/2017/09/25/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://haoweiguang.me/2017/09/25/Linux环境变量总结/</id>
    <published>2017-09-25T08:21:24.000Z</published>
    <updated>2017-09-25T08:22:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux是一个多用户多任务的操作系统，可以==在Linux中为不同的用户设置不同的运行环境==，具体做法是设置不同用户的环境变量。</p><h3 id="Linux环境变量分类"><a href="#Linux环境变量分类" class="headerlink" title="Linux环境变量分类"></a>Linux环境变量分类</h3><p>一、按照生命周期来分，Linux环境变量可以分为两类：<br>1、永久的：需要用户修改相关的配置文件，变量永久生效。<br>2、临时的：用户利用export命令，在当前终端下声明环境变量，关闭Shell终端失效。</p><p>二、按照作用域来分，Linux环境变量可以分为：<br>1、系统环境变量：系统环境变量对该系统中所有用户都有效。<br>2、用户环境变量：顾名思义，这种类型的环境变量只对特定的用户有效。</p><h3 id="Linux设置环境变量的方法"><a href="#Linux设置环境变量的方法" class="headerlink" title="Linux设置环境变量的方法"></a>Linux设置环境变量的方法</h3><p>一、在<code>/etc/profile</code>文件中添加变量 <strong>对所有用户生效（永久的）</strong><br>用vim在文件<code>/etc/profile</code>文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。<br>例如：编辑<code>/etc/profile</code>文件，添加<code>CLASSPATH</code>变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile    </span><br><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure><p>注：修改文件后要想马上生效还要运行<code>source /etc/profile</code>不然只能在下次重进此用户时生效。</p><p>二、在用户目录下的<code>.bash_profile</code>文件中增加变量 【<strong>对单一用户生效（永久的）</strong>】<br>用<code>vim ~/.bash_profile</code>文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash.profile</span><br><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure><p>注：修改文件后要想马上生效还要运行<code>$ source ~/.bash_profile</code>不然只能在下次重进此用户时生效。</p><p>三、直接运行export命令定义变量 【<strong>只对当前shell（BASH）有效（临时的）</strong>】<br>在shell的命令行下直接使用<code>export 变量名=变量值</code><br>定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p><h3 id="Linux环境变量使用"><a href="#Linux环境变量使用" class="headerlink" title="Linux环境变量使用"></a>Linux环境变量使用</h3><p>一、Linux中常见的环境变量有：</p><p>PATH：指定命令的搜索路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PATH声明用法：</span><br><span class="line">PATH=$PAHT:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:--------:&lt; PATH n &gt;</span><br><span class="line">export PATH</span><br><span class="line">你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效。</span><br><span class="line">可以利用echo $PATH查看当前当前系统PATH路径。</span><br></pre></td></tr></table></figure><p>HOME：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）。<br>HISTSIZE：指保存历史命令记录的条数。<br>LOGNAME：指当前用户的登录名。<br>HOSTNAME：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的<br>SHELL：指当前用户用的是哪种Shell。<br>LANG/LANGUGE：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。<br>MAIL：指当前用户的邮件存放目录。</p><p>注意：上述变量的名字并不固定，如HOSTNAME在某些Linux系统中可能设置成HOST</p><p>二、Linux也提供了修改和查看环境变量的命令，下面通过几个实例来说明：</p><p>echo 显示某个环境变量值 echo $PATH<br>export 设置一个新的环境变量 export HELLO=”hello” (可以无引号)<br>env 显示所有环境变量<br>set 显示本地定义的shell变量<br>unset 清除环境变量 unset HELLO<br>readonly 设置只读环境变量 readonly HELLO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux是一个多用户多任务的操作系统，可以==在Linux中为不同的用户设置不同的运行环境==，具体做法是设置不同用户的环境变量。&lt;/p&gt;
&lt;h3 id=&quot;Linux环境变量分类&quot;&gt;&lt;a href=&quot;#Linux环境变量分类&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="理解计算器机" scheme="http://haoweiguang.me/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E5%99%A8%E6%9C%BA/"/>
    
    
      <category term="linux" scheme="http://haoweiguang.me/tags/linux/"/>
    
      <category term="环境变量" scheme="http://haoweiguang.me/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习笔记——在centos6.5上安装oracle11g</title>
    <link href="http://haoweiguang.me/2017/09/21/INSTALLATION-OF-ORACLE-11g-Release-2-on-CentOS-6-5-1/"/>
    <id>http://haoweiguang.me/2017/09/21/INSTALLATION-OF-ORACLE-11g-Release-2-on-CentOS-6-5-1/</id>
    <published>2017-09-21T07:24:51.000Z</published>
    <updated>2017-09-21T07:27:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统：CentOS6.5（64位）<br>数据库：Oracle 11g Release2 (64-bit)</p><h2 id="第一步：配置yum以下载oracle的依赖"><a href="#第一步：配置yum以下载oracle的依赖" class="headerlink" title="第一步：配置yum以下载oracle的依赖"></a>第一步：配置yum以下载oracle的依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cd /etc/yum.repos.d</span><br><span class="line"># wget https://public-yum.oracle.com/public-yum-ol6.repo</span><br><span class="line">If case you received Certificate error then, use following command</span><br><span class="line"># wget https://public-yum.oracle.com/public-yum-ol6.repo –no-check-certificate</span><br></pre></td></tr></table></figure><p><img src="http://oo501cyv7.bkt.clouddn.com/15059722614907.png" alt></p><h2 id="第二步：导入GPG-Keys"><a href="#第二步：导入GPG-Keys" class="headerlink" title="第二步：导入GPG Keys"></a>第二步：导入GPG Keys</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># wget https://public-yum.oracle.com/RPM-GPG-KEY-oracle-ol6 -O /etc/pki/rpm-gpg/RPM-GPG-KEY-oracle</span><br><span class="line">If case you received Certificate error, then use following command</span><br><span class="line"># wget https://public-yum.oracle.com/RPM-GPG-KEY-oracle-ol6 -O /etc/pki/rpm-gpg/RPM-GPG-KEY-oracle –no-check-certificate</span><br></pre></td></tr></table></figure><h2 id="第三步：安装oracle的依赖"><a href="#第三步：安装oracle的依赖" class="headerlink" title="第三步：安装oracle的依赖"></a>第三步：安装oracle的依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install oracle-rdbms-server-11gR2-preinstall</span><br></pre></td></tr></table></figure><h2 id="第四步：设置服务器hsotname"><a href="#第四步：设置服务器hsotname" class="headerlink" title="第四步：设置服务器hsotname"></a>第四步：设置服务器hsotname</h2><p><code># vi /etc/hosts</code><br><img src="http://oo501cyv7.bkt.clouddn.com/15059724528724.jpg" alt></p><p><code># vi /etc/sysconfig/network</code></p><p><img src="http://oo501cyv7.bkt.clouddn.com/15059725023188.jpg" alt></p><h2 id="第五步：在服务器创建oracle账户"><a href="#第五步：在服务器创建oracle账户" class="headerlink" title="第五步：在服务器创建oracle账户"></a>第五步：在服务器创建oracle账户</h2><p>在终端里执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># passwd oracle</span><br><span class="line">Change password for user oracle.</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD:it is based on a dictinory word</span><br><span class="line">BAD PASSWORD:is too simple</span><br><span class="line">Retype new password:</span><br><span class="line">passwd:all authentication tokens updated sucessfully.</span><br></pre></td></tr></table></figure><h2 id="第六步：配置文件“90-nproc-conf”"><a href="#第六步：配置文件“90-nproc-conf”" class="headerlink" title="第六步：配置文件“90-nproc.conf”"></a>第六步：配置文件“90-nproc.conf”</h2><p><code># vi /etc/security/limits.d/90-nproc.conf</code><br><img src="http://oo501cyv7.bkt.clouddn.com/15059730733689.jpg" alt></p><h2 id="第七步：配置selinux参数为“permissive”"><a href="#第七步：配置selinux参数为“permissive”" class="headerlink" title="第七步：配置selinux参数为“permissive”"></a>第七步：配置selinux参数为“permissive”</h2><p><code># vi /etc/selinux/config</code><br><img src="http://oo501cyv7.bkt.clouddn.com/15059731663187.jpg" alt></p><p><strong>重启服务器</strong>，然后使用『oracle』账户登录。使用其他账户登录的使用<code>su - oracle</code>切换到oracle账户下。</p><h2 id="第八步：在-“-bash-profile”-中添加oracle的相关配置"><a href="#第八步：在-“-bash-profile”-中添加oracle的相关配置" class="headerlink" title="第八步：在 “.bash_profile” 中添加oracle的相关配置"></a>第八步：在 “.bash_profile” 中添加oracle的相关配置</h2><p><code>[oracle@oracle~]# vi .bash_profile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/home/oracle/app/oracle;                 export ORACLE_BASE</span><br><span class="line">ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1;    export ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl;                                     export ORACLE_SID</span><br><span class="line">PATH=$ORACLE_HOME/bin:$PATH;                         export PATH</span><br></pre></td></tr></table></figure><p>其中<code>ORACLE_BASE</code>、<code>ORACLE_HOME</code>一定要和oracle的安装目录一致，不一致需要后续做修改。<br><img src="http://oo501cyv7.bkt.clouddn.com/15059735547795.jpg" alt></p><p><code>[oracle@oracle~]# source .bash_profile #修改的文件立即生效</code></p><h2 id="第九步：在服务器的虚拟控制台调用图形界面安装"><a href="#第九步：在服务器的虚拟控制台调用图形界面安装" class="headerlink" title="第九步：在服务器的虚拟控制台调用图形界面安装"></a>第九步：在服务器的虚拟控制台调用图形界面安装</h2><p>转到存放oracle压缩文件的目录，执行<code>unzip</code>命令来解压缩文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[oracle@oracle~]# unzip /media/linux.x64_11gR2_database_1of2.zip </span><br><span class="line">[oracle@oracle~]# unzip /media/linux.x64_11gR2_database_2of2.zip</span><br></pre></td></tr></table></figure><p>文件会解压到一个<code>database</code>的目录。<br><img src="http://oo501cyv7.bkt.clouddn.com/15059738419976.jpg" alt></p><p>执行<code>./runInstaller</code>就可以调出图形化界面了。（==<strong>注意：这个需要在服务器上的终端来执行，SSH连接到服务器运行该命令是不行的，需要通过xhost单独设置。</strong>==）</p><p>在执行上边的命令后可能会遇到乱码，执行以下命令再重新运行<code>./runInstaller</code></p><p><code>[oracle@oracle~]# export LANG=en_US.utf-8</code></p><p>可能会遇到网络不通的情况，应该是hostname没有设置正确。需要在oracle账户下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[oracle@oracle~]# hostname oracle.xdf.cn</span><br><span class="line">[oracle@oracle~]# hostname</span><br><span class="line">oracle.xdf.cn #有这个信息出来就表示设置好了</span><br></pre></td></tr></table></figure><h3 id="输入接受一些安全问题的邮件地址（什么也不输入）"><a href="#输入接受一些安全问题的邮件地址（什么也不输入）" class="headerlink" title="输入接受一些安全问题的邮件地址（什么也不输入）"></a>输入接受一些安全问题的邮件地址（什么也不输入）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059753192771.jpg" alt></p><h3 id="选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件"><a href="#选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件" class="headerlink" title="选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件"></a>选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059753952572.jpg" alt></p><h3 id="选择服务器版本"><a href="#选择服务器版本" class="headerlink" title="选择服务器版本"></a>选择服务器版本</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754099248.jpg" alt></p><h3 id="单实例数据库"><a href="#单实例数据库" class="headerlink" title="单实例数据库"></a>单实例数据库</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754176925.jpg" alt></p><h3 id="高级模式安装"><a href="#高级模式安装" class="headerlink" title="高级模式安装"></a>高级模式安装</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754282905.jpg" alt></p><h3 id="添加支持的语言（可以不添加，只支持英文也行）"><a href="#添加支持的语言（可以不添加，只支持英文也行）" class="headerlink" title="添加支持的语言（可以不添加，只支持英文也行）"></a>添加支持的语言（可以不添加，只支持英文也行）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754352247.jpg" alt><br><img src="http://oo501cyv7.bkt.clouddn.com/15059754767809.jpg" alt></p><h3 id="选择要安装的版本"><a href="#选择要安装的版本" class="headerlink" title="选择要安装的版本"></a>选择要安装的版本</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754873760.jpg" alt></p><h3 id="安装数据库目录"><a href="#安装数据库目录" class="headerlink" title="安装数据库目录"></a>安装数据库目录</h3><p>Oracle Base: /hywl/oracle/app<br>Sofeware Location: /hywl/oracle/app/product/11.1.1/db_1<br>这个根据自己服务器的账户名不同有所差别<br><img src="http://oo501cyv7.bkt.clouddn.com/15059755417537.jpg" alt><br><img src="http://oo501cyv7.bkt.clouddn.com/15059755472755.jpg" alt></p><h3 id="数据库用途"><a href="#数据库用途" class="headerlink" title="数据库用途"></a>数据库用途</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059755567343.jpg" alt></p><h3 id="数据库名及服务名（可以修改为自己想要）"><a href="#数据库名及服务名（可以修改为自己想要）" class="headerlink" title="数据库名及服务名（可以修改为自己想要）"></a>数据库名及服务名（可以修改为自己想要）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059755645841.jpg" alt></p><h3 id="开启自动内存管理"><a href="#开启自动内存管理" class="headerlink" title="开启自动内存管理"></a>开启自动内存管理</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059755911915.jpg" alt></p><h3 id="设置默认编码为UTF8（如果未添加中文支持，无这步操作）"><a href="#设置默认编码为UTF8（如果未添加中文支持，无这步操作）" class="headerlink" title="设置默认编码为UTF8（如果未添加中文支持，无这步操作）"></a>设置默认编码为UTF8（如果未添加中文支持，无这步操作）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756322355.jpg" alt></p><h3 id="启用Oracle企业管理控制台OEM"><a href="#启用Oracle企业管理控制台OEM" class="headerlink" title="启用Oracle企业管理控制台OEM"></a>启用Oracle企业管理控制台OEM</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756411025.jpg" alt></p><h3 id="选择数据库文件目录"><a href="#选择数据库文件目录" class="headerlink" title="选择数据库文件目录"></a>选择数据库文件目录</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756495504.jpg" alt></p><h3 id="自动备份设置：不启用"><a href="#自动备份设置：不启用" class="headerlink" title="自动备份设置：不启用"></a>自动备份设置：不启用</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756573188.jpg" alt></p><h3 id="设置数据库用户名和密码"><a href="#设置数据库用户名和密码" class="headerlink" title="设置数据库用户名和密码"></a>设置数据库用户名和密码</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756639425.jpg" alt></p><h3 id="授权的组"><a href="#授权的组" class="headerlink" title="授权的组"></a>授权的组</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756730616.jpg" alt></p><h3 id="检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）"><a href="#检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）" class="headerlink" title="检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）"></a>检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756918240.jpg" alt></p><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757013456.jpg" alt></p><h3 id="安装即将完成"><a href="#安装即将完成" class="headerlink" title="安装即将完成"></a>安装即将完成</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757103123.jpg" alt><br><img src="http://oo501cyv7.bkt.clouddn.com/15059757171035.jpg" alt></p><h3 id="解锁用户SCOTT，-SCOTT的默认口令为tiger（这步也可以不设置）"><a href="#解锁用户SCOTT，-SCOTT的默认口令为tiger（这步也可以不设置）" class="headerlink" title="解锁用户SCOTT， SCOTT的默认口令为tiger（这步也可以不设置）"></a>解锁用户SCOTT， SCOTT的默认口令为tiger（这步也可以不设置）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757313014.jpg" alt></p><h3 id="弹出“执行配置脚本”对对话框"><a href="#弹出“执行配置脚本”对对话框" class="headerlink" title="弹出“执行配置脚本”对对话框"></a>弹出“执行配置脚本”对对话框</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757540732.jpg" alt></p><p>安装完成了，系统提示需要用root账户执行两个脚本（orainstRoot.sh，root.sh）系统才算完全安装完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@oracle~]$ /hywl/oracle/app/oraInventory/orainstRoot.sh</span><br><span class="line"></span><br><span class="line">[root@oracle~]$ /hywl/oracle/app/product/11.2.0/dbhome_1/root.sh</span><br></pre></td></tr></table></figure><p>==<strong>很重要的一点，一定要记得在防火墙上开启<code>1521</code>端口，不然客户端是连接不上的，提示<code>no listner</code>。</strong>==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ su - root</span><br><span class="line"># /sbin/iptables -I INPUT -p tcp --dport 1251 -j ACCEPT </span><br><span class="line"># /etc/rc.d/init.d/iptables save</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.royalcyber.com/integration/installation-of-oracle-11g-release-2-on-centos-6-5/" target="_blank" rel="noopener">INSTALLATION OF ORACLE 11g Release 2 on CentOS 6.5</a></li><li><a href="http://77jiayuan.blog.51cto.com/386386/1569389" target="_blank" rel="noopener">CentOS 6.5_x64安装Oracle 11g R2</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;操作系统：CentOS6.5（64位）&lt;br&gt;数据库：Oracle 11g Release2 (64-bit)&lt;/p&gt;
&lt;h2 id=&quot;第一步：配置yum以下载oracle的依赖&quot;&gt;&lt;a href=&quot;#第一步：配置yum以下载oracle的依赖&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>idea在tomcat中的热部署</title>
    <link href="http://haoweiguang.me/2017/09/18/idea%E5%9C%A8tomcat%E4%B8%AD%E7%9A%84%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <id>http://haoweiguang.me/2017/09/18/idea在tomcat中的热部署/</id>
    <published>2017-09-18T03:32:58.000Z</published>
    <updated>2019-10-17T06:02:28.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="idea在tomcat中的热部署"><a href="#idea在tomcat中的热部署" class="headerlink" title="idea在tomcat中的热部署"></a>idea在tomcat中的热部署</h1><p>如果每次jsp页面或后台代码有修改，都得重启，确实比较麻烦，现在找到一种利用jrebel这个插件来实现热不熟。</p><p>在idea的插件库中找到jrebel，如下图<br><img src="http://oo501cyv7.bkt.clouddn.com/15057048125945.jpg" alt></p><p>因为这个插件是需要收费，这里有办法可以免费获取激活码：</p><p>方法1：JRebel有一个免费获得激活码的方法，登录<a href="https://my.jrebel.com这个网站（FQ），然后用Twitter或者Facebook账号登录这个网站，就能获得免费的激活码。" target="_blank" rel="noopener">https://my.jrebel.com这个网站（FQ），然后用Twitter或者Facebook账号登录这个网站，就能获得免费的激活码。</a><br><img src="http://oo501cyv7.bkt.clouddn.com/15057048682483.jpg" alt></p><p>在IDEA里面Help-&gt;JRebel-&gt;Activate，复制粘贴激活码就行了。<br><img src="http://oo501cyv7.bkt.clouddn.com/15057048855064.jpg" alt></p><p>方法2：<br>1.激活时填写的 <a href="http://idea.jrebel.ml/ilanyu" target="_blank" rel="noopener">http://idea.jrebel.ml/ilanyu</a> 及 lanyu19950316@gmail.com，授权服务器地址格式为：<a href="http://idea.jrebel.ml/{用户名}，邮箱随意填写，idea.jrebel.ml" target="_blank" rel="noopener">http://idea.jrebel.ml/{用户名}，邮箱随意填写，idea.jrebel.ml</a> 可能随时会被封，可使用反向代理工具代理 <a href="http://idea.lanyus.com/，即可稳定使用授权服务器。" target="_blank" rel="noopener">http://idea.lanyus.com/，即可稳定使用授权服务器。</a></p><p>2.该激活方法可离线使用6个月，可根据需要点击 Renew offline seat 即可更新离线过期时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;idea在tomcat中的热部署&quot;&gt;&lt;a href=&quot;#idea在tomcat中的热部署&quot; class=&quot;headerlink&quot; title=&quot;idea在tomcat中的热部署&quot;&gt;&lt;/a&gt;idea在tomcat中的热部署&lt;/h1&gt;&lt;p&gt;如果每次jsp页面或后台代码
      
    
    </summary>
    
      <category term="利器" scheme="http://haoweiguang.me/categories/%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="idea" scheme="http://haoweiguang.me/tags/idea/"/>
    
      <category term="tomcat" scheme="http://haoweiguang.me/tags/tomcat/"/>
    
      <category term="热部署" scheme="http://haoweiguang.me/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务详解</title>
    <link href="http://haoweiguang.me/2017/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
    <id>http://haoweiguang.me/2017/07/21/数据库的事务/</id>
    <published>2017-07-21T04:25:01.000Z</published>
    <updated>2018-10-09T09:18:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p><blockquote><p>1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。<br>2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</p></blockquote><p>当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</p><p>但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p><blockquote><p>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。<br>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。<br>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。<br>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：</p><p>1、从A账号中把余额读出来（500）。<br>2、对A账号做减法操作（500-100）。<br>3、把结果写回A账号中（400）。<br>4、从B账号中把余额读出来（500）。<br>5、对B账号做加法操作（500+100）。<br>6、把结果写回B账号中（600）。</p><h3 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h3><p>保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。</p><p>为了实现原子性，需要通过日志：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。<br>如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。</p><p>原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。例如，事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上， 事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。</p><p>为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。用术语来说，就是多个事务并发执行后的状态，和它们串行执行后的状态是等价的。怎样实现隔离性，已经有很多人回答过了，原则上无非是两种类型的锁：1)悲观锁 2)乐观锁</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！</p><h2 id="原子性与隔离性"><a href="#原子性与隔离性" class="headerlink" title="原子性与隔离性"></a>原子性与隔离性</h2><p>一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关。<br>比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。</p><p>因此，事务的原子性与一致性缺一不可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.hollischuang.com/archives/898" target="_blank" rel="noopener">彻底理解数据库事务</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一
      
    
    </summary>
    
      <category term="数据库" scheme="http://haoweiguang.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="事务" scheme="http://haoweiguang.me/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎</title>
    <link href="http://haoweiguang.me/2017/07/21/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://haoweiguang.me/2017/07/21/MySQL存储引擎/</id>
    <published>2017-07-21T04:25:01.000Z</published>
    <updated>2019-10-16T06:20:29.552Z</updated>
    
    <content type="html"><![CDATA[<p>对于初学者来说我们通常不关注存储引擎，但是 MySQL 提供了多个存储引擎，包括处理事物安全表的引擎和处理非食物安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p><h2 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h2><p>MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。 存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><p>例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。我的电脑上安装的 MySQL 5.6.13 版，InnoDB就是作为默认的存储引擎。InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p><ul><li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li><li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li><li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li><li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li><li>支持自动增加列AUTO_INCREMENT属性。</li><li>从5.7开始innodb存储引擎成为默认的存储引擎。</li></ul><p>一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：</p><ul><li>tb_demo.frm，存储表定义。</li><li>tb_demo.MYD，存储数据。</li><li>tb_demo.MYI，存储索引。</li></ul><p>MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：</p><ol><li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li><li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li></ol><h3 id="MRG-MYISAM"><a href="#MRG-MYISAM" class="headerlink" title="MRG_MYISAM"></a>MRG_MYISAM</h3><p>MRG_MyISAM存储引擎是一组MyISAM表的组合，老版本叫 MERGE 其实是一回事儿，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。</p><p>Merge存储引擎的使用场景。对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。</p><ul><li>ENGINE=MERGE，指明使用MERGE引擎，其实是跟MRG_MyISAM一回事儿，也是对的，在MySQL 5.7已经看不到MERGE了。</li><li>UNION=(t1, t2)，指明了MERGE表中挂接了些哪表，可以通过alter table的方式修改UNION的值，以实现增删MERGE表子表的功能。比如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_merge <span class="keyword">engine</span>=<span class="keyword">merge</span> <span class="keyword">union</span>(tb_log1) insert_method=<span class="keyword">last</span>;</span><br></pre></td></tr></table></figure><ul><li>INSERT_METHOD=LAST，INSERT_METHOD指明插入方式，取值可以是：0 不允许插入；FIRST 插入到UNION中的第一个表； LAST 插入到UNION中的最后一个表。</li><li>MERGE表及构成MERGE数据表结构的各成员数据表必须具有完全一样的结构。每一个成员数据表的数据列必须按照同样的顺序定义同样的名字和类型，索引也必须按照同样的顺序和同样的方式定义。</li></ul><h3 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h3><p>使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。</p><p>一般在以下几种情况下使用Memory存储引擎：</p><ul><li>目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。</li><li>如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。</li><li>存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。</li><li>Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用&lt;、&gt;和&gt;=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和&lt;&gt;的操作符中，不适合在&lt;或&gt;操作符中，也同样不适合用在order by子句中。</li></ul><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p>CSV 存储引擎是基于 CSV 格式文件存储数据。</p><ul><li>CSV 存储引擎因为自身文件格式的原因，所有列必须强制指定 NOT NULL 。</li><li>CSV 引擎也不支持索引，不支持分区。</li><li>CSV 存储引擎也会包含一个存储表结构的 .frm 文件，还会创建一个 .csv 存储数据的文件，还会创建一个同名的元信息文件，该文件的扩展名为 .CSM ，用来保存表的状态及表中保存的数据量。</li><li>每个数据行占用一个文本行。</li></ul><p>因为 csv 文件本身就可以被Office等软件直接编辑，保不齐就有不按规则出牌的情况，如果出现csv 文件中的内容损坏了的情况，也可以使用 CHECK TABLE 或者 REPAIR TABLE 命令检查和修复</p><h3 id="ARCHIVE"><a href="#ARCHIVE" class="headerlink" title="ARCHIVE"></a>ARCHIVE</h3><p>Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。</p><h3 id="BLACKHOLE"><a href="#BLACKHOLE" class="headerlink" title="BLACKHOLE"></a>BLACKHOLE</h3><p>黑洞存储引擎，所有插入的数据并不会保存，BLACKHOLE 引擎表永远保持为空，写入的任何数据都会消失，</p><h3 id="PERFORMANCE-SCHEMA"><a href="#PERFORMANCE-SCHEMA" class="headerlink" title="PERFORMANCE_SCHEMA"></a>PERFORMANCE_SCHEMA</h3><p>主要用于收集数据库服务器性能参数。MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表，一般用于记录binlog做复制的中继。在这里有官方的一些介绍<a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema.html" target="_blank" rel="noopener">MySQL Performance Schema</a></p><h3 id="FEDERATED"><a href="#FEDERATED" class="headerlink" title="FEDERATED"></a>FEDERATED</h3><p>主要用于访问其它远程MySQL服务器一个代理，它通过创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，而后完成数据存取；在MariaDB的上实现是FederatedX</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>这里列举一些其它数据库提供的存储引擎，OQGraph、SphinxSE、TokuDB、Cassandra、CONNECT、SQUENCE。提供的名字仅供参考。</p><h2 id="常用引擎对比"><a href="#常用引擎对比" class="headerlink" title="常用引擎对比"></a>常用引擎对比</h2><p>不同存储引起都有各自的特点，为适应不同的需求，需要选择不同的存储引擎，所以首先考虑这些存储引擎各自的功能和兼容。</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>ARCHIVE</th></tr></thead><tbody><tr><td>存储限制(Storage limits)</td><td>64TB</td><td>No</td><td>YES</td><td>No</td></tr><tr><td>支持事物(Transactions)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>锁机制(Locking granularity)</td><td>行锁</td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引(B-tree indexes)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>T树索引(T-tree indexes)</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>哈希索引(Hash indexes)</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>全文索引(Full-text indexes)</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>集群索引(Clustered indexes)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>数据缓存(Data caches)</td><td>Yes</td><td>No</td><td>N/A</td><td>No</td></tr><tr><td>索引缓存(Index caches)</td><td>Yes</td><td>Yes</td><td>N/A</td><td>No</td></tr><tr><td>数据可压缩(Compressed data)</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>加密传输(Encrypted data<sup>[1]</sup>)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>集群数据库支持(Cluster databases support)</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>复制支持(Replication support<sup>[2]</sup>)</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>外键支持(Foreign key support)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>存储空间消耗(Storage Cost)</td><td>高</td><td>低</td><td>N/A</td><td>非常低</td></tr><tr><td>内存消耗(Memory Cost)</td><td>高</td><td>低</td><td>N/A</td><td>低</td></tr><tr><td>数据字典更新(Update statistics for data dictionary)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>备份/时间点恢复(backup/point-in-time recovery<sup>[3]</sup>)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>多版本并发控制(Multi-Version Concurrency Control/MVCC)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>批量数据写入效率(Bulk insert speed)</td><td>慢</td><td>快</td><td>快</td><td>非常快</td></tr><tr><td>地理信息数据类型(Geospatial datatype support)</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>地理信息索引(Geospatial indexing support<sup>[4]</sup>)</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr></tbody></table><ol><li>在服务器中实现（通过加密功能）。在其他表空间加密数据在MySQL 5.7或更高版本兼容。</li><li>在服务中实现的，而不是在存储引擎中实现的。</li><li>在服务中实现的，而不是在存储引擎中实现的。</li><li>地理位置索引，InnoDB支持可mysql5.7.5或更高版本兼容</li></ol><h2 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h2><p>使用“SHOW VARIABLES LIKE ‘%storage_engine%’;” 命令在mysql系统变量搜索磨人设置的存储引擎，输入语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE '%storage_engine%';</span><br><span class="line">+<span class="comment">----------------------------------+---------+</span></span><br><span class="line">| Variable_name                    | Value   |</span><br><span class="line">|<span class="comment">----------------------------------+---------|</span></span><br><span class="line">| default_storage_engine           | InnoDB  |</span><br><span class="line">| default_tmp_storage_engine       | InnoDB  |</span><br><span class="line">| disabled_storage_engines         |         |</span><br><span class="line">| internal_tmp_disk_storage_engine | InnoDB  |</span><br><span class="line">+<span class="comment">----------------------------------+---------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span></span><br><span class="line"><span class="keyword">Time</span>: <span class="number">0.005</span>s</span><br></pre></td></tr></table></figure><p>使用“SHOW ENGINES;”命令显示安装以后可用的所有的支持的存储引擎和默认引擎，后面带上 \G 可以列表输出结果，你可以尝试一下如“SHOW ENGINES\G;”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINES;</span><br><span class="line">+<span class="comment">--------------------+---------+--------------------------------------+-------------+--------+-----------+</span></span><br><span class="line">| Engine             | Support | <span class="keyword">Comment</span>                              | Transactions| XA     | Savepoints|</span><br><span class="line">|<span class="comment">--------------------+---------+--------------------------------------+-------------+--------+-----------|</span></span><br><span class="line">| <span class="keyword">InnoDB</span>             | <span class="keyword">DEFAULT</span> | Supports transactions,               | YES         | YES    | YES       |</span><br><span class="line">|                    |         | <span class="keyword">row</span>-<span class="keyword">level</span> locking, <span class="keyword">and</span> foreign <span class="keyword">keys</span>  |             |        |           |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection <span class="keyword">of</span> identical MyISAM <span class="keyword">tables</span>| <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| <span class="keyword">MEMORY</span>             | YES     | <span class="keyword">Hash</span> based, <span class="keyword">stored</span> <span class="keyword">in</span> <span class="keyword">memory</span>, useful | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">|                    |         | <span class="keyword">for</span> <span class="keyword">temporary</span> <span class="keyword">tables</span>                 |             |        |           |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/<span class="literal">null</span> <span class="keyword">storage</span> <span class="keyword">engine</span> (anything   | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">|                    |         | you write <span class="keyword">to</span> it disappears)          |             |        |           |</span><br><span class="line">| MyISAM             | YES     | MyISAM <span class="keyword">storage</span> <span class="keyword">engine</span>                | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| CSV                | YES     | CSV <span class="keyword">storage</span> <span class="keyword">engine</span>                   | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| <span class="keyword">ARCHIVE</span>            | YES     | <span class="keyword">Archive</span> <span class="keyword">storage</span> <span class="keyword">engine</span>               | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | <span class="keyword">Performance</span> <span class="keyword">Schema</span>                   | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| FEDERATED          | <span class="keyword">NO</span>      | Federated MySQL <span class="keyword">storage</span> <span class="keyword">engine</span>       | &lt;<span class="literal">null</span>&gt;      | &lt;<span class="literal">null</span>&gt; | &lt;<span class="literal">null</span>&gt;    |</span><br><span class="line">+<span class="comment">--------------------+---------+--------------------------------------+-------------+--------+-----------+</span></span><br></pre></td></tr></table></figure><p>由上面命令输出，可见当前系统的默认数据表类型是InnoDB。当然，我们可以通过修改数据库配置文件中的选项，设定默认表类型。</p><h2 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h2><p>对上面数据库存储引擎有所了解之后，你可以在<code>my.cnf</code> 配置文件中设置你需要的存储引擎，这个参数放在 [mysqld] 这个字段下面的 default_storage_engine 参数值，例如下面配置的片段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">default_storage_engine=CSV</span><br></pre></td></tr></table></figure><p>在创建表的时候，对表设置存储引擎，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span>     <span class="built_in">int</span>(<span class="number">100</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span>   <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`mobile`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'手机'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>在创建用户表 user 的时候，SQL语句最后 ENGINE=InnoDB 就是设置这张表存储引擎为 InnoDB。</p><h2 id="如何选择合适的存储引擎"><a href="#如何选择合适的存储引擎" class="headerlink" title="如何选择合适的存储引擎"></a>如何选择合适的存储引擎</h2><p>提供几个选择标准，然后按照标准，选择对应的存储引擎即可，也可以根据<a href="#常用引擎对比">常用引擎对比</a>来选择你使用的存储引擎。使用哪种引擎需要根据需求灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。</p><ol><li>是否需要支持事务；</li><li>是否需要使用热备；</li><li>崩溃恢复，能否接受崩溃；</li><li>是否需要外键支持；</li><li>存储的限制；</li><li>对索引和缓存的支持；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于初学者来说我们通常不关注存储引擎，但是 MySQL 提供了多个存储引擎，包括处理事物安全表的引擎和处理非食物安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。&lt;/p&gt;
&lt;h2 id=&quot;存储引擎简介
      
    
    </summary>
    
      <category term="数据库" scheme="http://haoweiguang.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://haoweiguang.me/tags/MySQL/"/>
    
      <category term="存储引擎" scheme="http://haoweiguang.me/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>java HashMap工作原理和实现</title>
    <link href="http://haoweiguang.me/2017/07/20/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://haoweiguang.me/2017/07/20/java集合框架-HashMap实现原理分析/</id>
    <published>2017-07-20T10:21:57.000Z</published>
    <updated>2018-09-22T16:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-HashMap的数据结构"><a href="#1-HashMap的数据结构" class="headerlink" title="1. HashMap的数据结构"></a>1. HashMap的数据结构</h2><p>JDK1.8之前数据结构是<strong>数组和链表</strong>来实现对数据的存储，但这两者基本上是两个极端。JDK1.8当链表长度大于阈值（默认为8），将链表转化为红黑树，减少搜索时间。</p><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：<strong>寻址容易，插入和删除困难；</strong></p><h3 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h3><p>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O(N)。链表的特点是：<strong>寻址困难，插入和删除容易</strong>。</p><h3 id="1-3-哈希表"><a href="#1-3-哈希表" class="headerlink" title="1.3 哈希表"></a>1.3 哈希表</h3><p>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p><p>哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：<br><img src="http://oo501cyv7.bkt.clouddn.com/14847296397735.jpg" alt></p><p><img src="http://oo501cyv7.bkt.clouddn.com/14847296679116.jpg" alt></p><p>从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p><p>　　HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。</p><p>　　首先HashMap里面实现一个静态内部类<code>Entry</code>，其重要的属性有 <code>key , value, next</code>，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="line"> */</span><br><span class="line">transient Entry[] table;</span><br></pre></td></tr></table></figure><h2 id="2-HashMap的存取实现"><a href="#2-HashMap的存取实现" class="headerlink" title="2. HashMap的存取实现"></a>2. HashMap的存取实现</h2><p>既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 存储时:</span><br><span class="line">int hash = key.hashCode(); // 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">Entry[index] = value;</span><br><span class="line"></span><br><span class="line">// 取值时:</span><br><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">return Entry[index];</span><br></pre></td></tr></table></figure><h3 id="2-1-put"><a href="#2-1-put" class="headerlink" title="2.1 put"></a>2.1 put</h3><p>疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？<br>　　这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。到这里为止，HashMap的大致实现，我们应该已经清楚了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            return putForNullKey(value); //null总是放在数组的第一个链表中</span><br><span class="line">        int hash = hash(key.hashCode());</span><br><span class="line">        int i = indexFor(hash, table.length);</span><br><span class="line">        //遍历链表</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            //如果key在链表中已存在，则替换为新value</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); //参数e, 是Entry.next</span><br><span class="line">    //如果size超过threshold，则扩充table大小。再散列</span><br><span class="line">    if (size++ &gt;= threshold)</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p><h3 id="2-2-get"><a href="#2-2-get" class="headerlink" title="2.2 get"></a>2.2 get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            return getForNullKey();</span><br><span class="line">        int hash = hash(key.hashCode());</span><br><span class="line">        //先定位到数组元素，再遍历该元素处的链表</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != null;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-null-key的存取"><a href="#2-3-null-key的存取" class="headerlink" title="2.3 null key的存取"></a>2.3 null key的存取</h3><p>null key总是存放在Entry[]数组的第一个元素。</p><p>保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">            if (e.key == null) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(0, null, value, 0);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private V getForNullKey() &#123;</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">        if (e.key == null)</span><br><span class="line">            return e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-确定数组indexhashcode-tablelength取模"><a href="#2-4-确定数组indexhashcode-tablelength取模" class="headerlink" title="2.4 确定数组indexhashcode tablelength取模"></a>2.4 确定数组indexhashcode tablelength取模</h3><p>HashMap存取时，都需要计算当前key应该对应Entry[]数组哪个元素，即计算数组下标；算法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns index for hash code h.</span><br><span class="line">     */</span><br><span class="line">    static int indexFor(int h, int length) &#123;</span><br><span class="line">        return h &amp; (length-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>按位取并，作用上相当于取模mod或者取余%。<br><strong>这意味着数组下标相同，并不表示hashCode相同。</strong></p><h3 id="2-5-table初始大小"><a href="#2-5-table初始大小" class="headerlink" title="2.5 table初始大小"></a>2.5 table初始大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        .....</span><br><span class="line">        // Find a power of 2 &gt;= initialCapacity</span><br><span class="line">        int capacity = 1;</span><br><span class="line">        while (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= 1;</span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        threshold = (int)(capacity * loadFactor);</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意table初始大小并不是构造函数中的initialCapacity！！</p><p>而是 &gt;= initialCapacity的2的n次幂！！！！</p><h2 id="3-解决hash冲突的办法"><a href="#3-解决hash冲突的办法" class="headerlink" title="3. 解决hash冲突的办法"></a>3. 解决hash冲突的办法</h2><ol><li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li><li>再哈希法</li><li><strong>链地址法</strong></li><li>建立一个公共溢出区</li></ol><p>Java中hashmap的解决办法就是采用的链地址法。</p><h2 id="4-再散列rehash过程"><a href="#4-再散列rehash过程" class="headerlink" title="4. 再散列rehash过程"></a>4. 再散列rehash过程</h2><p>当哈希表的容量超过默认容量时，必须调整table的大小。当容量已经达到最大可能值时，那么该方法就将容量调整到Integer.MAX_VALUE返回，这时，需要创建一张新表，将原表的映射到新表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Rehashes the contents of this map into a new array with a</span><br><span class="line">     * larger capacity.  This method is called automatically when the</span><br><span class="line">     * number of keys in this map reaches its threshold.</span><br><span class="line">     *</span><br><span class="line">     * If current capacity is MAXIMUM_CAPACITY, this method does not</span><br><span class="line">     * resize the map, but sets threshold to Integer.MAX_VALUE.</span><br><span class="line">     * This has the effect of preventing future calls.</span><br><span class="line">     *</span><br><span class="line">     * @param newCapacity the new capacity, MUST be a power of two;</span><br><span class="line">     *        must be greater than current capacity unless current</span><br><span class="line">     *        capacity is MAXIMUM_CAPACITY (in which case value</span><br><span class="line">     *        is irrelevant).</span><br><span class="line">     */</span><br><span class="line">    void resize(int newCapacity) &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        int oldCapacity = oldTable.length;</span><br><span class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Transfers all entries from current table to newTable.</span><br><span class="line">     */</span><br><span class="line">    void transfer(Entry[] newTable) &#123;</span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        int newCapacity = newTable.length;</span><br><span class="line">        for (int j = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                src[j] = null;</span><br><span class="line">                do &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    //重新计算index</span><br><span class="line">                    int i = indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next = newTable[i];</span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; while (e != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="noopener">HashMap实现原理分析</a></li><li><a href="http://www.cnblogs.com/chenssy/p/3521565.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3521565.html</a></li><li><a href="http://www.importnew.com/10620.html" target="_blank" rel="noopener">http://www.importnew.com/10620.html</a></li><li><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-HashMap的数据结构&quot;&gt;&lt;a href=&quot;#1-HashMap的数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. HashMap的数据结构&quot;&gt;&lt;/a&gt;1. HashMap的数据结构&lt;/h2&gt;&lt;p&gt;JDK1.8之前数据结构是&lt;strong
      
    
    </summary>
    
    
      <category term="java" scheme="http://haoweiguang.me/tags/java/"/>
    
      <category term="HashMap" scheme="http://haoweiguang.me/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Servlet的线程安全问题</title>
    <link href="http://haoweiguang.me/2017/07/09/Servlet%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://haoweiguang.me/2017/07/09/Servlet的线程安全问题/</id>
    <published>2017-07-09T03:36:48.000Z</published>
    <updated>2017-07-09T03:37:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了有效利用JVM允许多个线程访问同一个实例的特性，来提高服务器性能。在非分布式系统中，Servlet容器只会维护一个Servlet的实例。</p><blockquote><p>如果 Web 应用中的 Servlet 被标注为分布式的,容器应该为每一个分布式应用程序的 JVM 维护一个 Servlet 实例池。</p></blockquote><p>Servlet容器通过维护一个线程池来处理多个请求，线程池中维护的是一组工作者线程（Worker Thread）。Servlet容器通过一个调度线程（Dispatcher Thread）来调度线程池中的线程。</p><p>当客户端的servlet请求到来时，调度线程会从线程池中选出一个工作者线程并将请求传递给该线程，该线程就会执行对应servlet实例的service方法。同样，当客户端发起另一个servlet请求时，调度线程会从线程池中选出另一个线程去执行servlet实例的service方法。Servlet容器并不关心这些线程访问的是同一个servlet还是不同的servlet，当多个线程访问同一个servlet时，该servlet实例的service方法将在多个线性中并发执行。</p><p>所以，<strong>==Servlet对象是单实例多线程，Servlet不是线程安全的==</strong></p><h2 id="为什么不安全？"><a href="#为什么不安全？" class="headerlink" title="为什么不安全？"></a>为什么不安全？</h2><p>先看两个定义：<br><strong>实例变量</strong>：实例变量在类中定义。类的每一个实例都拥有自己的实例变量，如果多个线程同时访问该实例的方法，而该方法又使用到实例变量，那么这些线程同时访问的是同一个实例变量，会共享该实例变量。</p><p><strong>局部变量</strong>：局部变量在方法中定义。每当一个线程访问局部变量所在的方法时，在线程的堆栈中就会创建这个局部变量，线程执行完这个方法时，该局部变量就被销毁。所有多个线程同时访问该方法时，每个线程都有自己的局部变量，不会共享。</p><p>看如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyServlet extends HttpServlet&#123;</span><br><span class="line"> private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line"> private String userName1 = null;//实例变量</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void doGet(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">         throws ServletException, IOException&#123;</span><br><span class="line">  userName1 = req.getParameter(&quot;userName1&quot;);</span><br><span class="line"></span><br><span class="line">  String userName2 = req.getParameter(&quot;userName2&quot;);//局部变量</span><br><span class="line"></span><br><span class="line">  //TODO 其他处理</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>userName1则是共享变量，多个线程会同时访问该变量，是线程不安全的。</p><p>userName2是局部变量，不管多少个线程同时访问，都是线程安全的。</p><h2 id="解决Servlet的线程安全问题"><a href="#解决Servlet的线程安全问题" class="headerlink" title="解决Servlet的线程安全问题"></a>解决Servlet的线程安全问题</h2><p>如果不涉及到全局共享变量，就直接使用局部变量</p><p>如果使用到全局共享的场景，可以使用加锁的方式.对全局变量的读写操作置于synchronized同步块中，这样不同线程排队依次执行该代码块，从而避免线程不安全情况发生。还可以使用线程安全的数据类型。比如hashtable,blockQueue等</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.hollischuang.com/archives/849" target="_blank" rel="noopener">Servlet 3.1规范学习笔记（一）——Servlet生命周期和线程安全性问题</a></li><li><a href="http://www.charlestech.info/2014/04/13/servlet-thread-security/" target="_blank" rel="noopener">Servlet的线程安全问题</a></li><li><a href="http://haoran-10.iteye.com/blog/2245065" target="_blank" rel="noopener">java servlet拾遗（3）-servlet 线程安全问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了有效利用JVM允许多个线程访问同一个实例的特性，来提高服务器性能。在非分布式系统中，Servlet容器只会维护一个Servlet的实例。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 Web 应用中的 Servlet 被标注为分布式的,容器应该为每一个分布式应用程序的 
      
    
    </summary>
    
    
      <category term="java" scheme="http://haoweiguang.me/tags/java/"/>
    
      <category term="servlet" scheme="http://haoweiguang.me/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet开发实战</title>
    <link href="http://haoweiguang.me/2017/07/09/Servlet%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    <id>http://haoweiguang.me/2017/07/09/Servlet开发实战/</id>
    <published>2017-07-09T03:36:32.000Z</published>
    <updated>2019-10-16T06:21:32.408Z</updated>
    
    <content type="html"><![CDATA[<p>Web框架是开发者在使用某种语言编写Web应用服务端时关于架构的最佳实践。很多Web框架是从实际的Web项目抽取出来的，仅和Web的请求和响应处理有关，形成一个基础，在开发别的应用项目的时候则可以从这个剥离出来的基础做起，让开发者更关注更具体的业务问题，而不是Web的请求和响应的控制。 </p><p>框架很多，但套路基本类似，帮你隐藏很多关于 HTTP 协议细节内容，专注功能开发。 </p><p>但对一个初学者来说，过早的接触框架往往是事倍功半！同样一个问题，换一种框架你可能需要从头开始研究。 </p><p>下面是针对初学 Java 开发 Web 过程一些个人见解和思路，高手可略过。</p><p>然后将下面 XML 内容替换 Tomcat 下的 conf/server.xml 文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;</span><br><span class="line">Server&quot;8005&quot;shutdown&quot;SHUTDOWN&quot;</span><br><span class="line">  Service&quot;Catalina&quot;</span><br><span class="line">    Connector&quot;8080&quot;protocol&quot;HTTP/1.1&quot;connectionTimeout&quot;20000&quot;redirectPort&quot;8443&quot;URIEncoding&quot;UTF-8&quot;/&gt;</span><br><span class="line">    Engine&quot;Catalina&quot;defaultHost&quot;localhost&quot;</span><br><span class="line">      &quot;localhost&quot;</span><br><span class="line">    ContextdocBase&quot;D:\WORKDIR\ServletDemo\webapp&quot;reloadable&quot;true&quot;/&gt;</span><br><span class="line">      &lt;/</span><br><span class="line">    &lt;/Engine</span><br><span class="line">  &lt;/Service</span><br><span class="line">&lt;/Server</span><br></pre></td></tr></table></figure><p>再次启动 Tomcat 后在浏览器打开 <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 便可看到 Hello World 的输出信息。</p><h2 id="了解-Servlet-和-Filter"><a href="#了解-Servlet-和-Filter" class="headerlink" title="了解 Servlet 和 Filter"></a>了解 Servlet 和 Filter</h2><p>好了，我已经把环境搭起来了，接下来该干嘛呢？</p><p>前面的步骤为的是搭建一个测试的环境，然后让你了解一个最基本的 Java Web 项目的结构。</p><p>一个最基本的 Java Web 项目所需的 jar 包只需要一个 servlet-api.jar ，这个 jar 包中的类大部分都是接口，还有一些工具类，共有 2 个包，分别是 javax.servlet 和 javax.servlet.http。我把这个jar包放到了 webapp 目录外的一个独立 packages 文件夹里，这是因为所有的 Servlet 容器都带有这个包，你无需再放到Web项目里，我们放到这里只不过是编译的需要，运行是不需要的。如果你硬是把 servlet-api.jar 放到 webapp/WEB-INF/lib 目录下，那么 Tomcat 启动时还会报一个警告信息。</p><p>Java Web 项目还需要一个非常重要的配置文件 web.xml ，在这个项目中已经被我最小化了，只保留有用的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; </span><br><span class="line">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;demo.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>每个 servlet 都必须在 web.xml 中定义并进行 URL 映射配置，早期 Java 开发 Web 在没有框架满天飞的时候，这个文件会定义了大量的 servlet，或者有人为了省事干脆来一个 /servlet/* 来通过类名直接调用 Servlet。</p><p>Servlet 规范里还有另外一个非常重要而且非常有用的接口那就是 Filter 过滤器。</p><p>下面是一个最简单的 Filter 类以及相应的定义方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package demo;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">public class HelloFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void init(FilterConfig arg0) throws ServletException &#123;</span><br><span class="line">System.out.println(&quot;Filter 初始化&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest req, ServletResponse res,</span><br><span class="line">FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest)req;</span><br><span class="line">System.out.println(&quot;拦截 URI=&quot;+request.getRequestURI());</span><br><span class="line">chain.doFilter(req, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void destroy() &#123;</span><br><span class="line">System.out.println(&quot;Filter 结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 web.xml 中的配置必须放在 Servlet 的前面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; </span><br><span class="line"> &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;helloFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;demo.HelloFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;helloFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;demo.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 时看看 Tomcat 控制台有何输出信息。</p><h2 id="Servlet-和-HTTP-的对应关系"><a href="#Servlet-和-HTTP-的对应关系" class="headerlink" title="Servlet 和 HTTP 的对应关系"></a>Servlet 和 HTTP 的对应关系</h2><p>Servlet 是 J2EE 最重要的一部分，有了 Servlet 你就是 J2EE 了，J2EE 的其他方面的内容择需采用。而 Servlet 规范你需要掌握的就是 servlet 和 filter 这两项技术。绝大多数框架不是基于 servlet 就是基于 filter，如果它要在 Servlet 容器上运行，就永远也脱离不开这个模型。</p><p>为什么 Servlet 规范会有两个包，javax.servlet 和 javax.servlet.http ，早先设计该规范的人认为 Servlet 是一种服务模型，不一定是依赖某种网络协议之上，因此就抽象出了一个 javax.servlet ，同时在提供一个基于 HTTP 协议上的接口扩展。但是从实际运行这么多年来看，似乎没有发现有在其他协议上实现的 Servlet 技术。</p><p>javax.servlet 和 javax.servlet.http 这两个包总共加起来也不过是三十四个接口和类。你需要通过 J2EE 的 JavaDoc 文档 熟知每个类和接口的具体意思。特别是下面几个接口必须熟知每个方法的意思和用途：</p><ul><li>HttpServlet</li><li>ServetConfig</li><li>ServletContext</li><li>Filter</li><li>FilterConfig</li><li>FilterChain</li><li>RequestDispatcher</li><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>一些 Listenser 类</li></ul><p>再次强调 HttpServletRequest 和 HttpServletResponse 这两个接口更应该是烂熟于心。</p><p>如果你从字面上无法理解某个方法的意思，你可以在前面那个项目的基础上做实验看看其输出，再不行你可以到讨论区提问，这样的提问非常明确，很多人都可以帮到你。</p><p>为什么我这么强调 HttpServletRequest 和 HttpServletResponse 这两个接口，因为 Web 开发是离不开 HTTP 协议的，而 Servlet 规范其实就是对 HTTP 协议做面向对象的封装，HTTP协议中的请求和响应就是对应了 HttpServletRequest 和 HttpServletResponse 这两个接口。</p><p>你可以通过 HttpServletRequest 来获取所有请求相关的信息，包括 URI、Cookie、Header、请求参数等等，别无它路。因此当你使用某个框架时，你想获取HTTP请求的相关信息，只要拿到 HttpServletRequest 实例即可。</p><p>而 HttpServletResponse接口是用来生产 HTTP 回应，包含 Cookie、Header 以及回应的内容等等。</p><h2 id="再谈谈-Session"><a href="#再谈谈-Session" class="headerlink" title="再谈谈 Session"></a>再谈谈 Session</h2><p>HTTP 协议里是没有关于 Session 会话的定义，Session 是各种编程语言根据 HTTP 协议的无状态这种特点而产生的。其实现无非就是服务器端的一个哈希表，哈希表的Key就是传递给浏览器的名为 jsessionid 的 Cookie 值。</p><p>当需要将某个值保存到 session 时，容器会执行如下几步：</p><p>a. 获取 jsessionid 值，没有的话就生成一个，也就是 request.getSession() 这个方法<br>b. 拿到的 HttpSession 对象实例就相当于一个哈希表，你可以往哈希表里存放数据(setAttribute)<br>c. 你也可以通过 getAttribute 来获取某个值</p><p>而这个名为 jsessionid 的 Cookie 在浏览器关闭时会自动删除。把 Cookie 的 MaxAge 值设为 -1 就能达到浏览器关闭自动删除的效果。</p><h2 id="关于-JSP"><a href="#关于-JSP" class="headerlink" title="关于 JSP"></a>关于 JSP</h2><p>任何一个 JSP 页面在执行的时候都会编译成一个 Servlet 类文件，如果是 Tomcat 的话，这些生成的 java 文件会放置在 {TOMCAT}/work 目录下对应项目的子目录中，例如 Tomcat 生成的类文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.jsp;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import javax.servlet.jsp.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public final class test_jsp extends org.apache.jasper.runtime.HttpJspBase</span><br><span class="line">    implements org.apache.jasper.runtime.JspSourceDependent &#123;</span><br><span class="line"></span><br><span class="line">  private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();</span><br><span class="line"></span><br><span class="line">  private static java.util.List&lt;String&gt; _jspx_dependants;</span><br><span class="line"></span><br><span class="line">  private javax.el.ExpressionFactory _el_expressionfactory;</span><br><span class="line">  private org.apache.tomcat.InstanceManager _jsp_instancemanager;</span><br><span class="line"></span><br><span class="line">  public java.util.List&lt;String&gt; getDependants() &#123;</span><br><span class="line">    return _jspx_dependants;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspInit() &#123;</span><br><span class="line">    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();</span><br><span class="line">    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspDestroy() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspService(final HttpServletRequest request, final HttpServletResponse response)</span><br><span class="line">        throws java.io.IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    final PageContext pageContext;</span><br><span class="line">    HttpSession session = null;</span><br><span class="line">    final ServletContext application;</span><br><span class="line">    final ServletConfig config;</span><br><span class="line">    JspWriter out = null;</span><br><span class="line">    final Object page = this;</span><br><span class="line">    JspWriter _jspx_out = null;</span><br><span class="line">    PageContext _jspx_page_context = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">      pageContext = _jspxFactory.getPageContext(this, request, response,</span><br><span class="line">      null, true, 8192, true);</span><br><span class="line">      _jspx_page_context = pageContext;</span><br><span class="line">      application = pageContext.getServletContext();</span><br><span class="line">      config = pageContext.getServletConfig();</span><br><span class="line">      session = pageContext.getSession();</span><br><span class="line">      out = pageContext.getOut();</span><br><span class="line">      _jspx_out = out;</span><br><span class="line"></span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;html&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;    &lt;title&gt;Test&lt;/title&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;    &lt;style&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;    &lt;/style&gt; \r\n&quot;);</span><br><span class="line">      out.write(&quot;  &lt;body&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;h1&gt;Test Demo (oschina)&lt;/h1&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;table cellspacing=\&quot;1\&quot; cellpadding=\&quot;5\&quot;&gt;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">Enumeration Names=request.getHeaderNames();</span><br><span class="line">while(Names.hasMoreElements())</span><br><span class="line">&#123;String name=(String)Names.nextElement();</span><br><span class="line">String value=request.getHeader(name);</span><br><span class="line"> </span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot; &lt;tr&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot; &lt;td&gt;&quot;);</span><br><span class="line">      out.print(name);</span><br><span class="line">      out.write(&quot;&lt;/td&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;  &lt;td&gt;&quot;);</span><br><span class="line">      out.print(value);</span><br><span class="line">      out.write(&quot;&lt;/td&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot; \r\n&quot;);</span><br><span class="line">      out.write(&quot; &lt;/tr&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot; &quot;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;/table&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;  &lt;/body&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">      if (!(t instanceof SkipPageException))&#123;</span><br><span class="line">        out = _jspx_out;</span><br><span class="line">        if (out != null &amp;&amp; out.getBufferSize() != 0)</span><br><span class="line">          try &#123; out.clearBuffer(); &#125; catch (java.io.IOException e) &#123;&#125;</span><br><span class="line">        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _jspxFactory.releasePageContext(_jspx_page_context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 servlet 中有一个包 javax.servlet.jsp 是跟 JSP 相关的一些接口规范定义。JSP 比 Servlet 方便的地方在于可直接修改立即生效，不像 Servlet 修改后必须重启容器才能生效。</p><p>因此 JSP 适合用来做视图，而 Servlet 则适合做控制层。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>罗哩罗嗦一大堆，归纳一下就是下面几点：</p><p>熟知 Servlet 规范之前，请不要学习任何框架<br>使用最简单的工具，不要任何向导和可视化<br>熟知 HTTP 协议<br>等你真的掌握了 Servlet 规范再去看框架，便会觉得一些都小菜。总之一点：不要被框架牵着鼻子走，框架是你的工具，它应该听你的！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.oschina.net/question/12_52027" target="_blank" rel="noopener">初学 Java Web 开发，请远离各种框架，从 Servlet 开发</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web框架是开发者在使用某种语言编写Web应用服务端时关于架构的最佳实践。很多Web框架是从实际的Web项目抽取出来的，仅和Web的请求和响应处理有关，形成一个基础，在开发别的应用项目的时候则可以从这个剥离出来的基础做起，让开发者更关注更具体的业务问题，而不是Web的请求和
      
    
    </summary>
    
      <category term="Java" scheme="http://haoweiguang.me/categories/Java/"/>
    
    
      <category term="servlet" scheme="http://haoweiguang.me/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet生命周期和工作原理</title>
    <link href="http://haoweiguang.me/2017/07/09/Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://haoweiguang.me/2017/07/09/Servlet生命周期和工作原理/</id>
    <published>2017-07-09T03:36:11.000Z</published>
    <updated>2017-07-09T03:38:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>名词解释：</p><ul><li>web.xml = 部署描述符（Deployment Descriptor ）</li><li>容器 = Servlet Container/Engine</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>主要有四个过程：init-&gt;service-&gt;doGet/doPost-&gt;destory</p><p>第一步：加载和实例化</p><ol><li>Servlet容器启动时自动装载某些Servlet，实现它只需要在web.XML文件中的<code>&lt;Servlet&gt;&lt;/Servlet&gt;</code>之间添加如下代码：<br><code>&lt;loadon-startup&gt;1&lt;/loadon-startup&gt;</code></li><li>在Servlet容器启动后，客户首次向Servlet发送请求</li><li>Servlet类文件被更新后，重新装载Servlet</li></ol><p>Servlet被装载后，Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化。在Servlet的整个生命周期内，init()方法只被调用一次。</p><p>第二步：初始化 </p><p>实例化后会立马进行初始化，并传递实现ServletConfig接口的对象。也就是执行init方法。在init（）方法中，Servlet可以部署描述符中读取配置参数，或者执行任何其他一次性活动。在Servlet的整个生命周期类，init（）方法只被调用一次。</p><p>第三步：请求处理</p><p>初始化后，Servlet就可以接受请求了。<br>基本方式是执行Servlet接口中的service方法。并把请求和响应对象作为参数传递。当并行的请求到来时，多个service（）方法能够同时运行在独立的线程中。<br>service()方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet()、doPost()、doPut()，doDelete() 等方法。<br>当然，API也提供了HttpServlet抽象类，其中有doGet、doPost等特殊方法。<br>注意：任意的容器按照规范必须实现上述几种方法，所以你的代码写在这几个方法中都可以。</p><p>第四步：终止服务</p><p>容器会在合适的时候销毁某个Servlet对象，这个策略取决于容器的开发者/商。<br>在容器关闭的时候Servlet对象一定会被销毁。<br>当1或2发生时，也就是Servlet对象被销毁时，destroy方法会被调用</p><p><img src="http://oo501cyv7.bkt.clouddn.com/14995681398150.png" alt></p><p>PS:<strong>Servlet的生命（周期）是由容器管理的，换句话说，Servlet程序员不能用代码控制其生命。</strong></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>首先简单解释一下Servlet接收和响应客户请求的过程，首先客户发送一个请求，Servlet是调用service()方法对请求进行响应的，通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet,doPost等这些方法，然后再进入对应的方法中调用逻辑层的方法，实现对客户的响应。在Servlet接口和GenericServlet中是没有doGet,doPost等等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息，所以，我们每次定义一个Servlet的时候，都必须实现doGet或doPost等这些方法。</p><p>每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。所以我们定义Servlet的时候只需要继承HttpServlet即可。</p><p>Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类，所以HttpServlet中实现了service()方法，并将请求ServletRequest,ServletResponse强转为HttpRequest和HttpResponse。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void service(ServletRequest req,ServletResponse res) </span><br><span class="line">  throws ServletException,IOException</span><br><span class="line">&#123;</span><br><span class="line">      HttpRequest request;</span><br><span class="line">      HttpResponse response;</span><br><span class="line"> </span><br><span class="line">     try</span><br><span class="line">     &#123;</span><br><span class="line">         req = (HttpRequest)request;</span><br><span class="line">         res = (HttpResponse)response;</span><br><span class="line">      &#125;catch(ClassCastException e)</span><br><span class="line">      &#123;</span><br><span class="line">         throw new ServletException(&quot;non-HTTP request response&quot;); </span><br><span class="line">      &#125;</span><br><span class="line">      service(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的最后调用了HTTPServlet自己的service(request,response)方法，然后根据请求去调用对应的doXXX方法，因为HttpServlet中的doXXX方法都是返回错误信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest res,HttpServletResponse resp)</span><br><span class="line">  throws ServletException,IOException</span><br><span class="line">&#123;</span><br><span class="line">   String protocol = req.getProtocol();</span><br><span class="line">   String msg = IStrings.getString(&quot;http.method_get_not_supported&quot;);</span><br><span class="line">   if(protocol.equals(&quot;1.1&quot;))</span><br><span class="line">   &#123;</span><br><span class="line">      resp.sendError(HttpServletResponse.SC.METHOD.NOT.ALLOWED,msg);</span><br><span class="line">    &#125;</span><br><span class="line">   esle</span><br><span class="line">    &#123;</span><br><span class="line">      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以需要我们在自定义的Servlet中override这些方法！</p><h3 id="Servlet响应请求阶段"><a href="#Servlet响应请求阶段" class="headerlink" title="Servlet响应请求阶段"></a>Servlet响应请求阶段</h3><p>对于用户到达Servlet的请求，Servlet容器会创建特定于这个请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service方法。service方法从ServletRequest对象获得客户请求信息，处理该请求，并通过ServletResponse对象向客户返回响应信息。</p><p>对于Tomcat来说，它会将传递过来的参数放在一个Hashtable中，该Hashtable的定义是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Hashtable&lt;String String[]&gt; paramHashStringArray = new Hashtable&lt;String String[]&gt;();</span><br></pre></td></tr></table></figure><p>这是一个String–&gt;String[]的键值映射。</p><p>HashMap线程不安全的，Hashtable线程安全。</p><h3 id="Servlet终止阶段"><a href="#Servlet终止阶段" class="headerlink" title="Servlet终止阶段"></a>Servlet终止阶段</h3><p>当WEB应用被终止，或Servlet容器终止运行，或Servlet容器重新装载Servlet新实例时，Servlet容器会先调用Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。</p><h3 id="Servlet何时被创建"><a href="#Servlet何时被创建" class="headerlink" title="Servlet何时被创建"></a>Servlet何时被创建</h3><ol><li><p>默认情况下，当WEB客户第一次请求访问某个Servlet的时候，WEB容器将创建这个Servlet的实例。</p></li><li><p>当web.xml文件中如果<servlet>元素中指定了<load-on-startup>子元素时，Servlet容器在启动web服务器时，将按照顺序创建并初始化Servlet对象。</load-on-startup></servlet></p></li></ol><p>注意：在web.xml文件中，某些Servlet只有<serlvet>元素，没有<servlet-mapping>元素，这样我们无法通过url的方式访问这些Servlet，这种Servlet通常会在<servlet>元素中配置一个<load-on-startup>子元素，让容器在启动的时候自动加载这些Servlet并调用init()方法，完成一些全局性的初始化工作。</load-on-startup></servlet></servlet-mapping></serlvet></p><h3 id="Web应用何时被启动"><a href="#Web应用何时被启动" class="headerlink" title="Web应用何时被启动"></a>Web应用何时被启动</h3><ol><li>当Servlet容器启动的时候，所有的Web应用都会被启动</li><li>控制器启动web应用</li></ol><h2 id="JSP运行原理"><a href="#JSP运行原理" class="headerlink" title="JSP运行原理"></a>JSP运行原理</h2><p>当Web服务器上的JSP页面第一次被请求执行时，JSP引擎先将JSP页面文件转译成一个Java文件，即Servlet，Java Servlet是基于服务器端编程的API，用Java Servlet编写的Java程序称为servlet，servlet通过HTML与客户交互。服务器将前面转译成的Java文件编译成字节码文件，再执行这个字节码文件来响应客户的请求。当这个JSP页面再次被请求时，只要该JSP文件没有被改动，JSP引擎就直接调用已装载的Servlet。</p><p>JSP工作原理<br>所有JSP页面，在执行的时候都会被服务器端的JSP引擎转换为Servelet（.java），然后又由JSP引擎调用Java编译器，将Servelet（.java）编译为Class文件（.class），并由Java虚拟机（JVM）解释执行。下面验证这一点：<br>有一个JSP页面Test.jsp，在浏览器地址栏中输入<a href="http://localhost:8080/Test.jsp" target="_blank" rel="noopener">http://localhost:8080/Test.jsp</a> ,将会出现执行结果。同时在%CATALINA_HOME%/work/Catalina/localhost下多出两个文件：_Test_jsp.java和_Test_jsp.class，他们分别就是Servelet和Class文件</p><h2 id="JSP和servlet的运行原理探讨"><a href="#JSP和servlet的运行原理探讨" class="headerlink" title="JSP和servlet的运行原理探讨"></a>JSP和servlet的运行原理探讨</h2><p>&lt;%page language=”java”%&gt;在服务器端执行.<br>客户端用户填写 HTML 表单，发送请求。将请求发送给 服务器端servlet(tomcat是servlet的容器)。 servlet 将该 HTTP 请求转换成一个 MQSeries 消息，并将其放入一个队列。 后端应用程序处理该消息，然后通过消息队列发回一个应答。 servlet 从队列中检索消息，并将其存放在一个 Java Bean 中。 然后 servlet 调用编译过的 Java Server Page(JSP) 并动态生成结果 HTML 页面。 JSP 从 Java Bean 检索出该页面需要的数据，将其合并到 HTML，然后将结果页面发送给客户端。</p><p>JSP中的html代码和javascrīpt代码不会在服务器端执行，servlet 调用编译过的 Java Server Page(JSP) ，也就是运行由JSP编译成的class文件(运行的代码包括actionBean,formBean,一般的bean 和内嵌在JSP的Java代码).</p><p>一个Web运行程序（网站）可以有多个servlet，一般认为一个action就是一个servlet.</p><p>所谓Servlet是指运行在服务器端的Java小程序。用于响应客户端的请求。在默认情况下，Servlet采用一种无状态的请求-响应处理方式。Servlet代码的主要作用是为了增强Java服务器端的功能，它运行在服务器端，用于接收并且处理浏览器客户端发出的请求，该请求是通过配置文件web.xml的相关配置进行转发。也就是说Servlet是一个标准的Java类，它符合Java类的一般规则。和一般的Java类不同之处只是在于Servlet可以处理Http请求。</p><ol><li>servlet是持久的。servlet只需Web服务器加载一次,后续又用到这个servlet，就不需要再加载。(所谓加载是指servlet加载进JVM运行)</li><li>servlet是与平台无关的。</li><li>servlet是可扩展的。</li></ol><h2 id="Servlet与JSP的比较"><a href="#Servlet与JSP的比较" class="headerlink" title="Servlet与JSP的比较"></a>Servlet与JSP的比较</h2><ul><li>有许多相似之处，都可以生成动态网页。</li><li>JSP的优点是擅长于网页制作，生成动态页面比较直观，缺点是不容易跟踪与排错。</li><li>Servlet是纯Java语言，擅长于处理流程和业务逻辑，缺点是生成动态网页不直观。</li></ul><p>参考：</p><ul><li><a href="http://blog.csdn.net/u010297957/article/details/51498018" target="_blank" rel="noopener">Servlet的历史与规范</a></li><li><a href="http://www.hollischuang.com/archives/849" target="_blank" rel="noopener">Servlet 3.1规范学习笔记（一）——Servlet生命周期和线程安全性问题</a></li><li><a href="http://www.cnblogs.com/cuiliang/archive/2011/10/21/2220671.html" target="_blank" rel="noopener">Servlet生命周期与工作原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;名词解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;web.xml = 部署描述符（Deployment Descriptor ）&lt;/li&gt;
&lt;li&gt;容器 = Servlet Container/Engine&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期
      
    
    </summary>
    
    
      <category term="java" scheme="http://haoweiguang.me/tags/java/"/>
    
      <category term="servlet" scheme="http://haoweiguang.me/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet容器详解</title>
    <link href="http://haoweiguang.me/2017/07/09/Servlet%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://haoweiguang.me/2017/07/09/Servlet容器详解/</id>
    <published>2017-07-09T03:34:54.000Z</published>
    <updated>2017-07-09T03:35:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Servlet-容器？"><a href="#什么是-Servlet-容器？" class="headerlink" title="什么是 Servlet 容器？"></a>什么是 Servlet 容器？</h2><p>容器就是你的程序运行时需要的环境。<br>Servlet Container（Servlet 容器） 是 Web 服务器或者应用服务器的一部分，用于提供基于请求/响应发送模式的网络服务，解码基于 MIME 的请求，并且格式化基于 MIME 的响应。Servlet 容器同时也包含和管理他们的生命周期里Servlet。</p><p>Servlet容器可以嵌入到宿主的 Web 服务器中，或者通过 Web 服务器的本地扩展 API 单独作为附加组件安装。Servelt 容器也可能内嵌或安装到启用 Web 功能的应用服务器中。</p><p>所有的 Servlet 容器必须支持 HTTP 协议用于请求和响应，但额外的基于 请求/响应 的协议，如 HTTPS (HTTP over SSL)的支持是可选的。对于 HTTP 规范需要版本，容器必须支持 HTTP/1.0 和 HTTP/1.1。因为容器或许支持 RFC2616 (HTTP/1.1)描述的缓存机制，缓存机制可能在将客户端请求交给 Servlet 处理之前修改它们，也可能在将 Servlet 生成的响应发送给客户端之前修改它们，或者可能根据 RFC2616 规范直接对请求作出响应而不交给 Servlet 进行处理。</p><p>Servlet 容器应该使 Servlet 执行在一个安全限制的环境中。在 Java 平台标准版（J2SE, v.1.3 或更高） 或者 Java平台企业版(Java EE, v.1.3 或更高) 的环境下，这些限制应该被放置在 Java 平台定义的安全许可架构中。比如，高端的应用服务器为了保证容器的其他组件不受到负面影响可能会限制 Thread 对象的创建。</p><p>Java SE 7 是构建 Servlet 容器最低的 Java平 台版本。</p><h2 id="常见的Servlet容器"><a href="#常见的Servlet容器" class="headerlink" title="常见的Servlet容器"></a>常见的Servlet容器</h2><p>Tomcat，apache,Jetty是Servlet的运行环境，即一个Servlet容器,做过java web开发的应该都知道。 </p><h2 id="Servlet的执行流程"><a href="#Servlet的执行流程" class="headerlink" title="Servlet的执行流程"></a>Servlet的执行流程</h2><ol><li>Servlet容器的作用是负责处理客户请求，当客户请求来到时，Servlet容器获取请求，然后调用某个Servlet，并把Servlet的执行结果返回给客户</li><li>Servlet容器的工作过程是：当客户请求某个资源时，Servlet容器使用ServletRequest对象把客户的请求信息封装起来，然后调用java Servlet API中定义的Servlet的一些生命周期方法，完成Servlet的执行，接着把Servlet执行的要返回给客户的结果封装到 ServletResponse对象中，最后Servlet容器把客户的请求发送给客户，完成为客户的一次服务过程。每一个Servlet的类都执行 init（）、service（）、destory（）三个函数的自动调用，在启动时调用一次init（）函数用以进行参数的初始化，在服务期间每当接收到对该Servlet的请求时都会调用Service（）函数执行该Servlet的服务操作，当容器销毁时调用一次destory（）函数。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-Servlet-容器？&quot;&gt;&lt;a href=&quot;#什么是-Servlet-容器？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Servlet 容器？&quot;&gt;&lt;/a&gt;什么是 Servlet 容器？&lt;/h2&gt;&lt;p&gt;容器就是你的程序运行时需要的环境。&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://haoweiguang.me/tags/java/"/>
    
      <category term="servlet" scheme="http://haoweiguang.me/tags/servlet/"/>
    
  </entry>
  
</feed>
