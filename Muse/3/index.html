<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="关于技术、产品、个人感悟等的记录">
<meta property="og:type" content="website">
<meta property="og:title" content="微光的Notes">
<meta property="og:url" content="http://www.haoweiguang.me/Muse/3/index.html">
<meta property="og:site_name" content="微光的Notes">
<meta property="og:description" content="关于技术、产品、个人感悟等的记录">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="微光的Notes">
<meta name="twitter:description" content="关于技术、产品、个人感悟等的记录">



  <link rel="alternate" href="/atom.xml" title="微光的Notes" type="application/atom+xml">




  <link rel="canonical" href="http://www.haoweiguang.me/Muse/3/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>微光的Notes</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-101937505-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-101937505-1');
</script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">微光的Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">梦想是要有的，万一实现了呢</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.haoweiguang.me/2017/07/02/网络协议进阶2——TCP-UDP协议详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/网络协议进阶2——TCP-UDP协议详解/" itemprop="url">
                  网络协议进阶2——TCP/UDP协议详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-02 11:17:47" itemprop="dateCreated datePublished" datetime="2017-07-02T11:17:47+08:00">2017-07-02</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/" itemprop="url" rel="index"><span itemprop="name">理解计算器机</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/02/网络协议进阶2——TCP-UDP协议详解/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/02/网络协议进阶2——TCP-UDP协议详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分开叙述tcp、ip、http/https等协议</p>
<p>这个协议在java中的体现？</p>
<p>分为应用层、传输层、网络层和实体层<br><img src="http://oo501cyv7.bkt.clouddn.com/14816321462047.jpg" alt></p>
<p>一、TCP/IP协议</p>
<p>TCP/IP协议（传输控制协议）由网络层的IP协议和传输层的TCP协议组成。IP层负责网络主机的定位，数据传输的路由，由IP地址可以唯一的确定Internet上的一台主机。TCP层负责面向应用的可靠的或非可靠的数据传输机制，这是网络编程的主要对象。</p>
<p>二、TCP与UDP</p>
<p>TCP是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。</p>
<p>　　UDP是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816330764039.jpg" alt></p>
<p>TCP与UDP区别：</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816332469431.jpg" alt></p>
<p>TCP特点：</p>
<p>　　1、TCP是面向连接的协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接协议，所以只能用于点对点的通讯。而且建立连接也需要消耗时间和开销。</p>
<p>　　2、TCP传输数据无大小限制，进行大数据传输。</p>
<p>　　3、TCP是一个可靠的协议，它能保证接收方能够完整正确地接收到发送方发送的全部数据。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816333163774.jpg" alt></p>
<p>UDP特点：</p>
<p>　　1、UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</p>
<p>　　2、UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。</p>
<p>　　3、UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816333420719.jpg" alt></p>
<p>TCP与UDP应用：</p>
<p>　　1、TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。</p>
<p>　　2，UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些</p>
<p>TCP通信需要服务器端侦听listen、接收客户端连接请求accept，等待客户端connect建立连接后才能进行数据包的收发(recv/send)工作。</p>
<p>而UDP则服务器和客户端的概念不明显，服务器端即接收端需要绑定端口，等待客户端的数据的到来。后续便可以进行数据的收发(recvfrom/sendto)工作。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816331321116.jpg" alt></p>
<p>参考</p>
<ul>
<li><a href="http://www.cnblogs.com/ghj1976/p/4295346.html" target="_blank" rel="noopener">HTTP TCP UDP Socket 关系的几个经典图</a></li>
<li><a href="https://krystalchisholm.wordpress.com/2010/11/24/chapter-17/" target="_blank" rel="noopener">Chapter 7 – ISP Services</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.haoweiguang.me/2017/07/02/网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路/" itemprop="url">
                  网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-02 11:16:14" itemprop="dateCreated datePublished" datetime="2017-07-02T11:16:14+08:00">2017-07-02</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/" itemprop="url" rel="index"><span itemprop="name">理解计算器机</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/02/网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/02/网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://oo501cyv7.bkt.clouddn.com/14816335778945.jpg" alt></p>
<p>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。</p>
<p>本文介绍 HTTP协议的历史演变和设计思路。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816948261078.jpg" alt></p>
<h2 id="一、HTTP-0-9"><a href="#一、HTTP-0-9" class="headerlink" title="一、HTTP/0.9"></a>一、HTTP/0.9</h2><p>HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p>
<p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure>
<p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p>
<p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>服务器发送完毕，就关闭TCP连接。</p>
<h2 id="二、HTTP-1-0"><a href="#二、HTTP-1-0" class="headerlink" title="二、HTTP/1.0"></a>二、HTTP/1.0</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p>
<p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p>
<p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。<br>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p>
<p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>
<h3 id="2-2-请求格式"><a href="#2-2-请求格式" class="headerlink" title="2.2 请求格式"></a>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>
<p>可以看到，这个格式与0.9版有很大变化。<br>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p>
<h3 id="2-3-回应格式"><a href="#2-3-回应格式" class="headerlink" title="2.3 回应格式"></a>2.3 回应格式</h3><p>服务器的回应如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>回应的格式是”头信息 + 一个空行（<code>\r\n</code>） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p>
<h3 id="2-4-Content-Type-字段"><a href="#2-4-Content-Type-字段" class="headerlink" title="2.4 Content-Type 字段"></a>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。<br>下面是一些常见的<code>Content-Type</code>字段的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* text/plain</span><br><span class="line">* text/html</span><br><span class="line">* text/css</span><br><span class="line">* image/jpeg</span><br><span class="line">* image/png</span><br><span class="line">* image/svg+xml</span><br><span class="line">* audio/mp4</span><br><span class="line">* video/mp4</span><br><span class="line">* application/javascript</span><br><span class="line">* application/pdf</span><br><span class="line">* application/zip</span><br><span class="line">* application/atom+xml</span><br></pre></td></tr></table></figure>
<p>这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。<br>除了预定义的类型，厂商也可以自定义类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.debian.binary-package</span><br></pre></td></tr></table></figure>
<p>上面的类型表明，发送的是Debian系统的二进制数据包。<br>MIME type还可以在尾部使用分号，添加参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>上面的类型表明，发送的是网页，而且编码是UTF-8。<br>客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>
<p>上面代码中，客户端声明自己可以接受任何格式的数据。<br>MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-Content-Encoding-字段"><a href="#2-5-Content-Encoding-字段" class="headerlink" title="2.5 Content-Encoding 字段"></a>2.5 Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure>
<p>客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>
<h3 id="2-6-缺点"><a href="#2-6-缺点" class="headerlink" title="2.6 缺点"></a>2.6 缺点</h3><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。<br>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。<br>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h2 id="三、HTTP-1-1"><a href="#三、HTTP-1-1" class="headerlink" title="三、HTTP/1.1"></a>三、HTTP/1.1</h2><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p>
<h3 id="3-1-持久连接"><a href="#3-1-持久连接" class="headerlink" title="3.1 持久连接"></a>3.1 持久连接</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。<br>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h3 id="3-2-管道机制"><a href="#3-2-管道机制" class="headerlink" title="3.2 管道机制"></a>3.2 管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h3 id="3-3-Content-Length-字段"><a href="#3-3-Content-Length-字段" class="headerlink" title="3.3 Content-Length 字段"></a>3.3 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure>
<p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。<br>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>
<h3 id="3-4-分块传输编码"><a href="#3-4-分块传输编码" class="headerlink" title="3.4 分块传输编码"></a>3.4 分块传输编码</h3><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>
<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p>
<p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure>
<p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="3-5-其他功能"><a href="#3-5-其他功能" class="headerlink" title="3.5 其他功能"></a>3.5 其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p>
<p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>
<p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
<h3 id="3-6-缺点"><a href="#3-6-缺点" class="headerlink" title="3.6 缺点"></a>3.6 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank" rel="noopener">队头堵塞</a>“（Head-of-line blocking）。</p>
<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h2 id="四、SPDY-协议"><a href="#四、SPDY-协议" class="headerlink" title="四、SPDY 协议"></a>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。<br>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p>
<h2 id="五、HTTP-2"><a href="#五、HTTP-2" class="headerlink" title="五、HTTP/2"></a>五、HTTP/2</h2><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p>
<h3 id="5-1-二进制协议"><a href="#5-1-二进制协议" class="headerlink" title="5.1 二进制协议"></a>5.1 二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>
<p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h3 id="5-2-多工"><a href="#5-2-多工" class="headerlink" title="5.2 多工"></a>5.2 多工</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>
<p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p>
<p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<h3 id="5-3-数据流"><a href="#5-3-数据流" class="headerlink" title="5.3 数据流"></a>5.3 数据流</h3><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p>
<p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p>
<p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h3 id="5-4-头信息压缩"><a href="#5-4-头信息压缩" class="headerlink" title="5.4 头信息压缩"></a>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>
<p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h3 id="5-5-服务器推送"><a href="#5-5-服务器推送" class="headerlink" title="5.5 服务器推送"></a>5.5 服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>
<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a></li>
<li><a href="http://www.open-open.com/solution/view/1455863940495" target="_blank" rel="noopener">http协议和tcp协议的区别是什么</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.haoweiguang.me/2017/07/02/网络协议入门（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/网络协议入门（二）/" itemprop="url">
                  网络协议入门（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-02 11:04:45" itemprop="dateCreated datePublished" datetime="2017-07-02T11:04:45+08:00">2017-07-02</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/" itemprop="url" rel="index"><span itemprop="name">理解计算器机</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/02/网络协议入门（二）/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/02/网络协议入门（二）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="七、一个小结"><a href="#七、一个小结" class="headerlink" title="七、一个小结"></a>七、一个小结</h2><p>先对前面的内容，做一个小结。</p>
<p>我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816280847955.jpg" alt></p>
<p>发送这个包，需要知道两个地址：</p>
<ul>
<li>对方的MAC地址</li>
<li>对方的IP地址</li>
</ul>
<p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816281262864.jpg" alt></p>
<p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p>
<p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：<br><img src="http://oo501cyv7.bkt.clouddn.com/14816281721776.jpg" alt></p>
<p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。</p>
<h2 id="八、用户的上网设置"><a href="#八、用户的上网设置" class="headerlink" title="八、用户的上网设置"></a>八、用户的上网设置</h2><h3 id="8-1-静态IP地址"><a href="#8-1-静态IP地址" class="headerlink" title="8.1 静态IP地址"></a>8.1 静态IP地址</h3><p>你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816282063772.jpg" alt></p>
<p>通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p>
<ul>
<li>本机的IP地址</li>
<li>子网掩码</li>
<li>网关的IP地址</li>
<li>DNS的IP地址</li>
</ul>
<p>下图是Windows系统的设置窗口。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816283222474.jpg" alt></p>
<p>这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。</p>
<p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p>
<h3 id="8-2-动态IP地址"><a href="#8-2-动态IP地址" class="headerlink" title="8.2 动态IP地址"></a>8.2 动态IP地址</h3><p>所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。</p>
<p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p>
<p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p>
<p>DHCP协议做了一些巧妙的规定。</p>
<h3 id="8-3-DHCP协议"><a href="#8-3-DHCP协议" class="headerlink" title="8.3 DHCP协议"></a>8.3 DHCP协议</h3><p>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816284096522.jpg" alt></p>
<p>   （1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p>
<p>  （2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p>
<p>　（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。<br>　<br>　这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。<br>　<br>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p>
<p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p>
<h3 id="8-4-上网设置：小结"><a href="#8-4-上网设置：小结" class="headerlink" title="8.4 上网设置：小结"></a>8.4 上网设置：小结</h3><p>这个部分，需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p>
<ul>
<li>本机的IP地址</li>
<li>子网掩码</li>
<li>网关的IP地址</li>
<li>DNS的IP地址</li>
</ul>
<p>有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。</p>
<h2 id="九、一个实例：访问网页"><a href="#九、一个实例：访问网页" class="headerlink" title="九、一个实例：访问网页"></a>九、一个实例：访问网页</h2><h3 id="9-1-本机参数"><a href="#9-1-本机参数" class="headerlink" title="9.1 本机参数"></a>9.1 本机参数</h3><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数：</p>
<ul>
<li>本机的IP地址：192.168.1.100</li>
<li>子网掩码：255.255.255.0</li>
<li>网关的IP地址：192.168.1.1</li>
<li>DNS的IP地址：8.8.8.8</li>
</ul>
<p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816286436708.jpg" alt></p>
<p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p>
<h3 id="9-2-DNS协议"><a href="#9-2-DNS协议" class="headerlink" title="9.2 DNS协议"></a>9.2 DNS协议</h3><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。</p>
<p><a href="http://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">DNS协议</a>可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816287378399.jpg" alt></p>
<p>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p>
<h3 id="9-3-子网掩码"><a href="#9-3-子网掩码" class="headerlink" title="9.3 子网掩码"></a>9.3 子网掩码</h3><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p>
<p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p>
<p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p>
<h3 id="9-4-应用层协议"><a href="#9-4-应用层协议" class="headerlink" title="9.4 应用层协议"></a>9.4 应用层协议</h3><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816289059177.jpg" alt></p>
<p>HTTP部分的内容，类似于下面这样：</p>
<p>```<br>　　GET / HTTP/1.1<br>　　Host: www.google.com<br>　　Connection: keep-alive<br>　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ……<br>　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>　　Accept-Encoding: gzip,deflate,sdch<br>　　Accept-Language: zh-CN,zh;q=0.8<br>　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3<br>　　Cookie: … …</p>
<p>```　<br>　<br>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p>
<h3 id="9-5-TCP协议"><a href="#9-5-TCP协议" class="headerlink" title="9.5 TCP协议"></a>9.5 TCP协议</h3><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p>
<p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p>
<h3 id="9-6-IP协议"><a href="#9-6-IP协议" class="headerlink" title="9.6 IP协议"></a>9.6 IP协议</h3><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p>
<p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p>
<h3 id="9-7-以太网协议"><a href="#9-7-以太网协议" class="headerlink" title="9.7 以太网协议"></a>9.7 以太网协议</h3><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p>
<p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p>
<p><img src="media/14816259798684/14816290203170.jpg" alt></p>
<h3 id="9-8-服务器端响应"><a href="#9-8-服务器端响应" class="headerlink" title="9.8 服务器端响应"></a>9.8 服务器端响应</h3><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p>
<p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p>
<p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>
<p><img src="media/14816259798684/14816290564421.jpg" alt></p>
<p>这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">互联网协议入门（二）</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.haoweiguang.me/2017/07/02/网络协议入门（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/网络协议入门（一）/" itemprop="url">
                  网络协议入门（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-02 10:54:17" itemprop="dateCreated datePublished" datetime="2017-07-02T10:54:17+08:00">2017-07-02</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/" itemprop="url" rel="index"><span itemprop="name">理解计算器机</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/02/网络协议入门（一）/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/02/网络协议入门（一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络协议入门（一）"><a href="#网络协议入门（一）" class="headerlink" title="网络协议入门（一）"></a>网络协议入门（一）</h1><p>我们每天使用互联网，你是否想过，它是如何实现的？<br>全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？</p>
<p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。</p>
<p>下面就是我的学习笔记。因为这些协议实在太复杂、太庞大，我想整理一个简洁的框架，帮助自己从总体上把握它们。为了保证简单易懂，我做了大量的简化，有些地方并不全面和精确，但是应该能够说清楚互联网的原理。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-五层模型"><a href="#1-1-五层模型" class="headerlink" title="1.1 五层模型"></a>1.1 五层模型</h3><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p>
<p>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p>
<p>如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816246370013.jpg" alt></p>
<p>如上图所示，最底下的一层叫做”实体层”（Physical Layer），最上面的一层叫做”应用层”（Application Layer），中间的三层（自下而上）分别是”链接层”（Link Layer）、”网络层”（Network Layer）和”传输层”（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p>
<p>它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。</p>
<h3 id="1-2-层与协议"><a href="#1-2-层与协议" class="headerlink" title="1.2 层与协议"></a>1.2 层与协议</h3><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。<br>大家都遵守的规则，就叫做”协议”（protocol）。</p>
<p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p>
<h2 id="二、实体层"><a href="#二、实体层" class="headerlink" title="二、实体层"></a>二、实体层</h2><p>我们从最底下的一层开始。</p>
<p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816251058498.jpg" alt></p>
<p>这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p>
<h2 id="三、链接层"><a href="#三、链接层" class="headerlink" title="三、链接层"></a>三、链接层</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p>
<p>这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。</p>
<h3 id="3-2-以太网协议"><a href="#3-2-以太网协议" class="headerlink" title="3.2 以太网协议"></a>3.2 以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p>
<p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816251883055.jpg" alt></p>
<p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p>
<p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>
<h3 id="3-3-MAC地址"><a href="#3-3-MAC地址" class="headerlink" title="3.3 MAC地址"></a>3.3 MAC地址</h3><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p>
<p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816253012951.jpg" alt></p>
<p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816253370028.jpg" alt></p>
<p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>
<h3 id="3-4-广播"><a href="#3-4-广播" class="headerlink" title="3.4 广播"></a>3.4 广播</h3><p>定义地址只是第一步，后面还有更多的步骤。</p>
<p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p>
<p>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</p>
<p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？</p>
<p>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816253745582.jpg" alt></p>
<p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p>
<p>有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</p>
<h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><h3 id="4-1-网络层的由来"><a href="#4-1-网络层的由来" class="headerlink" title="4.1 网络层的由来"></a>4.1 网络层的由来</h3><p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p>
<p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p>
<p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816254458858.jpg" alt></p>
<p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>
<p><strong>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p>
<p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p>
<p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p>
<h3 id="4-2-IP协议"><a href="#4-2-IP协议" class="headerlink" title="4.2 IP协议"></a>4.2 IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p>
<p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816255100692.jpg" alt></p>
<p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p>
<p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p>
<p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p>
<p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。</p>
<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p>
<p>总结一下，<strong>IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络</strong>。</p>
<h3 id="4-3-IP数据包"><a href="#4-3-IP数据包" class="headerlink" title="4.3 IP数据包"></a>4.3 IP数据包</h3><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p>
<p>但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p>
<p>回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p>
<p>具体来说，IP数据包也分为”标头”和”数据”两个部分。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816255957408.jpg" alt></p>
<p>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816256121670.jpg" alt></p>
<p>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<h3 id="4-4-ARP协议"><a href="#4-4-ARP协议" class="headerlink" title="4.4 ARP协议"></a>4.4 ARP协议</h3><p>关于”网络层”，还有最后一点需要说明。</p>
<p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p>
<p>所以，我们需要一种机制，能够从IP地址得到MAC地址。</p>
<p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p>
<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p>
<p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p>
<h2 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h2><h3 id="5-1-传输层的由来"><a href="#5-1-传输层的由来" class="headerlink" title="5.1 传输层的由来"></a>5.1 传输层的由来</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p><strong>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流</strong>。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>
<h3 id="5-2-UDP协议"><a href="#5-2-UDP协议" class="headerlink" title="5.2 UDP协议"></a>5.2 UDP协议</h3><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p>
<p>UDP数据包，也是由”标头”和”数据”两部分组成。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816257733505.jpg" alt></p>
<p>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816257948856.jpg" alt></p>
<p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p>
<h3 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a>5.3 TCP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>
<p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>
<p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p>
<p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<h2 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h2><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p>
<p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816258786010.jpg" alt></p>
<p>至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门（一）</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.haoweiguang.me/2017/07/01/java反射基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/01/java反射基础知识/" itemprop="url">
                  java反射基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-01 14:50:46" itemprop="dateCreated datePublished" datetime="2017-07-01T14:50:46+08:00">2017-07-01</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/01/java反射基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/01/java反射基础知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p><strong>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性</strong>；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制.</p>
<p>白话<br>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。</p>
<p>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p>反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java反射框架主要提供以下功能：</p>
<p>1.在运行时判断任意一个对象所属的类；<br>2.在运行时构造任意一个类的对象；<br>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>4.在运行时调用任意一个对象的方法</p>
<p><strong>==重点：是运行时而不是编译时==</strong></p>
<h2 id="有什么用处？"><a href="#有什么用处？" class="headerlink" title="有什么用处？"></a>有什么用处？</h2><p>==反射最重要的用途就是开发各种通用框架。具有强大的解耦性==</p>
<p>JUnit的@Test和Spring的@Controller和@RequestMapping是很好的例子。</p>
<p>当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p>
<p>很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p>
<p>举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如：</p>
<action name="login" class="org.ScZyhSoft.test.action.SimpleLoginAction" method="execute"><br>           <result>/shop/shop-index.jsp</result><br>           <result name="error">login.jsp</result><br>  </action>

<p>配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。<br>——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。<br>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
<h2 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h2><p>JAVA的反射你一定要知道四个类:</p>
<p>Class，Constructor，Field，Method;<br>Class 代表类的对象<br>Constructor 代表类的构造器对象<br>Field 代表了类的成员变量<br>Method 代表了类的方法对象</p>
<p>获得Class对象</p>
<p>方法有三种<br>(1)使用Class类的forName静态方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String className)</span><br><span class="line">Class c1=Class.forName(&quot;me.light.Person&quot;);</span><br></pre></td></tr></table></figure>
<p>(2)直接获取某一个对象的class，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = int.class;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br><span class="line">Class c2=me.light.Person.class;</span><br></pre></td></tr></table></figure>
<p>(3)调用某个对象的getClass()方法,比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = new StringBuilder(&quot;123&quot;);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br><span class="line">Class c3=person.getClass();</span><br></pre></td></tr></table></figure>
<p>2、判断是否为某个类的实例</p>
<p>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的<code>isInstance()</code>方法来判断是否为某个类的实例，它是一个Native方法：</p>
<p><code>public native boolean isInstance(Object obj);</code></p>
<p>3、创建实例</p>
<p>通过反射来生成对象主要有两种方式。</p>
<p>（1）使用Class对象的<code>newInstance()</code>方法来创建Class对象对应类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure>
<p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p>
<p>//获取String所对应的Class对象<br><code>Class&lt;?&gt; c = String.class;</code><br>//获取String类带一个String参数的构造器<br><code>Constructor constructor = c.getConstructor(String.class);</code><br>//根据构造器创建实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = constructor.newInstance(&quot;23333&quot;);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>
<p>4、获取方法</p>
<p>获取某个Class对象的方法集合，主要有以下几个方法：</p>
<p>4.1 <code>getDeclaredMethods()</code>方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><code>public Method[] getDeclaredMethods() throws SecurityException</code></p>
<p>4.2 <code>getMethods()</code>方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><code>public Method[] getMethods() throws SecurityException</code></p>
<p>4.3 <code>getMethod()</code>方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象<br><code>public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></p>
<p>通过getMethods()获取的方法可以获取到父类的方法,比如java.lang.Object下定义的各个方法。</p>
<p>5、获取构造器信息<br>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:</p>
<p><code>public T newInstance(Object ... initargs)</code></p>
<p>此方法可以根据传入的参数来调用对应的Constructor创建对象实例~</p>
<p>6、获取类的成员变量（字段）信息<br>主要是这几个方法，在此不再赘述：<br>getFiled: 访问公有的成员变量<br>getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）</p>
<p>7、调用方法<br>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">        throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">           InvocationTargetException</span><br></pre></td></tr></table></figure>
<p>下面是一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; klass = methodClass.class;</span><br><span class="line">        //创建methodClass的实例</span><br><span class="line">        Object obj = klass.newInstance();</span><br><span class="line">        //获取methodClass类的add方法</span><br><span class="line">        Method method = klass.getMethod(&quot;add&quot;,int.class,int.class);</span><br><span class="line">        //调用method对应的方法 =&gt; add(1,4)</span><br><span class="line">        Object result = method.invoke(obj,1,4);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class methodClass &#123;</span><br><span class="line">    public final int fuck = 3;</span><br><span class="line">    public int add(int a,int b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sub(int a,int b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于invoke()方法的详解，后面我会专门写一篇文章来深入解析invoke的过程。</p>
<p>一些注意事项</p>
<p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。<br>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F" target="_blank" rel="noopener">深入解析Java反射（1） - 基础</a></li>
<li><a href="https://juejin.im/post/58c93ea144d9040069eb72ba" target="_blank" rel="noopener">开发笔记之你弄不懂的JAVA反射机制</a></li>
<li><a href="https://juejin.im/post/5906f77461ff4b0066cb88f7" target="_blank" rel="noopener">Java 基础与提高干货系列—Java 反射机制 | 掘金技术征文</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.haoweiguang.me/2017/05/08/Mac下shadowsocks全自动地代理翻墙/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/08/Mac下shadowsocks全自动地代理翻墙/" itemprop="url">
                  Mac下shadowsocks全自动地代理翻墙
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-08 15:07:16" itemprop="dateCreated datePublished" datetime="2017-05-08T15:07:16+08:00">2017-05-08</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/利器/" itemprop="url" rel="index"><span itemprop="name">利器</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/08/Mac下shadowsocks全自动地代理翻墙/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/05/08/Mac下shadowsocks全自动地代理翻墙/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Shadowsocks服务端"><a href="#Shadowsocks服务端" class="headerlink" title="Shadowsocks服务端"></a>Shadowsocks服务端</h2><p>可以搭建自己服务，也可以买现成的服务。我就是在shadowsocks.com买的服务。</p>
<h3 id="测速-speed-test"><a href="#测速-speed-test" class="headerlink" title="测速 speed test"></a>测速 speed test</h3><h4 id="手机上下载-【BestTrace】-app-测试连接翻墙服务节点的路由跳数，并绘制地图："><a href="#手机上下载-【BestTrace】-app-测试连接翻墙服务节点的路由跳数，并绘制地图：" class="headerlink" title="手机上下载 【BestTrace】 app 测试连接翻墙服务节点的路由跳数，并绘制地图："></a>手机上下载 【BestTrace】 app 测试连接翻墙服务节点的路由跳数，并绘制地图：</h4><ol>
<li>路由跳数</li>
<li>地图：是否有绕路</li>
</ol>
<h4 id="MAC和windows"><a href="#MAC和windows" class="headerlink" title="MAC和windows"></a>MAC和windows</h4><p>官方网站 下载：<a href="https://www.ipip.net/download.html" target="_blank" rel="noopener">https://www.ipip.net/download.html</a></p>
<p>Windows / Mac OS X 客户端<br>android / iOS 客户端</p>
<h2 id="Shadowsocks客户端配置"><a href="#Shadowsocks客户端配置" class="headerlink" title="Shadowsocks客户端配置"></a>Shadowsocks客户端配置</h2><h3 id="shadowsocks-on-Mac-OS-X"><a href="#shadowsocks-on-Mac-OS-X" class="headerlink" title="shadowsocks on Mac OS X"></a>shadowsocks on Mac OS X</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>github release 下载地址：</p>
<ul>
<li>Mac 新版客户端：<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases/" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG/releases/</a></li>
<li>Mac 旧版客户端：<a href="https://github.com/shadowsocks/shadowsocks-iOS/releases/" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-iOS/releases/</a></li>
</ul>
<h4 id="MD5-hash"><a href="#MD5-hash" class="headerlink" title="MD5 hash"></a>MD5 hash</h4><p>打开 终端 应用，使用 <code>md5</code> 命令校验下载文件的 MD5 哈希值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ md5 Downloads/ShadowsocksX-2.6.3.dmg</span><br><span class="line">MD5 (Downloads/ShadowsocksX-2.6.3.dmg) = c3406e8d4a5009efaa74d3a37b53fed8</span><br></pre></td></tr></table></figure>
<h4 id="ShadowsocksX安装配置"><a href="#ShadowsocksX安装配置" class="headerlink" title="ShadowsocksX安装配置"></a>ShadowsocksX安装配置</h4><ol>
<li>运行 ShadowsocksX</li>
<li>配置 代理服务器</li>
<li>连接 代理服务器</li>
<li>开启 系统代理</li>
<li>测试 科学上网</li>
<li>从 <code>GFWList</code> 更新 PAC 文件</li>
</ol>
<p>【运行】ShadowsocksX<br>运行 ShadowsocksX 后，会在 menubar 显示 「纸飞机」 图标<br>默认图标为 灰色 表示 「系统代理」 未启动<br><img src="http://images.insuncle.com/mweb/14813822404491.jpg" alt></p>
<p>【编辑】代理服务器</p>
<p>点击 「纸飞机」 选择 「服务器」 菜单，然后点击 【打开服务器设定】 选项：<br><img src="http://images.insuncle.com/mweb/14813824182249.jpg" alt></p>
<p>弹出 「服务器设定」 窗口：<br><img src="http://images.insuncle.com/mweb/14813824401968.jpg" alt></p>
<p>【连接】代理服务器</p>
<p>选中 「服务器」 菜单创建的代理服务器配置，出现对号 「√」 表示与代理服务器建立连接<br>成功与代理服务器建立连接后，便会创建 「SOCKS5 代理」<br><img src="http://images.insuncle.com/mweb/14813826263320.jpg" alt></p>
<p>【开启】系统代理</p>
<p>点击「主菜单」 第二行 【打开 shadowsocks】 启用 「系统代理」：</p>
<ol>
<li>第一行：系统代理 运行 状态，显示 「关闭」 状态</li>
<li>第二行：系统代理 运行 开关，默认 系统代理 没有启动（ 图标为 灰色 ）<br><img src="http://images.insuncle.com/mweb/14813827865115.jpg" alt></li>
</ol>
<p>系统代理 启动后 menubar 的 「纸飞机」 图标也变为 黑色：<br><img src="http://images.insuncle.com/mweb/14813828342006.jpg" alt></p>
<p>「系统代理」 与 「SOCKS5 代理」 区别：<br>系统代理</p>
<ul>
<li>浏览器的访问请求全部由 shadowsocks 创建的 系统代理 处理</li>
<li>浏览器默认不需要任何设置，也无需安装 代理插件 （Firefox 除外）</li>
<li>如果浏览器安装了代理插件，需要 禁用 代理插件 或把插件设置为 使用系统代理</li>
</ul>
<p>SOCKS5 代理</p>
<ul>
<li>若不 【启用系统代理】 shadowsocks 成功连接代理服务器后，仅创建了 「SOCKS5 代理」</li>
<li>浏览器需要安装 代理插件 或设置浏览器的代理配置，才能科学上网</li>
</ul>
<p>【测试】科学上网</p>
<p>如果 系统代理 运行成功，就可以访问 google 。如果失败，请检查 「服务器配置」 是否正确：<br><img src="http://images.insuncle.com/mweb/14813829541791.jpg" alt></p>
<p>【更新】PAC 文件</p>
<p>最后在主菜单中点击 「从 GFWList 更新 PAC 文件」 更新翻墙列表：<br><img src="http://images.insuncle.com/mweb/14813830308088.jpg" alt></p>
<p>SOCKS5 代理<br>默认 ShadowsocksX 创建的 「SOCKS5 代理」端口 是 1080 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep 127 ~/.ShadowsocksX/gfwlist.js</span><br><span class="line">var proxy = &quot;SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT;&quot;;</span><br></pre></td></tr></table></figure>
<p>ShadowsocksX-NG 本地端口更换为 1086 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat &quot;/Users/yourname/Library/Application Support/ShadowsocksX-NG/ss-local-config.json&quot;a</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;method&quot; : &quot;rc4-md5&quot;,</span><br><span class="line">  &quot;server&quot; : &quot;IP&quot;,</span><br><span class="line">  &quot;password&quot; : &quot;...&quot;,</span><br><span class="line">  &quot;local_address&quot; : &quot;127.0.0.1&quot;,</span><br><span class="line">  &quot;server_port&quot; : ...,</span><br><span class="line">  &quot;auth&quot; : false,</span><br><span class="line">  &quot;timeout&quot; : 60,</span><br><span class="line">  &quot;local_port&quot; : 1086</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以自行修改 ~/.ShadowsocksX/gfwlist.js 配置文件，自定义 「SOCKS5 代理」端口</p>
<h3 id="shadowsocks-on-IOS"><a href="#shadowsocks-on-IOS" class="headerlink" title="shadowsocks on IOS"></a>shadowsocks on IOS</h3><h4 id="Potatso"><a href="#Potatso" class="headerlink" title="Potatso"></a>Potatso</h4><p>APP Store ：<a href="https://itunes.apple.com/app/apple-store/id1070901416" target="_blank" rel="noopener">https://itunes.apple.com/app/apple-store/id1070901416</a><br><a href="https://potatso.com/" target="_blank" rel="noopener">https://potatso.com/</a><br><a href="https://manual.potatso.com/" target="_blank" rel="noopener">https://manual.potatso.com/</a><br><a href="https://github.com/shadowsocks/Potatso" target="_blank" rel="noopener">https://github.com/shadowsocks/Potatso</a></p>
<h4 id="Mume-VPN"><a href="#Mume-VPN" class="headerlink" title="Mume VPN"></a>Mume VPN</h4><p>基于 Potatso 开发的 Shadowsocks 协议 VPN 客户端<br>APP Store ：<a href="https://itunes.apple.com/cn/app/mume-vpn/id1144787928" target="_blank" rel="noopener">https://itunes.apple.com/cn/app/mume-vpn/id1144787928</a><br><a href="https://github.com/liruqi/Mume-iOS" target="_blank" rel="noopener">https://github.com/liruqi/Mume-iOS</a><br><a href="http://vpn.liruqi.info/ios/" target="_blank" rel="noopener">http://vpn.liruqi.info/ios/</a><br><a href="http://api.liruqi.info/" target="_blank" rel="noopener">http://api.liruqi.info/</a><br><a href="http://mume.site/" target="_blank" rel="noopener">http://mume.site/</a></p>
<h2 id="PAC代理模式"><a href="#PAC代理模式" class="headerlink" title="PAC代理模式"></a>PAC代理模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>翻墙原理就是通过 「<strong>SOCKS5 代理</strong>」 来访问被和谐的网站</p>
<p>shadowsocks 客户端除了创建 「<strong>SOCKS5 代理</strong>」 外，还实现了创建 「系统代理」 的功能，通过 「系统代理」 来管理浏览器的访问请求（分流）。「系统代理」 支持 2 种 代理模式：</p>
<ol>
<li>自动代理模式 ( 即 PAC 模式 ，默认 )</li>
<li>全局代理模式</li>
</ol>
<h4 id="PAC-代理模式"><a href="#PAC-代理模式" class="headerlink" title="PAC 代理模式"></a>PAC 代理模式</h4><p>PAC 维基百科：<a href="http://zh.wikipedia.org/zh/PAC" target="_blank" rel="noopener">http://zh.wikipedia.org/zh/PAC</a></p>
<p>默认 shadowsocks 启用 「系统代理」 后使用的是 【<strong>PAC 代理模式</strong>】</p>
<p>Shadowsocks 成功 连接代理服务器 后，会创建一个 「<strong>SOCKS5 代理</strong>」</p>
<p>Socks 5 代理 使用的是本机 <code>127.0.0.1:1080</code> 端口</p>
<p>【<strong>PAC 代理模式</strong>】 当浏览器访问某个网站时，会去匹配 <strong>PAC 配置文件</strong> pac.txt 里 URL 列表。如果能匹配到 PAC 文件配置的 URL 就会使用「SOCKS5 代理」访问该网站。否则不使用代理，直接访问网站。既节省 ss 流量，也会提高 国内 网站的访问速度，不然访问国内网站要绕到国外代理再绕回来。</p>
<h4 id="全局代理模式"><a href="#全局代理模式" class="headerlink" title="全局代理模式"></a>全局代理模式</h4><p>全局代理模式 所有请求全部走 「<strong>SOCKS5 代理</strong>」。访问 国内 网站时，将会先绕到 国外 的代理服务器，然后在绕回来，南辕北辙了。当访问的网站没有包含在 PAC 文件的匹配规则列表时，可以 临时 开启全局代理进行访问。</p>
<p>菜单<br><img src="http://images.insuncle.com/mweb/14813841973907.jpg" alt></p>
<h3 id="编辑-PAC-规则"><a href="#编辑-PAC-规则" class="headerlink" title="编辑 PAC 规则"></a>编辑 PAC 规则</h3><p>从 GFWList 同步的 PAC 规则后，会在本地生成的 PAC 文件 ：</p>
<p>Mac OS X 是在<code>~/.ShadowsocksX/gfwlist.js</code>里</p>
<p>新版本的可以在shadowsocks里直接设置</p>
<p><img src="http://images.insuncle.com/mweb/14813844089754.jpg" alt></p>
<p>然后在弹框中输入<br><img src="http://images.insuncle.com/mweb/14813844540632.jpg" alt></p>
<p>里边的文档格式可以参考<a href="Adblock Plus filters explained">https://adblockplus.org/en/filter-cheatsheet</a>，两者的写法完全相同，下面是我的用户规则文件user-rule.txt的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">! Put user rules line by line in this file.</span><br><span class="line">! See https://adblockplus.org/en/filter-cheatsheet</span><br><span class="line"></span><br><span class="line">||aws.amazon.com^</span><br><span class="line">||amazonwebservices.com^</span><br><span class="line">||cloudfront.net^</span><br><span class="line">||google.com^</span><br></pre></td></tr></table></figure>
<p>找出非常隐蔽的被墙掉的地址</p>
<p>好了，既然学会了自定义PAC文件，那么，想必应该是配置完毕了吧？当然不是，你有没有遇到过这种情况，明明把指定网址加到PAC里面了，但是打开该网址还是非常缓慢，或者只能看到部分控件，而网页主体始终刷不出来？但是将代理模式切到全局模式，又能正常打开该网页。</p>
<p>这又是为何？</p>
<p>其实，虽然目标网址是走了代理，但是目标网址上的一些资源（可能是某些JavaScript、CSS文件），可能是储存在某些被墙掉的地方，但是又没有添加到PAC文件里，所以使用全局代理模式时能轻松打开，但是使用自动代理模式时却又显示不出来，那么，如何解决呢？</p>
<h4 id="使用日志来查找"><a href="#使用日志来查找" class="headerlink" title="使用日志来查找"></a>使用日志来查找</h4><p>从菜单里点击<code>显示日志...</code>，其实就是打开系统应用<code>控制台</code>，系统日志中所有以 <strong>ShadowsocksX</strong>: 开头的是Shadowsocks的日志，我们再右上角输入ShadowsocksX，即可只显示Shadowsocks的日志。我们在全局模式下，刷新一次在自动代理模式下打不开的网页，然后马上切到控制台查看Shadowsocks的日志，看看是否有遗漏没有添加到PAC文件的网址，如图中的<em>*</em>.cloudfront.net。<br><img src="http://images.insuncle.com/mweb/14813851228563.jpg" alt></p>
<p>我们在用户规则文件user-rule.txt添加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">! Put user rules line by line in this file.</span><br><span class="line">! See https://adblockplus.org/en/filter-cheatsheet</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">||cloudfront.net^</span><br></pre></td></tr></table></figure>
<p>并执行一遍从GFWList更新PAC文件，即可。</p>
<h4 id="使用浏览器来查找"><a href="#使用浏览器来查找" class="headerlink" title="使用浏览器来查找"></a>使用浏览器来查找</h4><p>当然，可以使用浏览器的开发者工具来查看目标网址所需的网络请求，然后将可以的地址加入到PAC文件即可。<br><img src="http://images.insuncle.com/mweb/14813852310687.jpg" alt></p>
<h4 id="ShadowSocks-的-Alfred-Workflow来添加规则"><a href="#ShadowSocks-的-Alfred-Workflow来添加规则" class="headerlink" title="ShadowSocks 的 Alfred Workflow来添加规则"></a>ShadowSocks 的 Alfred Workflow来添加规则</h4><p>如果你是 小帽子 Alfred 的用户，你可以直接使用我写的 <a href="https://github.com/echohn/shadowsocks-alfred-workflow/raw/master/shadowsocks.alfredworkflow" target="_blank" rel="noopener">ShadowSocks-Workflow</a>(点击下载)。在 Alfred 中执行 ssadd ，然后粘贴你准备加入 gfwlist 的 url，url 的域名就添加进 ShadowScoks 了。<br><img src="http://images.insuncle.com/mweb/14813861026193.jpg" alt></p>
<h2 id="浏览器代理插件"><a href="#浏览器代理插件" class="headerlink" title="浏览器代理插件"></a>浏览器代理插件</h2><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>Chrome 代理插件：Proxy SwitchyOmega</p>
<ol>
<li><p>如果你不想用全局 PAC 代理，想配合 SwitchySharp 等插件使用，可在菜单栏图标里点关闭 Shadowsocks。关闭后代理仍会运行在 127.0.0.1:1080 上，代理类型为 SOCKS v5。之所以不叫关闭 PAC，因为很多人不懂什么是 PAC。写关闭 Shadowsocks 更容易理解。</p>
</li>
<li><p>切换服务器后，因为 Chrome 保持长连接，可能需要重启浏览器才能生效。也可以重启 ShadowsocksX 来强制 Chrome 重新连接。</p>
</li>
</ol>
<h2 id="Shadowsocks的PAC模式与全局模式与VPN的区别"><a href="#Shadowsocks的PAC模式与全局模式与VPN的区别" class="headerlink" title="Shadowsocks的PAC模式与全局模式与VPN的区别"></a>Shadowsocks的PAC模式与全局模式与VPN的区别</h2><h3 id="VPN，即虚拟专用网络"><a href="#VPN，即虚拟专用网络" class="headerlink" title="VPN，即虚拟专用网络"></a>VPN，即虚拟专用网络</h3><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。</p>
<h4 id="Shadowsocks，即Sock5代理"><a href="#Shadowsocks，即Sock5代理" class="headerlink" title="Shadowsocks，即Sock5代理"></a>Shadowsocks，即Sock5代理</h4><p>采用socks协议的代理服务器就是SOCKS服务器，是一种通用的代理服务器。Socks是个电路级的底层网关，是DavidKoblas在1990年开发的，此后就一直作为Internet RFC标准的开放标准。Socks 不要求应用程序遵循特定的操作系统平台，Socks 代理与应用层代理、 HTTP 层代理不同，Socks 代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。所以，Socks代理比其他应用层代理要快得多。</p>
<p>VPN顾名思义，虚拟专网，你接入VPN就是接入了一个专有网络，那么你访问网络都是从这个专有网络的出口出去，好比你在家，你家路由器后面的网络设备是在同一个网络，而VPN则是让你的设备进入了另一个网络。同时你的IP地址也变成了由VPN分配的一个IP地址。通常是一个私网地址。你和VPN服务器之间的通信是否加密取决于连接VPN的具体方式/协议。</p>
<p>Sock5代理服务器则是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地。你没有加入任何新的网络，只是http/socks数据经过代理服务器的转发送出，并从代理服务器接收回应。你与代理服务器通信过程不会被额外处理，如果你用https，那本身就是加密的。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>VPN</strong>的开发目的是给企业内网直接传输加密数据，最重要的就是安全性，相反VPN的流量特征变得很明显，特别是SSL VPN类型，比如Openvpn有SSL证书的加密，安全性不必多说，但是握手依然是明文，流量更加明显，导致匹配流量特征很容易，在我这里一旦链接Openvpn那就是秒封。</p>
<p>VPN目前就科学上网方面来讲，PPTP大部分地区已死，L2TP大部分地区已经出现干扰和断开连接情况，Openvpn一封一个准。而anyconnect大多数都是企业用的，所以墙不敢乱封，IKEv1/IKEv2需要注意证书中间人攻击问题。</p>
<p>所以，在VPN科学上网这方面，一些地区已经根据VPN的流量特征做出了相应的匹配策略，可以有效封杀VPN了。</p>
<p><strong>Shadowsocks</strong>的开发目的就是穿透防火墙，最重要的是增加墙的匹配流量效率封杀成本和难度，也就是混淆隐秘性。</p>
<p><strong>Shadowsocks是更注重流量混淆隐秘，VPN则是更注重加密安全性。</strong>如果你需要安全你可能需要 VPN 或者 Shadowsocks+TOR匿名 ，否则就抗干扰能力来说Shadowsocks更适合拿来科学上网，VPN中的Opnevpn是最安全的VPN协议之一，然而第一个被墙宣布效率检测、封杀！</p>
<p>没有完美的工具，VPN和Shadowsocks在某种程度上可以说是两种相反的技术，开发目的不一样，注重点也不一样，缺点相应的也不一样，所以根据当地运营商的封杀策略选择最适合自己的方式。</p>
<h2 id="通过ProxyChains让Iterm终端上网"><a href="#通过ProxyChains让Iterm终端上网" class="headerlink" title="通过ProxyChains让Iterm终端上网"></a>通过ProxyChains让Iterm终端上网</h2><p>如我们之前所说的，浏览器科学上网只是一部分，身为一名工程师或非 Windows 用户，我们经常会使用到一些命令行工具，想让命令行工具科学上网肿么办？</p>
<p>ProxyChains 就是一个这样用途的工具，它可以让你的其它工具通过 Socks 或 HTTP 代理访问网络。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先从 Homebrew 安装 ProxyChains。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install proxychains-ng</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>编辑配置文件 <code>mvim /usr/local/etc/proxychains.conf</code><br>在 [ProxyList] 下面（也就是末尾）加入代理类型，代理地址和端口<br>例如使用 TOR 代理，注释掉原来的代理并添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">strict_chain</span><br><span class="line">proxy_dns</span><br><span class="line">remote_dns_subnet 224</span><br><span class="line">tcp_read_time_out 15000</span><br><span class="line">tcp_connect_time_out 8000</span><br><span class="line">localnet 127.0.0.0/255.0.0.0</span><br><span class="line">quiet_mode</span><br><span class="line">[ProxyList]</span><br><span class="line">socks5  127.0.0.1 1086</span><br></pre></td></tr></table></figure>
<p>需要说明一点，在这里我配置的是 strict_chain。如果你有多重代理，类似我之前一样，比如让命令先通过 Lantern 代理出去，如果失败再走 SS 代理，可以配置成 dynamic_chain 模式。不过这超出今天的文章范畴了，我还是以 strict_chain 举例，如果你对 dynamic_chain 感兴趣，可以自行研究。</p>
<p>每次使用 <code>proxychains4</code> 命令其实有些不爽，太长容易输错。<br>编辑 <code>~/.bash_profile</code> 文件，添加下面一行命令为 <code>proxychains4</code> 设置别名为 pc 或者你喜欢的任何命令。重启终端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias pc=&quot;proxychains4 -f ~/.proxychains.conf&quot;</span><br></pre></td></tr></table></figure>
<p>在执行 <code>source ~/.bash_profile</code> 重新加载环境变量之后，就可以尝试是否配置成功了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc curl https://twitter.com</span><br></pre></td></tr></table></figure>
<h2 id="为git-nodejs-gradle-maven等进行代理服务器的配置"><a href="#为git-nodejs-gradle-maven等进行代理服务器的配置" class="headerlink" title="为git,nodejs,gradle,maven等进行代理服务器的配置"></a>为git,nodejs,gradle,maven等进行代理服务器的配置</h2><p><a href="http://www.snowdream.tech/2016/03/31/proxy-settings-with-shadowsocks/#IDEA" target="_blank" rel="noopener">http://www.snowdream.tech/2016/03/31/proxy-settings-with-shadowsocks/#IDEA</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://echohn.github.io/2016/05/29/to-build-the-fullstack-tools-for-over-the-wall/" target="_blank" rel="noopener">打造基于 ShadowSocks + ProxyChains 的全栈式科学上网工具</a></li>
<li><a href="https://www.gitbook.com/book/lvii/outman/details" target="_blank" rel="noopener">科学上网漫游指南</a></li>
<li><a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-%E5%B8%AE%E5%8A%A9" target="_blank" rel="noopener">Shadowsocks for OSX 帮助</a></li>
<li><a href="https://www.dou-bi.co/ss-jc9/" target="_blank" rel="noopener">Shadowsocks（Sock5代理）的PAC模式与全局模式与VPN的区别</a></li>
<li><a href="http://celerysoft.github.io/2016-01-17.html" target="_blank" rel="noopener">Shadowsocks-GUI For Mac OS使用指南</a></li>
<li><a href="https://adblockplus.org/en/filter-cheatsheet" target="_blank" rel="noopener">用户自定义规则参考之Adblock Plus filters explained</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.haoweiguang.me/2017/05/08/MySQL中text、blob字段类型的不同/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/08/MySQL中text、blob字段类型的不同/" itemprop="url">
                  MySQL中text、blob字段类型的不同
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-08 14:50:46" itemprop="dateCreated datePublished" datetime="2017-05-08T14:50:46+08:00">2017-05-08</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/08/MySQL中text、blob字段类型的不同/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/05/08/MySQL中text、blob字段类型的不同/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在MySQL中有两个字段类型容易让人感觉混淆，那就是TEXT与BLOB，特别是自己写博客程序的博主不知道改为自己的博客正文字段选择TEXT还是BLOB类型。</p>
<p>下面给出几点区别：</p>
<h3 id="一、主要差别"><a href="#一、主要差别" class="headerlink" title="一、主要差别"></a>一、主要差别</h3><p>TEXT与BLOB的主要差别就是BLOB保存二进制数据，TEXT保存字符数据。目前几乎所有博客内容里的图片都不是以二进制存储在数据库的，而是把图片上传到服务器然后正文里使用<code>&lt;img&gt;</code>标签引用，这样的博客就可以使用TEXT类型。而BLOB就可以把图片换算成二进制保存到数据库中。</p>
<h3 id="二、类型区别"><a href="#二、类型区别" class="headerlink" title="二、类型区别"></a>二、类型区别</h3><p>BLOB有4种类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同<br>TEXT也有4种类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些类型同BLOB类型一样，有相同的最大长度和存储需求。</p>
<h3 id="三、字符集"><a href="#三、字符集" class="headerlink" title="三、字符集"></a>三、字符集</h3><p>BLOB列没有字符集，并且排序和比较基于列值字节的数值值。TEXT列有一个字符集，并且根据字符集的校对规则对值进行排序和比较</p>
<h3 id="四、大小写"><a href="#四、大小写" class="headerlink" title="四、大小写"></a>四、大小写</h3><p>在TEXT或BLOB列的存储或检索过程中，不存在大小写转换，都一样！</p>
<h3 id="五、严格模式"><a href="#五、严格模式" class="headerlink" title="五、严格模式"></a>五、严格模式</h3><p>运行在非严格模式时，如果你为BLOB或TEXT列分配一个超过该列类型的最大长度的值值，值被截取以保证适合。如果截掉的字符不是空格，将会产生一条警告。使用严格SQL模式，会产生错误，并且值将被拒绝而不是截取并给出警告。</p>
<h3 id="六、其它"><a href="#六、其它" class="headerlink" title="六、其它"></a>六、其它</h3><p>当保存或检索BLOB和TEXT列的值时不删除尾部空格。<br>对于BLOB和TEXT列的索引，必须指定索引前缀的长度。<br>BLOB和TEXT列不能有默认值。<br>当排序时只使用该列的前max_sort_length个字节。max_sort_length的 默认值是1024.<br>当你想要使超过max_sort_length的字节有意义，对含长值的BLOB或TEXT列使用GROUP BY或ORDER BY的另一种方式是将列值转换为固定长度的对象。标准方法是使用SUBSTRING函数。<br>BLOB或TEXT对象的最大大小由其类型确定，但在客户端和服务器之间实际可以传递的最大值由可用内存数量和通信缓存区大小确定。你可以通过更改max_allowed_packet变量的值更改消息缓存区的大小，但必须同时修改服务器和客户端程序。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/Muse/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/Muse/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/2578.jpg" alt="Light微光">
            
              <p class="site-author-name" itemprop="name">Light微光</p>
              <p class="site-description motion-element" itemprop="description">关于技术、产品、个人感悟等的记录</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/haoweiguang" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i></a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:haoweiguang1986#gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i></a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Light微光</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.1</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'FR41X5AqL4IcM2cE5qBmHU1Q-gzGzoHsz',
        appKey: 'iXWuS118CuMxx8GkdQl53Xry',
        placeholder: '说两句吧~~',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: false
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
