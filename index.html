<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="关于技术、产品、个人感悟等的记录">
<meta property="og:type" content="website">
<meta property="og:title" content="微光的Notes">
<meta property="og:url" content="http://haoweiguang.me/index.html">
<meta property="og:site_name" content="微光的Notes">
<meta property="og:description" content="关于技术、产品、个人感悟等的记录">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="微光的Notes">
<meta name="twitter:description" content="关于技术、产品、个人感悟等的记录">



  <link rel="alternate" href="/atom.xml" title="微光的Notes" type="application/atom+xml">




  <link rel="canonical" href="http://haoweiguang.me/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>微光的Notes</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-101937505-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-101937505-1');
</script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">微光的Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">梦想是要有的，万一实现了呢</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2019/10/18/Git分支策略-我的实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/18/Git分支策略-我的实践/" itemprop="url">
                  Git分支策略-我的实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-18 16:23:59" itemprop="dateCreated datePublished" datetime="2019-10-18T16:23:59+08:00">2019-10-18</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/利器/" itemprop="url" rel="index"><span itemprop="name">利器</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/18/Git分支策略-我的实践/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/10/18/Git分支策略-我的实践/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>具体策略还是要根据项目的大小和复杂度来定。遵循的原则是先简单，然后根据项目情况不断的精细化，不要上来就搞一个特别复杂的规则。</p>
<p>这样做的好处：</p>
<ul>
<li>简单，团队更容易接受、执行，更易操作</li>
<li>简单也更不容易出错</li>
</ul>
<p>如果是个全新的项目，我觉着保留一个主干master，和线上代码一致，仅用来发布新版本。不用非得维护一个develop分支，这样反而麻烦。在项目上线之前，规则都相对简单。但是等项目上线后，问题就慢慢复杂了。因为你分支策略还得考虑怎么保证master和线上一致。我们分多个场景来讲：</p>
<h3 id="场景1-我们要添加一个新功能"><a href="#场景1-我们要添加一个新功能" class="headerlink" title="场景1 我们要添加一个新功能"></a>场景1 我们要添加一个新功能</h3><h4 id="场景1-1-当前没有并行的功能"><a href="#场景1-1-当前没有并行的功能" class="headerlink" title="场景1.1 当前没有并行的功能"></a>场景1.1 当前没有并行的功能</h4><p>1.开发的时候先从master建一个功能分支，命名：Feature-xxx，后续在此基础上做开发就行了，视情况决定是否建个人分支（命名：Feature-xxx-light）</p>
<p>2.功能开发完成，准备提测，如果是按照瀑布模型开发，可以直接把Feature分支的代码部署到测试环境（QA），发现bug直接在此分支修改就行，然后部署到测试环境；如果是敏捷开发，那最好分出来一个测试分支，因为该功能分支还得继续开发，可能会包含未完成的功能，这时候如果拿功能分支部署测试环境，会遇到问题。如果开辟了一个测试分支，这样就把开发跟测试隔离了，测试环境的bug什么都可以在测试分支搞定。</p>
<p>3.（可选）  开发测试完成提交到pre-production</p>
<p>4.（可选）  进一步测试没有问题提交到release分支</p>
<p>5.后续就是上线，则合并到master分支，并在master分支上做发布</p>
<p>6.（可选）  如果需要延迟发布则新建production分支（比如，等待iOS审核，需遵守upstream first）</p>
<h4 id="场景1-2-有多个功能并行"><a href="#场景1-2-有多个功能并行" class="headerlink" title="场景1.2 有多个功能并行"></a>场景1.2 有多个功能并行</h4><p>可能有个极端情况就是两个团队需要开发同一个功能，我觉着这种情况在前期任务划分的时候就应该尽量避免掉，实在无法避免，可以让一个团队负责开发，并暴露接口供另一个团队调用</p>
<p>其实流程跟场景1.1差不多，就是从哪里新开分支，怎么合并会遇到些问题？</p>
<p>还是从master创建分支。合并的时候根据项目情况选择是合并到pre-production或release，反正最终要合并到master分支并做发布。</p>
<h3 id="场景2-发现了线上bug"><a href="#场景2-发现了线上bug" class="headerlink" title="场景2 发现了线上bug"></a>场景2 发现了线上bug</h3><p>最重要的是记得记得保存当前的代码，别一着急把当前的代码丢了，那真会欲哭无泪。<br>1.如果本地还在开发，记得先使用git stash暂存，以免切换到master后代码丢失</p>
<p>2.从master创建本地bug分支，命名：bugfix-xxx</p>
<p>3.修复bug</p>
<p>4.（可选）修改测试完成后依次同步到pre-produciton和release分支</p>
<p>5.各个环境的测试通过，合并到master，并在master上做发布</p>
<p>6.切换到自己的开发分支，使用git stash恢复暂存，继续工作</p>
<p>但这些也不够全面，想到哪写到哪，后续持续迭代吧。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2019/09/01/徐十胖公众号所得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/01/徐十胖公众号所得/" itemprop="url">
                  徐十胖公众号所得
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-01 00:21:14" itemprop="dateCreated datePublished" datetime="2019-09-01T00:21:14+08:00">2019-09-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/01/徐十胖公众号所得/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/09/01/徐十胖公众号所得/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近看了他的文章，感觉有所收获，就准备把他公众号有用的文章翻来看看，我把一些收获总结一下。</p>
<p>写作对我虽然难，更要多写，复盘，大力出奇迹</p>
<p><strong>执行力是基础，大力出奇迹，干干干</strong>。多次在不同文章提到执行力的重要性。为啥这样说呢，他的观点是在你很弱的时候，你的思考能力和执行能力必然都是很弱的。<strong>思考能力很弱，很多事情你是根本想不清楚的</strong>，因为一个是逻辑不过关，一个是因为见的不够多，做的不够多！就像一个经典的笑话：乞丐说，等我发财了，我就买个大房子，天天坐在门口要饭吃。</p>
<p><strong>专注</strong>，没钱的时候，做事一定要专注，<strong>把小事做好，然后做深，做大</strong>。多做试验，找到适合自己的方法，然后拼命跑马圈地。</p>
<p><strong>团队</strong>，想做事赚钱一定要有团队</p>
<p><strong>知道自己短处和长处，并总是想法突破自己</strong>，文章中提到“确实没有办法耐着性子研究技术”，后来转到产品岗位，发现自己特别喜欢，但是转到产品岗，也是吃了不少苦头，打击最大的一次是把美团几万人使用的系统给搞挂了，因此差点辞职。但是通过自己不断的学习和突破，坚持了下来，后边绩效也很好。</p>
<p>除了主业，还得多去尝试和试验，不断接触新人、新知识，提升认知</p>
<p>什么是牛逼？<strong>能够克服得了难的东西，持续的做下去，不断的思考，做深，做精。哪怕最后没有结果，与困难战斗的过程中越战越强，本身就是很爽的事情。</strong>【这个估计也是作者的目标】<br><strong>什么事都是有代价的</strong>，比我漂泊在外，就能换取自己的一份自由，想干嘛就干嘛</p>
<p>Reversion History<br>2019.9.1 第一次记录</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2019/08/29/我为什么写作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/29/我为什么写作/" itemprop="url">
                  我为什么写作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-29 13:55:18" itemprop="dateCreated datePublished" datetime="2019-08-29T13:55:18+08:00">2019-08-29</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/29/我为什么写作/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/08/29/我为什么写作/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>其实我对写作有很大的心里恐惧。还记刚上初中时，因为作文写不好彻夜难眠，也哭了无数次。有一次考试作文竟然只憋出来了6行，得了6分，至今难忘。但是我认为写作还是很有用处，所以也就硬着头皮写吧，以下说说我对写作的理解。</p>
<p>写作大概能分为两种，一种是为自己而写，主要想通过写作来更好的学习、思考、记录、复盘等；一种是为他人而写，通过写作扩大影响力、赚钱等等。我的目标是“<strong>为自己而写</strong>”。</p>
<p><strong>为了深度思考</strong>，把自己学的东西。通过写作，将自己的思考转换为文字后，很多实践经验和总结往往才能够真正的系统化和结构化，同时完成整个思维的抽象和升华过程。写作有时候像教人，能把一件事写明白了，证明自己掌握的也挺好的了。</p>
<p><strong>让自己慢下来</strong>，平时看的太多，太杂，除了通过写作来梳理，为了更好的吸收，其实<strong>写作是真正能够让人平静下来的事情</strong>，写作是在安静的时候，一个人，自己和自己的心灵的对话，让自己听到自己内心的声音。</p>
<p>也有一些<strong>交流的需要</strong>，我现在有个习惯，就是如果觉着一个人思想还不错，我就会去找他的博客、公众号等，把他写的文章看一遍，就能大概了解这个人了，减少了沟通的成本。</p>
<p>你们有没有觉着回忆是不准确的，我们经常修改和美化自己的记忆，以验证自己当下的判断（就像“禀赋效应”那样）。所以记录下来，回头再看，是对自己成长过程最好的交代。另外，记录当时状态对于人生也是一份宝贵的财富。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="noopener">为什么你应该（从现在开始就）-刘未鹏</a></li>
<li><a href="https://fatesinger.com/100080" target="_blank" rel="noopener">当我谈博客时我在谈些什么-Fatesinger</a></li>
<li><a href="https://yukunwu.wordpress.com/why-write-blogs/" target="_blank" rel="noopener">为何写作-zero</a></li>
</ul>
<h3 id="Revision-history"><a href="#Revision-history" class="headerlink" title="Revision history"></a>Revision history</h3><p>2019.8.29 开写</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2019/08/24/读《股票作手回忆录》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/24/读《股票作手回忆录》/" itemprop="url">
                  读《股票作手回忆录》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-24 22:21:46" itemprop="dateCreated datePublished" datetime="2019-08-24T22:21:46+08:00">2019-08-24</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/财富投资/" itemprop="url" rel="index"><span itemprop="name">财富投资</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/24/读《股票作手回忆录》/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/08/24/读《股票作手回忆录》/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="自己认为比较有收获的点"><a href="#自己认为比较有收获的点" class="headerlink" title="自己认为比较有收获的点"></a>自己认为比较有收获的点</h3><ul>
<li>坚持自己独立思考，必须对自己和自己的判断充满信心，不断跟市场学习，虽然这要付出金钱的代价，但是没有捷径，因为一个人从自己的错误中总结经验，需要经历漫长的过程。找到自己的优势、缺点，记录每次亏损或失误的原因，不断复盘来不断改进修炼，让某些操作成为潜意识</li>
<li>赚大钱不能靠股价的短期波动，而要靠大趋势，看对趋势，买进仓位后就持有不动，直到你觉得牛市将尽，抛出获利</li>
<li>用筹码去测试市场，市场永远是对的，识别最小阻力位是个艺术</li>
<li>止损，出错的时候必须认错，然后卖掉；止盈，牛市时广大股民一开始都能赚钱，可后来都因为流连于牛市不肯收手而亏损</li>
<li>不要受情绪的影响，亲情、感激之情、愧疚</li>
</ul>
<h3 id="一些摘抄"><a href="#一些摘抄" class="headerlink" title="一些摘抄"></a>一些摘抄</h3><blockquote>
<p>市场信号出现之前，不要操作。<br> 股价上涨时，不要问它为啥涨，持续买进自然会推动股价上涨。</p>
<p>只有真金白银才能证明自己观点的正确性<br>试错是股市永恒的主题</p>
<p>判断对错并不重要，重要的在于正确时获取多大利润，错误时亏损了多少<br>市场对我有利，就在自己财力范围内尽可能大规模交易</p>
<p>防止成为“股呆”，图标分析不是万能的，别成为查理芒格说的“拿着锤子，看谁都像钉子”的人，扩大专注面。<br>投资一定要理论结合实际，既要研究理论，也要善于在实际操作中变通</p>
<p>搞清楚自己的交易对手是谁</p>
<p>没有一个人能抓住所有起伏，不理会大波动，总是抢进抢出，这是投资大忌<br>不要尝试去抓住最初或最后的八分之一点利润</p>
<p>择时很重要啊<br>最重要的能力是能保证对买进卖出时机判断的正确率和在错误时及时止损的能力</p>
<p>牛市整体上扬才有机会挣大钱，走势要依赖整个经济环境<br>股票投机中，解读行情很重要，在正确的时间进场、坚持自己的立场也同样重要。更重要的是必须研究和评估经济形势，这样才能准确预测市场可能会往哪个方向发展</p>
<p>研究人性让你受益匪浅<br>人性的两大弱点~希望与恐惧<br>最致命的敌人来自自己的内心<br>最危险的敌人就是聪明的朋友的热切规劝和人格魅力<br>赌博的心态要不得</p>
<p>股票投机成功原则的基础是：人类会在将来犯过去犯过的相同的错误<br>股票投机永远不会消失，因为人性不希望它消失</p>
<p>操盘技巧<br>K线是个好的宣传工具<br>炒作的目的通常是激活市场，让自己能随时以某个价位抛出大宗股票<br>要让一只股票一路上涨，第一步是让它先涨起来<br>没人愿意做空这种股权不够分散的股票，因为你会完全受制于持股的内线集团</p>
<p>知道不该做什么和知道什么该做同样重要</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2019/04/22/程序员健康生活指南总目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/程序员健康生活指南总目录/" itemprop="url">
                  程序员健康生活指南总目录
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-22 15:07:16" itemprop="dateCreated datePublished" datetime="2019-04-22T15:07:16+08:00">2019-04-22</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/22/程序员健康生活指南总目录/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/04/22/程序员健康生活指南总目录/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>收录了《程序员健康生活指南》的中文翻译，给为码友可以关注下一。</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558473&amp;idx=1&amp;sn=d3008accd5067725f9c923dd5c527539&amp;chksm=83a72901b4d0a017350d800c10abb20ef6c72b89e36c89850b45f6edc107c6c202796dd352f5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(一) - 前言</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558485&amp;idx=1&amp;sn=e5fbd41db021ecb36fa1e3c1d4903ffd&amp;chksm=83a7291db4d0a00b5051bd5d7953aa997eb8f1e0144a62757348c28b89f4ea59577f9a1d9fad&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(二) - 做出改变</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558489&amp;idx=1&amp;sn=4dc8c675e3c29dd0557d7616c3f260d3&amp;chksm=83a72911b4d0a00760d165fd40ba37984fc83bb5d548ea8250b9b7116315a03530aaacd7fe7e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(三) - 努力健康起来吧</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558493&amp;idx=1&amp;sn=00f17f854a7d7d2e05ec6678d9020711&amp;chksm=83a72915b4d0a003f0b8e54d072db054d61eac9ca7e02627ce583878baa6adca5c3681473105&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(四)-永别了,椅子？</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558494&amp;idx=1&amp;sn=032ca87cd2af6a08dfbbcc80b5c18005&amp;chksm=83a72916b4d0a000ff11876eb349baf47311670a2a6c37a003f9398ed2ecd1a47e209857f55b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(五)-灵活的饮食方案</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558498&amp;idx=1&amp;sn=aa2ce31099b56d67eb0faf1a38ba6dd6&amp;chksm=83a7292ab4d0a03ce9ad519c0d596575b35e27785f5ad9650d265af418b45e7c70c30239e642&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(六) - 预防头痛和眼部疲劳</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558518&amp;idx=1&amp;sn=d4c26f0d5747aaf80cd6aa98df19bceb&amp;chksm=83a7293eb4d0a0286f08d3010e9de04932b0d3bd304bfffd1b17dc6702f0d7261d63100e8ba2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(七) - 预防背部疼痛</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558533&amp;idx=1&amp;sn=cc7e7473c219a3637b5d65473db1405f&amp;chksm=83a72acdb4d0a3db7a24567b4247125472ee96fe08a997da72897470adcbd104018cb8beb4c1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(八) - 预防手腕疼痛</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558536&amp;idx=1&amp;sn=d47d48123f0e7b4a4737ef1714f634ab&amp;chksm=83a72ac0b4d0a3d682546d4f42f255645f40c354a3942709839e5c064ab8b6e67d02fe436e8b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(九) - 让锻炼贴近生活</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558555&amp;idx=1&amp;sn=de859c13913f9b96248b060d270a6b46&amp;chksm=83a72ad3b4d0a3c5192627a06d186a82ab0602cf3f39d9cf36846e40a7fc40c367bc40956e2e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(十) - 到户外来思考</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558574&amp;idx=1&amp;sn=ef4cd191f657b0025bd40077e838b5cc&amp;chksm=83a72ae6b4d0a3f0310b9b7c589cd9a86b34d0ce1ba5eea638fd99ba1b207171944e7c86a989&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(十一) - 重构健康</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558577&amp;idx=1&amp;sn=a3d1733759058d21160902622eb9466b&amp;chksm=83a72af9b4d0a3ef1c37720ec6e810697fc51f3ea0cd864fe388064626b832063a7c3726b8fd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(十二) - 组起队来</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTYwNTQxNQ==&amp;mid=2649558580&amp;idx=1&amp;sn=12213b39e6f7c2c112a428411f5cae7b&amp;chksm=83a72afcb4d0a3ea9ba8d7ada82b4f99b46e18cbbac2dffb317c331cce78a8ce288e491923c5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">程序员健康生活指南(十三) - 继续行动吧，健康的程序员</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2019/03/04/Naval：如何不靠运气致富/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/04/Naval：如何不靠运气致富/" itemprop="url">
                  Naval：如何不靠运气致富
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-04 15:23:07" itemprop="dateCreated datePublished" datetime="2019-03-04T15:23:07+08:00">2019-03-04</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/财富投资/" itemprop="url" rel="index"><span itemprop="name">财富投资</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/04/Naval：如何不靠运气致富/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/Naval：如何不靠运气致富/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>How to Get Rich (without getting lucky)<br>如何变的富有，不需要任何的运气。</p>
<p>Seek wealth, not money or status. Wealth is having assets that earn while you sleep. Money is how we transfer time and wealth. Status is your place in the social hierarchy.<br>寻求财富，而不是金钱或身份。财富是指拥有产生睡后收入的资产。金钱是我们怎么调动时间和财富。身份是你在社会体系中的位置。</p>
<p>Understand that ethical wealth creation is possible. If you secretly despise wealth, it will elude you.<br>理解道德正确的创造财富是可能的。如果你秘密的鄙视财富，它会避开你。</p>
<p>Ignore people playing status games. They gain status by attacking people playing wealth creation games.<br>忽略那些做地位博弈的人。他们获得地位的方式是通过攻击做创造财富博弈的人。</p>
<p>You’re not going to get rich renting out your time. You must own equity - a piece of a business - to gain your financial freedom.<br>你不可能通过租赁你的时间变得富有，你需要拥有资产，一个生意的一部分，来获取你的财务自由。</p>
<p>You will get rich by giving society what it wants but does not yet know how to get. At scale.<br>你可以通过给于这个社会想要但还不知道如何得到的东西去变得富有。规模化的。</p>
<p>Pick an industry where you can play long term games with long term people.<br>选择一个行业，在这个行业里你可以和长期的人去玩长期的游戏。</p>
<p>The Internet has massively broadened the possible space of careers. Most people haven’t figured this out yet.<br>互联网极大的扩展了职业生涯的可能性，大部分人还没有意识到这件事。</p>
<p>Play iterated games. All the returns in life, whether in wealth, relationships, or knowledge, come from compound interest.<br>做重复博弈。一生中所有的回报，财富，关系，或者知识，都是来源于复利。</p>
<p>Pick business partners with high intelligence, energy, and, above all, integrity.<br>挑选商业合伙人的条件是，非常聪明，富有能量，最重要的是，正直。</p>
<p>Don’t partner with cynics and pessimists. Their beliefs are self-fulfilling.<br>不要和犬儒主义者和悲观主义者合伙。他们的信仰是自证（预言）。</p>
<p>Learn to sell. Learn to build. If you can do both, you will be unstoppable.<br>学习去销售事物，学习去建造事物。如若这两者都可以做，那么你将是不可阻挡的。</p>
<p>Arm yourself with specific knowledge, accountability, and leverage.<br>通过特种知识，负责，杠杆，来武装你自己。</p>
<p>Specific knowledge is knowledge that you cannot be trained for. If society can train you, it can train someone else, and replace you.<br>特种知识是无法通过培训获得的知识。如果社会可以培训你，那么也可以培训其他人，他们可以取代你。</p>
<p>Specific knowledge is found by pursuing your genuine curiosity and passion rather than whatever is hot right now.<br>特种知识是通过追寻你单纯的好奇与热情获得的，而不是去寻找当下什么地方最热。</p>
<p>Building specific knowledge will feel like play to you but will look like work to others.<br>建造特种知识的过程看上去是对他人的工作，实际上是对自己的索取。</p>
<p>When specific knowledge is taught, it’s through apprenticeships, not schools.<br>当特种知识被教授的时候，是通过学徒制的，而不是学校制的教育。</p>
<p>Specific knowledge is often highly technical or creative. It cannot be outsourced or automated.<br>特种知识通常有很高的技术性和创造性。它不能被外包或者自动化。</p>
<p>Embrace accountability, and take business risks under your own name. Society will reward you with responsibility, equity, and leverage.<br>拥抱负责，把商业风险放在自己的名下。社会将会奖赏你于责任，股份，杠杆。</p>
<p>The most accountable people have singular, public, and risky brands: Oprah, Trump, Kanye, Elon.<br>那些最负责的人拥有独一无二的，公开的，有风险的品牌。奥普拉，川普，坎耶，马斯克。</p>
<p>“Give me a lever long enough, and a place to stand, and I will move the earth.” - Archimedes<br>给我一个足够长的杠杆，和一个支点，我能够移动地球。- 阿基米德</p>
<p>Fortunes require leverage. Business leverage comes from capital, people, and products with no marginal cost of replication (code and media).<br>财富需要杠杆。商业杠杆来自于资本，人民，和那些没有边际复制成本的产品（媒体作品和程序）</p>
<p>Capital means money. To raise money, apply your specific knowledge, with accountability, and show resulting good judgment.<br>资本意味着金钱。想要募集金钱，应用你的特种知识，负责，并且展示发生的好的判断。</p>
<p>Labor means people working for you. It’s the oldest and most fought-over form of leverage. Labor leverage will impress your parents, but don’t waste your life chasing it.<br>人力意味人那些为你工作的人。这是最古老和斗争最激烈的杠杆形式。人力杠杆会给你的父母留下深刻印象，但是不要浪费一生去追逐它。</p>
<p>Capital and labor are permissioned leverage. Everyone is chasing capital, but someone has to give it to you. Everyone is trying to lead, but someone has to follow you.<br>资本和人力是需要许可的杠杠。每个人都在追逐资本，但是必须有人把它给你。每个人都想领头，但是必须有人跟随你。</p>
<p>Code and media are permissionless leverage. They’re the leverage behind the newly rich. You can create software and media that works for you while you sleep.<br>程序和媒体作品是无需许可的杠杠。它们是新富们背后的杠杆。你可创造出程序和媒体作品，（它们）在你睡觉时还为你工作。</p>
<p>An army of robots is freely available - it’s just packed in data centers for heat and space efficiency. Use it.<br>一只机器人军队可以被自由使用 - 只是为了散热和空间效率被打包放置在数据中心。使用它。</p>
<p>If you can’t code, write books and blogs, record videos and podcasts.<br>如果你不会编程，那就写书和写博客，录制视频和播客。</p>
<p>Leverage is a force multiplier for your judgement.<br>杠杆是你的判断的力量倍增器。</p>
<p>Judgement requires experience, but can be built faster by learning foundational skills.<br>判断需要经验，但是判断能力的构建可以通过学习基础技能的加速。</p>
<p>There is no skill called “business.” Avoid business magazines and business classes.<br>没有一种技能叫做商业。避免商业杂志和商业课程。</p>
<p>Study microeconomics, game theory, psychology, persuasion, ethics, mathematics, and computers.<br>学习微观经济学，博弈论，心理学，说服力，伦理学，数学，和计算机。</p>
<p>Reading is faster than listening. Doing is faster than watching.<br>阅读比听更快，做比看更快。</p>
<p>You should be too busy to “do coffee,” while still keeping an uncluttered calendar.<br>你应该保持日程的干净，但是应该足够忙碌而没时间去做很多会面。</p>
<p>Set and enforce an aspirational personal hourly rate. If fixing a problem will save less than your hourly rate, ignore it. If outsourcing a task will cost less than your hourly rate, outsource it.<br>给自己设置并执行一个有抱负的时薪。如果修复一个问题节省费用比时薪少，忽略它。如果外包任务比你的时薪便宜，外包它。</p>
<p>Work as hard as you can. Even though who you work with and what you work on are more important than how hard you work.<br>尽最大可能的努力工作。尽管和谁一起工作，在哪件事上工作比努力工作重要许多。</p>
<p>Become the best in the world at what you do. Keep redefining what you do until this is true.<br>在你所做的事情上成为世界上最好的。不停的重新定义你的工作直到成真。</p>
<p>There are no get rich quick schemes. That’s just someone else getting rich off you.<br>不会有快速致富的体系。只是有一些想从你身上发财的人。</p>
<p>Apply specific knowledge, with leverage, and eventually you will get what you deserve.<br>加杠杠应用特种知识，最终你会得到你想要的。</p>
<p>When you’re finally wealthy, you’ll realize that it wasn’t what you were seeking in the first place. But that’s for another day.<br>当你最终获取了财富，你会意识到这并不是你最开始想寻找的东西。但是这是日后再说的事情。</p>
<p>Summary: Productize Yourself.<br>最后，Naval提供了一句话的总结 —— “总结：把你自己产品化”。</p>
<p>原文：</p>
<ul>
<li><a href="https://twitter.com/naval/status/1002103360646823936" target="_blank" rel="noopener">https://twitter.com/naval/status/1002103360646823936</a>  </li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2018/10/16/产品经理应具备的能力（读张小龙有感）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/16/产品经理应具备的能力（读张小龙有感）/" itemprop="url">
                  产品经理应具备的能力（读张小龙有感）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-16 18:38:11" itemprop="dateCreated datePublished" datetime="2018-10-16T18:38:11+08:00">2018-10-16</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/产品设计/" itemprop="url" rel="index"><span itemprop="name">产品设计</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/16/产品经理应具备的能力（读张小龙有感）/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/16/产品经理应具备的能力（读张小龙有感）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在读有关张小龙的材料，觉着最真实、最有价值的还数龙哥在还未封神之前饭否的言论啦。花了好几天，断断续续的读完，泪流满面啊，龙哥牛逼，研究产品都搞到哲学、人性层面了，但感觉自己能吸收的东西了了。那就先写下自己当前的想法，另记下认为比较经典的话，以后可以常来翻一翻，常看常新吧。</p>
<blockquote>
<p>产品人是站在上帝身边的人</p>
</blockquote>
<p>产品经理看到这句，心里肯定会乐开了花，但权利越大，责任越大啊。龙哥为啥这样说呢，一是来奉承产品经理，二是产品经理确实是洞悉人性，满足用户欲望，设计规则，并让产品和人群按照规则演化的主，想想是不是有点像上帝。</p>
<blockquote>
<p>所以我后来发现,人不是培养出来的,是给他们土壤,然后,有才能的人自己会成长起来的。甚至不需要我分享什么。后来我就不培养人了,只观察人了。 </p>
</blockquote>
<p>优秀的人，有了土壤，自己就会长起来，其他职业也是。</p>
<blockquote>
<p> 如果工作不是被好奇心驱动,不如回家卖红薯。</p>
<p> 做产品,最要紧是保持十年如一日的新鲜感。</p>
<p>好奇心和发现是最值得珍惜的品德。</p>
</blockquote>
<p>好奇心很重要，这是人最原始的东西，也最能持久。</p>
<blockquote>
<p> 以后招产品经理,直接给他一个小电器,比如mp3播放器,让他写个产品使用手册,就知道行不行了。</p>
<p> 要提防那些Blog写得好的产品经理,因为在Blog上花的时间越多,在产品上花的时间就越少。原来还以为有例外,现在看起来无一例外。</p>
</blockquote>
<p>咳咳，Fenng老师，你怎么看？</p>
<blockquote>
<p> 做产品,就是跟用户谈一场恋爱,否则只是一场商业交易而已。产品人是多么的博爱啊。</p>
<p> 面试产品经理,所有技能合格后,要问,你喜欢摇滚吗。回答否的,就算了。</p>
<p> 我在生活上不是一个有洁癖的人,但对待产品却分毫必究,介大概就是传说中的精神分裂吧。</p>
<p> 很多人看到MJ的海报说pm心中有爱。不是爱,是愤怒。</p>
</blockquote>
<p>产品不应该仅仅是功能（需求）的堆砌，应该还要有“温度”，可能包含了产品经理的价值观、爱、愤怒或者其他，那样才有灵魂。</p>
<blockquote>
<p> 老乔是Intel的葛洛夫的唯有偏执狂才能生存的证明人。 偏执需要权力的辅佐才能进行到底。</p>
</blockquote>
<p>我还是想活的久一点，当个普通人也未尝不可吧。就像龙哥说的“ think less,live more（想得少，活得更久）”。</p>
<blockquote>
<p>要知道用户的心理，并且知道用一个什么样的规则去引导他。为什么这么说呢？规则是很简单的，只有简单的规则才可以演化出一个非常复杂的事件出来。所以我经常很不认同说，在很多做产品里面，一开始就做一个复杂的规则出来，最后没有任何演化的空间。……像Twitter之类的产品都非常简单，……，但是这样的东西是最有生命力的。</p>
<p>我们要做的工作是在群体里面做一个加速器、催化剂，是做这一类的工作，而不是把这一块钉死了之后，用户进来以后，只能怎么样，一步一步的走。</p>
</blockquote>
<p>设计出简单规则的能力</p>
<blockquote>
<p>让用户保持饥饿，让他们保持愚蠢。…….对我们的用户来说，我们是要想办法让他们知道他们的饥渴在哪里。</p>
<p>我们要满足他们的贪嗔痴。贪是贪婪，嗔是嫉妒，痴是执着。</p>
<p>那我们要洞察这一点，是因为我们的产品对用户产生黏性，就是让用户对你的产品产生贪，产生嗔，产生痴。</p>
<p>我们给大家各种钻，钻体现了什么心理？其实都体现了人性的这几个弱点，各种黄钻、绿钻，他会贪，他要升级；他会嗔，他会跟人比较，说你的钻比我的等级高，所以我也要升上去；他会痴，觉得我一定要把所有的钻给收齐。……就像苹果的手机，它同样的会对用户产生这样的吸引力……这是人性本身的一个共同的弱点</p>
<p>所以当我们在做一个产品的时候，我们在研究人性，而不是说在研究一个产品的逻辑。</p>
<p>所有的产品都需要有人性的研究。……..你可以对每一个好的产品都提出来问题，那么它背后肯定都是从人性的角度来说的，而不是从别的理由来说的。</p>
</blockquote>
<p>深刻的理解人性</p>
<blockquote>
<p>我们做产品要找到用户心理诉求的本质。……用户上微博干什么？<strong>用户上微博的原因是为了炫耀，是因为害怕孤独，不是利群而离群，是用它有追感。</strong>……<strong>实际上微博是一个构筑另一个自我的地方，构筑一个自我。</strong>…….一个内心强大的人是不需要写微博的。</p>
<p>功能是做需求，定位是做一种心理诉求，也就是说定位是更底层的一些心理供给。</p>
<p>让他<strong>获得安慰感、排除孤独感，让他获得成就感，让他在里面更加的自信</strong>，让他在里面像一个敌人一样的，要做到这些诉求。</p>
</blockquote>
<p>善于抓住用户心理诉求的本质，挖掘到底层的需求</p>
<blockquote>
<p>我们引用老乔的一句话，产品是技术和艺术的结合，或者产品是技术和人文的结合…..但是你怎么样在你的产品里面去包含这种人文或者艺术的成分？这是挺不容易的。</p>
<p>对于一个产品经理来说，需要提高自身修养的一个方向，在技术之外的人文方面有一些自己的认识</p>
<p>其实产品是可以表达产品经理自己情感的地方，如果大家用得好的话。……所以你看如果你把你个人的情感包含到产品里面，是一件很爽的事情。</p>
</blockquote>
<p>除了技术之外也需要提升自己的人文修养</p>
<blockquote>
<p><strong>所以有的时候，我们的产品经理经常是在做坏事，不是做好事，因为他拼命的引入新的功能进来，后面反正又不用自己写代码就不管，然后就把开发的累死了。</strong>……因为我们要冒出一个想法来，太容易了；但是我们要知道这个东西是一个正确的想法，就太难了。</p>
</blockquote>
<p>控制需求的能力</p>
<blockquote>
<p>其实研究客户心理就是研究自我，很多时候我们是瞄准自我的需求来做产品的。……当我们研究不到用户需求时，我们就会说只要让我们自己用得爽…..怎么样让用户用得爽呢？……一个比较简单的方法，把自己当作一个傻瓜来用产品，傻瓜心态。……他没有这么多的背景，他们用这个东西只是第一眼的感觉或者用一次，一、两分钟的体验就决定了。</p>
</blockquote>
<p>把自己当傻瓜用产品，傻瓜心态，一秒变傻瓜的能力</p>
<blockquote>
<p>使他（用户）感受趋势才是最重要的，因为用户只能够对过去的事情产生认知，未来的东西才是趋势，你怎么<strong>知道下一阶段会流行什么样的潮流，那才是最重要的</strong>。我们怎么去了解这个趋势是什么？有很多方法，很多人去分析数据【分析数据也有弊端，举了修理飞机的例子】</p>
<p>感知趋势是来自于我们的各种渠道，包括生活中的各种渠道，或者微博上的各种渠道。我自己的个人喜好我会看一些论坛或者微博这样的东西，去看这些离我很远的用户，他们在什么样的氛围、什么样的场景里面去用我们的产品。</p>
<p>坚持一个习惯，以前提过1000、100、10这样的习惯，就是说每周要去看1000个帖子，不管是微博的，还是哪里的。要看100天博客，要做10个CE这样子的。</p>
<p>之前就有一句话说web已经死掉了，大概从移动互联网的发展趋势来说，确实是有这个趋势。…..因为PC的不增长和手机的快速增长，这个对比实在是太强烈了。……而手机端的话，浏览器可能不是一个主要的入口，可能APP才是。</p>
<p>而且APP的趋势，不是要做一个大而全的APP，而是说做成尽可能小的APP。为什么不是大而全的呢？因为用户很懒，我要看天气，我就点天气的APP。我要看股票，就点股票的APP。我不会跑到腾讯所有服务的APP里面去，然后钻到里面去找天气、找股票。</p>
</blockquote>
<p>感知趋势的能力</p>
<blockquote>
<p>用户要什么我们就给什么，这个在很高层的用户里面甚至也会出现这个问题。比如说你的上级可能会给你说，你看用户给你提出这个需求了，你为什么不做？……为什么不做？因为我们觉得不能用户要什么就给他什么，要变个花样给他，用户要的不一定是对的。…..所以这种需求挺多的，但是我想表达的是如果我们针对需求一个人去满足，你可能获取了这部分用户，但是得罪了另外一部分用户。</p>
</blockquote>
<p>把控需求的能力，不要人云亦云，要有自己的思考</p>
<blockquote>
<p>但产品也是，一个产品里面很简单的一个产品可能也包含了上百个功能在里面，这些功能你可以像写代码一样的，你可以按一个线性的方式把它串起来，但是也可以做成一个很有架构在里面的东西。…….我们心中一定要有一个产品的架构在这里，而不是说我们这个产品就是一大堆功能的集合，只是一个无序的集合那样就很糟糕了。</p>
</blockquote>
<p>产品架构的能力，产品不仅仅是功能的堆砌</p>
<blockquote>
<p>一个产品技能的心态，这也是我感触比较深的，就是跟人讨论问题的时候会争论起来。<strong>对产品性能来说我觉得它是抱着一种求知的态度来讨论</strong>，而不是争论谁赢了谁输了这样一个观点。如果是这种求知的话，当别人说服了你，辩赢了你，那你很高兴，因为你接触到了新的知识。应该是说很鼓励这种辩驳，但不是为了自尊心而战。</p>
</blockquote>
<p>抱着求知的心态看待和讨论产品</p>
<blockquote>
<p>作为产品经理来说，一方面是自身要保持饥渴，保持一个觉得自己很无知的状态。</p>
<p>最后说的就是——我所说的都是错的。</p>
</blockquote>
<p>总结一下</p>
<ol>
<li><p>拥有好奇心，洞悉人性，善于抓住用户心理诉求的本质，挖掘到底层的需求</p>
</li>
<li><p>基于用户体验的产品思路，打造有“温度”、有“骨架”、有“灵魂”（PM的爱恨情仇）产品的能力</p>
</li>
<li><p>感知趋势的能力</p>
</li>
<li><p>设计出简单规则的能力</p>
</li>
<li><p>变傻瓜用户的能力</p>
</li>
</ol>
<p>   怎么具备以上能力呢，除了技术之外也需要提升自己的人文修养。多看书，多做产品。</p>
<p>产品不应该是冰冷的工具，乔老爷子如是说：“产品是技术和艺术的结合，或者产品是技术和人文的结合”。</p>
<h3 id="Revision-history"><a href="#Revision-history" class="headerlink" title="Revision history"></a>Revision history</h3><p>2019.10.26 读张小龙2012产品公开课总结<br>2019.10.16 读张小龙饭否后的总结</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2018/10/16/张小龙饭否摘抄/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/16/张小龙饭否摘抄/" itemprop="url">
                  张小龙饭否摘抄
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-16 14:11:52" itemprop="dateCreated datePublished" datetime="2018-10-16T14:11:52+08:00">2018-10-16</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/产品设计/" itemprop="url" rel="index"><span itemprop="name">产品设计</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/16/张小龙饭否摘抄/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/10/16/张小龙饭否摘抄/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>网络&amp;群体</strong></p>
<p>你的价值在于一个集体对你的认证,这是很多人具备的意识。然后这个意识再被sns网站利用,又增强了这个意识。 </p>
<p>物种多样性:一个物种并没有进化为全能生物,相反,只加强它独具的一个功能才能让它生存。 </p>
<p>动物会向中心聚集,处在边缘的动物会有被天敌吃掉的危险。成千上万人在一个时间段看和谈论一部最新的电影,也是同样的心理:不看的人会地处文化的边缘,隐性地影响交配权。 </p>
<p>将来每个人需要两个微博,一个是社交型微博,一个是自我表达型微博。 </p>
<p>社交网络,并不是好友越多越好。 </p>
<p>sns上,一下子给我100个好友,怎能给我一个一个去发现和找到好友的乐趣呢。 </p>
<p>社会是所大学,选修表演专业者众。 </p>
<p>陌生人组成的社区,虽然冰冷,但是去掉了熟人社区的温情和虚伪,多了规则。 </p>
<p>评论的意义:一个人如果自顾自写东西会写到离谱,评论相当于自动控制系统的负反馈,让人从偏激中收缩,趋于稳定。最终一个社区的个体互相影响,形成一个稳定的中庸的气场。 </p>
<p>人分熟人,半熟的人,陌生人。沟通方式有广播,群展示,群聊,单聊。排列组合是满足不到人们的需求的,因为基因的选择策略不是这么机械。重要的是,让人不自觉地掉进圈套,而不是让他建立圈子。 </p>
<p><strong>人性</strong></p>
<p>用手指同步自己的话到各个微博,原来是基于一种自我肯定和自我赞赏的快感,在paste的时候有机会欣赏到作品的复制和传播,这种快感源自基因的“复制和传播是第一目的”。任何自动同步工具都是扼杀这种快感的,因此会被基因排斥,这种同步产品注定失败。 </p>
<p>往往能够获胜的,不是真善美,而是贪嗔痴。因为后者更给力。 </p>
<p>你说的每一句话都是炫耀。因为,当你想说一句话的时候,你的意识里其实有1亿个念头在动,它们像精子一样争先恐后,最终,最炫的那个念头胜利了,成为了那句话,成为了冠军,获得了从你口里说出来的权力。 </p>
<p>方向盘是手的延伸,油门刹车是脚的延伸。汽车并不单是个运输工具, 而更像人工肢体。开车和坐车是不同的。对驾驶者来说,汽车是有生命的。 </p>
<p>手机是人的最重要的人工器官。 </p>
<p>手机是人的躯体的延伸,手机发博才是躯体对世界的回应,越来越感觉如此。 </p>
<p>人们等待一个平板电脑的发布,因为那是他们的第三支手第三只眼,所以,重量和分辨率是头等重要的。 </p>
<p>这么多年了,我还在做通讯工具,这让我相信一个宿命,每一个不善沟通的孩子都有强大的帮助别人沟通的内在力量。 </p>
<p>做自己的人又分两种,一种不断打破自己,一种沉溺于自己。 </p>
<p>人会集中注意力做一件事情,因为这样可以避免胡思乱想。这是一种基于生存本能的自我保护动作。 </p>
<p>人只是基因操作的一台机器,绝大部分的生存和选择策略,已经被写在基因的程序库里。人只是不自觉地听从这些基因制定的策略的指挥,却以为是自己的头脑做的选择。少数人可以挣脱并产生自己的选择策略 </p>
<p>基本人性需求,不应该压抑。谢安听说打破苻坚的军团之后,强行忍住了得瑟的冲动,结果把自己木屐的齿都折断了。谢安是宰相,折木屐。普通人的话,恐怕太压抑会折JJ的说。 </p>
<p>好战是人的天性,所以任何一个团队或者产品都要树立一个敌人来提振精神,哪怕没有敌人都要找一个假想敌。 </p>
<p>人就是环境。人就像变色龙,进入到环境就会去适应,最终成为那个环境的一部分。比如在微博上,环境就是听众,发表的言论自然就是适合粉丝听的言论。环境就是个天然的过滤器。 </p>
<p><strong>产品</strong></p>
<p>还是你们用户爽,哪里爽到哪里,苦的是做互联网的,要整天分析你们的阴暗心理好让你们更爽,还不能明说。 </p>
<p>一个产品,要加多少的功能,才能成为一个垃圾产品啊! </p>
<p>产品往往是做着做着,就主旋律了,因为跟着用户走,用户爱听主旋律的歌。 </p>
<p>虽然人人都说简单是美,但没有几个人真正喜欢简单的。看看这个越来越复杂的世界就知道了。 </p>
<p>产品就象一个生物,有它自然的进化之道。最重要的,是制定好产品的内在基因的“竞争策略”,让竞争策略在进化中再自行演化为具体的表现形态。如何搞?没想清楚。 </p>
<p>异议就象基因的突变,有突变才能滋生出更强的新一代基因。 </p>
<p>基因并不会思考,它们只是漫无目的的胡乱产生变异,有些碰巧更有利于生存,就存活下来了。 </p>
<p>如果说产品做的一切都在满足用户的虚荣,热闹,逃避,贪恋等,那么,大众同样都有受虐的心理,为什么不做一款产品去虐待他们? </p>
<p>平均每天收到一张iTunes Store的帐单。我要在apple上疯狂消费,来赎回以前在windows上狂用盗版的罪。【张小龙在app store体验了很多应用】 </p>
<p>twitter的创始人起先无所事事,就去钓鱼,看到鱼儿成群结队的拥挤,生怕掉队,于是得到启发,便开发了twitter,方便人们成群结队。 </p>
<p>网络尚未普及的时候,产品必须依靠功能多来取胜,并且产品是自成一体的。网络普及后,才催生出一种新的产品形态:产品极简,反而有利于在网络这个大生命体中自我繁衍,并且产品是面向连接的。</p>
<p>好的网络产品,必然是无法预料其会不会成功的。成功的产品,刚好是“碰巧”成功了。但这个碰巧并不是创造者的运气,而是,这个产品刚好能在网络生命体中生存和繁殖。就像我们无法知道一个小孩为什么成长如此迅速一样,我们无法知道一个网络产品为什么会成功,即使做的人,也应该感谢主。 </p>
<p>如果说一个细菌能够自然粘上另一个细菌是细菌的“意识”,一个极简的产品元素的能够连通另一个用户的接口,就是一种连接“意识”。那么这个接口就是有“意识”的。接口是主人,人是接口要使用的对象。 </p>
<p>一个被人预见必然会成功的产品,必然会是个失败的产品。成功的产品是不能预见的。至少,是不能被人所预见的。机器来预见还有可能。 </p>
<p>因为我们无从知道复杂生命体的运作规律。 </p>
<p>缘起,性空。 </p>
<p>互联网产品应该是由用户推动，而不是产品经理来推动。产品经理的作 用只是找到四两拨千斤的地方稍微用点力。 </p>
<p>流通正在取代内容本身,内容变得更小更方便传播。mp3取代唱片,微博取代书本,短信取代信件。我怀疑有一天,微小的内容也没有了,大家直接通过网络交换荷尔蒙。 </p>
<p>和“敌人比我们自己更了解我们”相对应的是,用户比我们自己更了解我们的产品。产品是有人用才成为有灵魂的产品,图纸和代码堆出来的只是躯壳。 </p>
<p>你问我们和竞争对手比有什么区别,我说我们没有他们那些臃肿艳俗的部分。 </p>
<p>FaWave这类工具,汇集了多个产品的数据和功能,看似提高效率,但人毕竟不只是效率工具,汇集类工具脱离了原产品的气息后,就丢失了对产品的情感认同。 </p>
<p>心有千千结,每种结都是一个产品。关系千万重,每种关系都是一个产品。未来世界,应该是每个人都会做一个十个用户的产品的时代。 </p>
<p>网站的发展趋势是,内容有标题的都不行了,没有标题的才兴起,如twitter,facebook。我现在好奇的是,quora的是有标题,还是没标题? </p>
<p>哥做的不是产品,哥做的是发挥潜力的自由。 </p>
<p>IM是没有前景的,因为破坏了“让人更轻松互连”的定律。IM可能需要尽快将双向关系转换到单向关注体系中。 </p>
<p>用户的忍耐力太强了,最后就不辩美丑了 </p>
<p>美女们是否爱用,是产品能否流行起来的风向标。特别是天上人间的。 </p>
<p>一晚上没睡着,想明白了一件事:单对单聊天是通讯工具,多人聊天是社区。 </p>
<p>手机开发,对体验的要求更高了,一寸短,一寸险。 </p>
<p>以后招产品经理,直接给他一个小电器,比如mp3播放器,让他写个产品使用手册,就知道行不行了。 </p>
<p>程序员当然不知道产品的走向,但产品人员就知道吗?也不知道。不同的是,程序员会盲目创造出100个尝试后,总有一个胜出并生存下来。生存的这个就是走向。 </p>
<p>facebook为什么在国外这么火?因为他们的生活是在是太单调了。 </p>
<p>产品总是会包含功能之外的价值观的。因此不能指望天朝设计的产品能被世界认同。 </p>
<p>哥喜欢的不是产品,是战争。 </p>
<p>互联网产品,好友是如何来的?必须是用户自己手把手拉来的。任何的批量好友导入,都是收效不大的。 </p>
<p>原来产品的气质,无非是说做产品要带些文艺。 </p>
<p>互联网的最终目的,是让关系学见鬼去。 </p>
<p>产品人是站在上帝身边的人 </p>
<p>think less,live more </p>
<p>信息越透明,整合的作用就越小。不在单点突破,而希望依靠整合来成事,是老套路了。所以N合一的东西一般很垃圾。网络的使命,包含了取缔整合。整合是系统来自然演绎的,不应该是人干的事。 </p>
<p>做产品,最要紧是保持十年如一日的新鲜感。 </p>
<p>怎么能跟战略部的人谈产品呢,他们面对的是评论家,我们面对用户。 </p>
<p>周国平说,即使产品是个悲剧,我们也要做得有滋有味。即使用户都是傻逼,我们也要帮他们装得有声有色。 </p>
<p>深夜,突然悟到Jobs说的“Stay hungry , stay foolish”,原来本意是对用户说的,“让你们保持饥渴,让你们保持愚蠢”。 </p>
<p>要提防那些Blog写得好的产品经理,因为在Blog上花的时间越多,在产品上花的时间就越少。原来还以为有例外,现在看起来无一例外。 </p>
<p>告诉大家一个秘密,苹果为什么崇尚白色?崇尚一个按钮的设计?因为他们的首席设计师乔纳森之前搞工业设计是浴室用品领域。想想马桶吧。 </p>
<p>互联网的产品,哪怕任何一个非常小的产品,其实都想一场战争,一场瓜分资源的战争。用户就是待瓜分的资源。 </p>
<p>做产品,就是跟用户谈一场恋爱,否则只是一场商业交易而已。产品人是多么的博爱啊。 </p>
<p>面试产品经理,所有技能合格后,要问,你喜欢摇滚吗。回答否的,就算了。 </p>
<p>我在生活上不是一个有洁癖的人,但对待产品却分毫必究,介大概就是传说中的精神分裂吧。 </p>
<p>很多人看到MJ的海报说pm心中有爱。不是爱,是愤怒。 </p>
<p>从前的理论是,市场营销是炮弹,打炮才能带动销量。现在的情况是, 产品本身是炮弹,只要爆炸力强就能炸晕一片用户。 </p>
<p>Instapaper本来就是小众,走收费路线可以理解。whatsapp那才叫牛逼,大众软件依然收费。【小众软件可以收费】 </p>
<p>如果社会进步到没有商人了,生产的人直接赚钱,该是种进步吧。appstore所以好。 </p>
<p><strong>用户体验</strong></p>
<p>原研哉:设计是为了让人在高速的现代生活节奏中更轻松,而非更紧张。 </p>
<p>原研哉:古人需要复杂的物品装饰图案和式样来吓唬敌人和统治民众, 现代人不再需要装饰有这类作用,因此流行简约设计。我感觉我生活在古代,因为我也不能完全接受简约。 </p>
<p>检验你是否真的接受简约的方法是,把家里装修成现代简约风,如果你住上几个月没疯,就通过了。 </p>
<p>我们遵循一个很古老的设计原则:UI人员禁止使用同类产品,但PM必须博采众长,PM将需求转述给UI去设计。这样避免UI进入思维定势 </p>
<p>多任务,在windows上是alt tab,在iphone上是双击马桶按钮,在macO S上是四个指头往下一撸。原始的就是人性的。 </p>
<p>需要说明书的产品不是好产品。需要弹tip告知用户如何使用的功能不是好功能。 </p>
<p>每天都有很多产品发布或升级,介绍都是罗列功能指标。用户又不是按功能来付费的,你列那么多新功能去完成kpi没有问题,去糊弄用户就不对了。 </p>
<p>我不喜欢的UI例子:弹tip;半透明遮盖;页面上来一块固定toolbar;令人不解的数字;etc </p>
<p><strong>创新</strong></p>
<p>问:深泽直人,为什么无印良品要创新呢?答:战后日本刚开始也都是模仿,因为模仿就可以在市场立足了。但是后来用户逐渐不买模仿的帐了,自然,企业必须要创新才能生存了。所以,创新是用户逼的。 </p>
<p>关于创新：1,创新是无稽之谈。创新不是决定取舍的理由。创新一般都是空想。创新是靠不住的,死得很快的。2,要的,是把握用户心理。其结果,才被观察为创新。3,创新是件碰运气的事,你只是蝴蝶,剩下的交给云。ppt over。 </p>
<p>指望中国人比西方更创新,是不太靠谱的。创新是基于用户环境的,比如我们都还没有普及智能手机,自然不会催生出一个智能手机普及环境下的创新应用。 </p>
<p>大部分的所谓创新,都是把问题搞复杂化而已。 </p>
<p><strong>思维</strong></p>
<p>程序设计最近20年的发展,是引入了更“自然”的思维方法:万事万物有其“基本类型”,高级类型是从基本类型派生出来的,并呈多态性,高级的个体是高级类型的实例,个体之间是通过消息来通讯的。这就是C++的全貌,虽然很多C++程序员对此理解不深。我想说的是,这也是PM分析问题的法宝。 </p>
<p>思维习惯和思维方法,其实是可以训练出来的。那么,为什么大学没有做产品这门课呢? </p>
<p>词语只是金属表面散射出来的一点点光,虽然能汇集成为耀眼变换的光,却还只是变换的光。 </p>
<p>《黑天鹅》里总结得太好了:人有天生的归纳能力来将复杂事物模型化。但这也导致人的认知误区,没有见过黑天鹅就认为天鹅都是白的。 </p>
<p>《黑天鹅》让我知道我是如何被我的经验和直觉所愚弄了。 </p>
<p>成功是个概率事件,这些传记可以当故事看,但不能当推理看。 </p>
<p>勤奋只是一种长年形成的癖好。 </p>
<p>程序语言和自然语言一样,都是对想法的整理和表达。因此我现在面试程序员,不让他写程序做题了,改为聊天。 </p>
<p>无欲则刚,一欲则强,多欲则乱</p>
<p>Think Different!我经常用这句话来提醒自己,我没有乔老爷的才,一定不能因为要think different而走火入魔。 </p>
<p>好奇心和发现是最值得珍惜的品德。 </p>
<p><strong>其他一些思考</strong></p>
<p>这两年,我博览了群书和群山,路过了死亡之谷和罪恶之源,现在终于可以坐下来喘口粗气了。 </p>
<p>少用电脑多看书,多看电影少上网 </p>
<p>你看到一本说出你心里话的经验之谈的书,然后会很痛苦,因为这类书是于人无益的:能明白的,不看此书也自然会明白。不明白的,看了此书也不会有改变。 </p>
<p>所以我后来发现,人不是培养出来的,是给他们土壤,然后,有才能的人自己会成长起来的。甚至不需要我分享什么。后来我就不培养人了,只观察人了。 </p>
<p>一个热衷于打勾的国度。源自对盖印的崇拜。盖印又源自宝塔葱白。 </p>
<p>古时候,男人出去打猎,是没有计划的,遇到什么打什么,也可能空手而回。今天的男人每天规定必须要打几只狼回来,就焦虑了。 </p>
<p>原来光有好的想法没用,还要有渠道才能传播出去。问题是,渠道反过来又会选择性传播和放大不该传播的。 </p>
<p>想法如同基因,有生存价值的想法最终会取得传播的胜利。这是《自私的基因》里关于文化基因的观点。 </p>
<p>整天将KPI挂在嘴上,以KPI为目标来工作的leader,都是不合格的,庸俗的,没有想法的,令人痛苦的,无法言语的。 </p>
<p>转:“人们往往出于责任做慈善,但事实是,做慈善有益于自己的身心, 有助于自己了解生活。我从难民身上学到了最多东西,比如如何当母亲、做一个坚强的人并生存下去,所以我只是希望能回报一些东西。”– 安吉丽娜朱莉 </p>
<p>我们总说每个人都是独一无二的,但同时又要求每个人都有一样的能力,因为不能提供给每个人独一无二的职业。 </p>
<p>人多了做事情就痛苦。哥的理想是,以后一个人弄一个很大面积的办公室,养花种草写程序,一个人做,爱怎么搞怎么搞。 </p>
<p>马太效应揭示出,不光是人会往人多的地方走,就连金钱都是这样。 </p>
<p>太初,人太自由了,于是,要有约束,便有了节日。大大小小的节日。 </p>
<p>如果工作不是被好奇心驱动,不如回家卖红薯。 </p>
<p>在一个平庸的人群里,需要有人独断专行 </p>
<p>转:人生的成长过程之中,要是不彻底的绝望一次,就不知道自己身上什么东西,决不可放弃,也就不知道什么是真正的快乐。——吉本芭娜娜《厨房》 </p>
<p>如果不是有乔老爷这只黑天鹅,我差点就相信三十岁以上的人都已经属于被时代脉搏淘汰的人了。 </p>
<p>愚人节的真是含义是,让人自省一下自己其实是个愚人。这一天,每个人都应该戴个驴面具上街的。 </p>
<p>人一成功,就喜欢将归纳法当作推导出真理的方法。 </p>
<p>人要成功很难,比成功更难的是,知道自己的成功是偶然的。 </p>
<p>归纳法来推导结论是错误的。所以很多时候,比拼的是谁更能独断专行。不过独断专行也是依赖在历史经验的基础上归纳出来的思路。 </p>
<p>陪练要找高手。 </p>
<p>群体互联时代,靠个人或者中心影响力来做宣传,显得不合失宜。 </p>
<p>没有压力和压力过重,都会导致不可承受的轻。 </p>
<p>王阳明是个了不起的人。看他的著作,不如在实践中尝试无畏。 </p>
<p>为了证明人是环境的反应器,在自然环境中才会产生更多的想法,我做了个实验,用语音记事本记录了今天在路上的十分钟产生的想法,结果发现,路上的思维很活跃。 </p>
<p>与其说乔布斯的强大在于对市场,商业,管理的洞察,不如说是对人性的洞察。 </p>
<p>我相信将来会有一种随时随地的微博形态来取代现在的微博。因为人在环境中实时产生的反应才是丰富而有实感的,而坐在电脑前产生的反应,是对电脑里的虚拟思维做二次反应。 </p>
<p>如果不能做一些特别的事情,那做它有什么意义呢。 </p>
<p>上帝让众生平庸,是不想看到他们都变成精神病 </p>
<p>一个理想的人生应该这么过,四十岁前把所有的欲望满足一遍,四十岁后过没有欲望的生活 </p>
<p>幸福感不一定和财富成正比,却和无知度成正比。 </p>
<p>丹·艾瑞里在《怪诞行为学》中,用大量的历史案例与实践经验证明:在很多时候,不是消费者的购买意愿影响市场价格,而是市场价格影响了消费者的预期,进而影响购买。 </p>
<p>在这本书中,高汀断言,我们已经进入了一个消费者几乎已经拥有了所必需的一切、很难有东西能激起其消费欲望的后消费时代,传统的面向大众的产品定位和老的营销法则即将衰亡,在这个需求饱和的时代,一种产品想要卖得出去——遑论获取成功——必须是值得注意的、例外的、全新的、有趣的 </p>
<p>从前的理论是,市场营销是炮弹,打炮才能带动销量。现在的情况是, 产品本身是炮弹,只要爆炸力强就能炸晕一片用户。 </p>
<p>要么你让市场营销人员去前线大炮,费钱费精力。要么你直接让用户打炮,一劳永逸。 </p>
<p>老乔是Intel的葛洛夫的唯有偏执狂才能生存的证明人。 </p>
<p>偏执需要权力的辅佐才能进行到底。 </p>
<p>中国的教育是扼杀好奇心的完美历程。 </p>
<p>写文章,做网站,写代码,要求的能力都是一样的,就是条理。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2018/06/25/bition-history/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/25/bition-history/" itemprop="url">
                  比特币的前世今生
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-25 21:54:01" itemprop="dateCreated datePublished" datetime="2018-06-25T21:54:01+08:00">2018-06-25</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/25/bition-history/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/06/25/bition-history/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="比特币诞生的背景？"><a href="#比特币诞生的背景？" class="headerlink" title="比特币诞生的背景？"></a>比特币诞生的背景？</h3><p>2008年，金融危机，当时政府和银行管理经济的能力遭到各方质疑，信用降入谷底。美国政府向华尔街和底特律汽车公司注入大笔资金，美联储推出“量化宽松”政策，本质上就是大量印美钞刺激经济，金价上涨。相当于政府拿民众的钱来补贴这些资本家。</p>
<h3 id="为什么要创建加密电子货币？"><a href="#为什么要创建加密电子货币？" class="headerlink" title="为什么要创建加密电子货币？"></a>为什么要创建加密电子货币？</h3><p>其实一直有一帮自由主义者密码极客希望创建一种完全去中心化的电子现金系统。可以脱离政府自由流通和发展。</p>
<p>因为之前的信用卡或者货币都存在诸多问题。比如信用卡需要用户的真实身份，对于用户的隐私保护不够。货币就存在超发的情况，政府通过这种方式从民众手里掠夺财富。</p>
<h3 id="加密电子货币的坎坷之路"><a href="#加密电子货币的坎坷之路" class="headerlink" title="加密电子货币的坎坷之路"></a>加密电子货币的坎坷之路</h3><p>1983年大卫·乔姆（David Chaum）最早提出把加密技术运用于现金上的想法。写了论文《不可被追踪的交易》，使用盲签（blind signature）的技术来实现匿名的网络支付系统。1989年大卫·乔姆创建了数字现金公司；在之前系统基础上创建了电子现金（Ecash）系统，这个系统还有一个别名为网络现金（cyberbucks）系统。得到了微软和visa等巨头的支持。但是因为理念太超前，未得到大范围的支持，另外，该系统支持企业对企业转账也是其失败的原因。</p>
<p>1998年，戴伟（Wei Dai）阐述了一种匿名的、分布式的电子现金系统：b-money。B.money强调点对点的交易和不可更改的交易记录。每个交易者都保持对交易追踪的权力。但是B.money系统中，大卫并没有解决账本同步的问题。</p>
<p>1998年，尼克·萨博（Nick Szabo）发明了比特黄金（BitGold），提出了工作量证明机制。</p>
<p>哈尔·芬尼（Hal Finney）发明了哈希现金（HashCash）则把该机制进一步完善为一种”可重复<br>利用的工作量证明（RPOW）“。“RPOW”的特色在于可重复使用，且虽然控管权集中，但发行者没有通胀压力。</p>
<p>2008年10月31日，名不见经传的中本聪在metzdowd.com的密码学邮件组列表中发表了比特币白皮书《Bitcoin: A Peer-to-Peer Electronic Cash System》（《比特币：一种点对点的现金支付系统》)。</p>
<p>2009年1月3日，比特币网络诞生，中本聪本人发布了开源的第一版比特币客户端。</p>
<p>2009年1月3日，比特币网络的第一个区块诞生了。<br><img src="http://images.insuncle.com/15301134448308.jpg" alt></p>
<p>2009年1月9日，中本聪本人发布了开源的0.1版比特币客户端。<br><img src="http://images.insuncle.com/15301134591691.jpg" alt></p>
<p>2009年1月12日，第一笔比特币交易，中本聪发送了 10 比特币给开发者、密码学活动份子，Hal Finney（哈尔·芬尼）。</p>
<p>2009年10月5日，有记录的最早比特币汇率： 1 美元 = 1309.03 比特币。</p>
<p>参考：<br><a href="https://en.wikipedia.org/wiki/Ecash" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ecash</a><br><a href="https://daimajia.com/2018/02/10/blockchain-share-in-freesfund" target="_blank" rel="noopener">https://daimajia.com/2018/02/10/blockchain-share-in-freesfund</a><br><a href="https://zhuanlan.zhihu.com/p/32754317" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32754317</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2018/05/13/JVM之Java堆/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/JVM之Java堆/" itemprop="url">
                  JVM之Java堆
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-13 10:05:48" itemprop="dateCreated datePublished" datetime="2018-05-13T10:05:48+08:00">2018-05-13</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/13/JVM之Java堆/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/05/13/JVM之Java堆/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM之Java堆"><a href="#JVM之Java堆" class="headerlink" title="JVM之Java堆"></a>JVM之Java堆</h1><p>先看图，搞清楚堆在运行区的位置<br><img src="http://images.insuncle.com/mweb/15725907891718.jpg" alt></p>
<blockquote>
<p>图片来自网络</p>
</blockquote>
<p><strong>介绍</strong><br>Java堆是JVM所管理内存中最大的一块，存放几乎所有对象实例（例外：栈上分配等）。这块是线程共享的区域。</p>
<p><img src="http://images.insuncle.com/mweb/15725908051364.jpg" alt></p>
<p>垃圾回收器管理的主要区域，现代的收集器基本都采用分代收集算法，所以可划分为新生代与老年代，新生代可进一步划分为Eden区、From Survivor区（S0）、To Survivor区（S1）。</p>
<p>可以处于物理上不连续内存空间中，所以标记-清理算法才会起作用。</p>
<p><strong>这个区域一些参数的解释</strong><br><img src="http://images.insuncle.com/mweb/15725908146701.jpg" alt></p>
<p>新生代与老年代的比例可以通过参数-XX:NewRatio来设置。比如，设置-XX:NewRatio=3，表示新生代:老年代=1:3，也就是说老年代占3/4。</p>
<p>Eden区、From Survivor区（S0）、To Survivor区（S1）之间的初始比例是8:1:1，通过-XX:SurvivorRatio参数来设置。比如：-XX:SurvivorRatio=8，表示两个Survivor:Eden = 2:8 ，每个Survivor占 1/10</p>
<p><strong>其他一些参数</strong></p>
<ul>
<li>-Xms：设置堆内存最小值</li>
<li>-Xmx：设置堆内存最大值</li>
<li>-Xmn堆中新生代初始及最大大小（NewSize和MaxNewSize为其细化）</li>
<li>-XX:NewSize设置新生代最小空间大小</li>
<li>-XX:MaxNewSize设置新生代最大空间大小</li>
<li>-XX:PermSize设置永久代最小空间大小</li>
<li>-XX:MaxPermSize设置永久代最大空间大小</li>
<li>-Xss设置每个线程的堆栈大小</li>
</ul>
<p>是不是参数太多，不容易记，这里有个记忆的小技巧</p>
<blockquote>
<p>Xmx（memory maximum）, Xms（memory startup）, Xmn（memory nursery/new）, Xss（stack size）</p>
</blockquote>
<p>对于参数的格式可以这样理解</p>
<ul>
<li>-: 标准VM选项，VM规范的选项。</li>
<li>-X: 非标准VM选项，不保证所有VM支持。</li>
<li>-XX: 高级选项，高级特性，但属于不稳定的选项。</li>
</ul>
<p><strong>会触发的异常</strong><br>OutOfMemoryError，堆中没有内存完成实例分配，并堆也无法再扩展时会触发。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2018/04/29/JVM之程序计数器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/JVM之程序计数器/" itemprop="url">
                  JVM之程序计数器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-29 12:48:38" itemprop="dateCreated datePublished" datetime="2018-04-29T12:48:38+08:00">2018-04-29</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/29/JVM之程序计数器/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/04/29/JVM之程序计数器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JVM运行时数据区的图，从这个图能清楚程序计数器的位置<br><img src="http://images.insuncle.com/mweb/15723360448435.jpg" alt></p>
<p>线程私有的，生命周期与线程相同</p>
<h3 id="什么是程序计数器？"><a href="#什么是程序计数器？" class="headerlink" title="什么是程序计数器？"></a>什么是程序计数器？</h3><p>通俗的讲就是告诉当前线程该执行哪条字节码了。</p>
<p>周志明定义</p>
<blockquote>
<p>可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器的工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。</p>
</blockquote>
<h3 id="程序计数器存在哪？"><a href="#程序计数器存在哪？" class="headerlink" title="程序计数器存在哪？"></a>程序计数器存在哪？</h3><p>虚拟机区别于硬件，组成原理里学的程序计数器是用CS和IP寄存器来存，来表示指令地址。<br>而Java把程序计数器存在内存里。</p>
<h3 id="程序计数器保存内容？"><a href="#程序计数器保存内容？" class="headerlink" title="程序计数器保存内容？"></a>程序计数器保存内容？</h3><p>两种情况：<br>一、存的是Java字节码的地址，实现上可能有两种形式：<br>1.是相对该方法字节码开始处的偏移量，叫做bytecode index，简称bci；<br>2.是该Java字节码指令在内存里的地址，叫做bytecode pointer，简称bcp。</p>
<p>二、为空（Undefined）<br>如果调用的是Native方法</p>
<h3 id="程序计数器有啥作用？"><a href="#程序计数器有啥作用？" class="headerlink" title="程序计数器有啥作用？"></a>程序计数器有啥作用？</h3><p>现实中程序往往是多线程协作完成任务的。JVM的多线程是通过CPU时间片轮转来实现的，某个线程在执行的过程中可能会因为时间片耗尽而挂起。当它再次获取时间片时，需要从挂起的地方继续执行。在JVM中，通过程序计数器来记录程序的字节码执行位置。程序计数器具有线程隔离性，每个线程拥有自己的程序计数器</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>此区域一般不会发生OutOfMemoryError，如果发生此类异常，排查的时候先别着急找这块了。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>是跟操作系统中的程序计数器有点类似。这个有时间再补充吧。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.sunjs.com/article/detail/6700cb3679744dc190adfdd9202d4055.html" target="_blank" rel="noopener">https://www.sunjs.com/article/detail/6700cb3679744dc190adfdd9202d4055.html</a></li>
<li><a href="https://www.cnblogs.com/noKing/p/8157608.html" target="_blank" rel="noopener">https://www.cnblogs.com/noKing/p/8157608.html</a></li>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://www.zhihu.com/question/40598119/answer/87381512" target="_blank" rel="noopener">https://www.zhihu.com/question/40598119/answer/87381512</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2018/03/11/区块链和生产关系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/区块链和生产关系/" itemprop="url">
                  区块链和生产关系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-11 17:04:27" itemprop="dateCreated datePublished" datetime="2018-03-11T17:04:27+08:00">2018-03-11</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/11/区块链和生产关系/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/03/11/区块链和生产关系/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之所以说区块链是生产关系，就是因为区块链技术可以很完美地为不同参与者分配利益。各方人对这种利益的分配规则的认可，就是一种共识。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2018/02/04/2018-02-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/04/2018-02-04/" itemprop="url">
                  《数字黄金》读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-04 21:42:26" itemprop="dateCreated datePublished" datetime="2018-02-04T21:42:26+08:00">2018-02-04</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/04/2018-02-04/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/02/04/2018-02-04/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="比特币的优势"><a href="#比特币的优势" class="headerlink" title="比特币的优势"></a>比特币的优势</h2><ul>
<li>匿名</li>
<li>绝对个人所有</li>
<li>跨境支付，速度快，手续费低</li>
<li>抗通货膨胀</li>
</ul>
<p>相比于现有货币，具备稀缺，分割性更强，耐用性更强，流通性更强</p>
<h2 id="比特币的价格"><a href="#比特币的价格" class="headerlink" title="比特币的价格"></a>比特币的价格</h2><p>全世界的黄金的价值应该是7万亿美元。假如比特币在全世界一半的地区流行，每个比特币的价格应该在50万美元</p>
<p>全球货币种类：170种（来自于维基百科），大概只有5%比较有价值，8种左右，美元、欧元、人民币、日元、英镑</p>
<h2 id="比特币的价值"><a href="#比特币的价值" class="headerlink" title="比特币的价值"></a>比特币的价值</h2><p>比特币的价值在于存储价值，不一定在交易上有多强悍的功能，类似黄金，比特币它自身有支付功能，但重点不在支付。它的重点是资产，是资产带支付，而不是支付带资产，反过来。什么意思呢？就是这个东西本身像黄金，也是一个商品嘛。但黄金有没有免费的支付，黄金从这边搬到那边要把它搬过去的 ，黄金没有脚不会走过去。比特币就不同，比特币是资产啊，但你叫它走过去，它可以自己走过去的。因为移动数字很便宜，没有成本嘛。所以它是资产带支付。</p>
<p>13年的时候百度的云保安服务就开始接收比特币支付，这个还挺让人惊奇的</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/09/26/Oracle学习笔记——配置监听/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/26/Oracle学习笔记——配置监听/" itemprop="url">
                  Oracle学习笔记——配置监听
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-26 15:58:26" itemprop="dateCreated datePublished" datetime="2017-09-26T15:58:26+08:00">2017-09-26</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/26/Oracle学习笔记——配置监听/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/09/26/Oracle学习笔记——配置监听/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是监听"><a href="#什么是监听" class="headerlink" title="什么是监听"></a>什么是监听</h3><p>如果你做过网络开发，对于监听listen就比较熟悉了，监听是什么，在网络开发中，就是监听某个端口，等待客户端的连接。同理，在Oracle中，监听的意思也和这差不多。</p>
<p>在Oracle数据库服务器中，通过一个叫“监听器”的组件接收来自客户端的连接请求，它是客户端和 服务器端中间的桥梁。监听器虽然在Oracle服务器端，但是它和Oracle主进程并不绑定，它是一个独立运行在服务器端的后台进程，独立于数据库运行。它负责对客户端传入的连接请求进行监听，并且对服务器端的连接负荷进行调整。当客户端准备建立一个到服务器端的连接时，监听器接收客户端的连接请求， 然后再将这个客户端连接请求交给服务器进行处理，一旦客户端和服务器建立连接，客户端和服务器以后就直接进行通信，而不再需要监听器的参与，这就好比师傅 领进门，修行靠个人。就如下图所示：<br><img src="http://oo501cyv7.bkt.clouddn.com/15064117419478.png" alt></p>
<ol>
<li>客户端向服务器端发出连接请求，监听器监听到客户端的连接请求；</li>
<li>监听器把客户端的连接请求交给数据库服务器进行处理；</li>
<li>经过监听器建立连接以后，客户端与服务器端就可以直接进行通信，而不再需要监听器的参与了。<br>以上就是监听器干的活，也就是说，你对数据库服务器的第一次，肯定会给监听器，如果监听器没有配好，你就甭想连数据库了。那么，怎么才能配好监听器呢？主要涉及以下三个文件：</li>
</ol>
<p><strong>listener.ora、sqlnet.ora和tnsnames.ora文件</strong></p>
<h4 id="listener-ora文件"><a href="#listener-ora文件" class="headerlink" title="listener.ora文件"></a>listener.ora文件</h4><p>打开listener.ora文件看看，贴上一部分有代表性的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#这是一个名为LISTENER1的监听器</span><br><span class="line">#监听的协议是TCP协议</span><br><span class="line">#监听的主机IP是127.0.0.1</span><br><span class="line">#监听的端口是1521端口</span><br><span class="line">LISTENER1 =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">    (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#记录了监听器LISTENER1服务的全局数据库名、数据库路径和数据库实例名</span><br><span class="line">SID_LIST_LISTENER1 =</span><br><span class="line">    (SID_LIST =</span><br><span class="line">        (SID_DESC =</span><br><span class="line">            (GLOBAL_DBNAME = ORCL)</span><br><span class="line">            (ORACLE_HOME = C:\Oracle11g\product\11.2.0\dbhome_1)</span><br><span class="line">            (SID_NAME = ORCL)</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h4 id="sqlnet-ora文件"><a href="#sqlnet-ora文件" class="headerlink" title="sqlnet.ora文件"></a>sqlnet.ora文件</h4><p>打开sqlnet.ora文件看看，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQLNET.AUTHENTICATION_SERVICES= (NTS)</span><br><span class="line">NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT)</span><br></pre></td></tr></table></figure>
<p>这个sqlnet.ora文件实际上就是一个配置文件，主要是和接下来说的tnsnames.ora配合使用。</p>
<h4 id="tnsnames-ora文件"><a href="#tnsnames-ora文件" class="headerlink" title="tnsnames.ora文件"></a>tnsnames.ora文件</h4><p>tnsnames.ora文件存放于客户端机器上，和sqlnet.ora文件配合使用。可以简单的看看tnsnames.ora文件中的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ORCL是个别名</span><br><span class="line">#这条信息记录了我们使用TCP协议，去连接IP地址为127.0.0.1，端口号为1521的数据库主机上服务名为orcl的数据库</span><br><span class="line">ORCL =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">        (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</span><br><span class="line">        (CONNECT_DATA =</span><br><span class="line">            (SERVER = DEDICATED)</span><br><span class="line">            (SERVICE_NAME = orcl)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">以后，我们还会配置更多的数据库连接信息，比如我要连接192.168.10.2主机上的数据库，我们只需要在tnsnames.ora中继续追加新的连接信息即可，比如：</span><br><span class="line"></span><br><span class="line">STDB =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">        (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.10.2)(PORT = 1521))</span><br><span class="line">        (CONNECT_DATA =</span><br><span class="line">            (SERVER = DEDICATED)</span><br><span class="line">            (SERVICE_NAME = stdb)</span><br><span class="line">        )</span><br><span class="line">     )</span><br></pre></td></tr></table></figure>
<h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><p>直接编辑listener.ora，就像下面这样，配置一个新的监听器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LISTENER =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">    (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SID_LIST_LISTENER =</span><br><span class="line">    (SID_LIST =</span><br><span class="line">        (SID_DESC =</span><br><span class="line">            (GLOBAL_DBNAME = ORCL)</span><br><span class="line">            (ORACLE_HOME = C:\Oracle11g\product\11.2.0\dbhome_1)</span><br><span class="line">            (SID_NAME = ORCL)</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>你想在哪个数据库上配置一个新的监听，就修改对应的内容即可。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>启动监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl start &lt;监听器的名字&gt;</span><br><span class="line"></span><br><span class="line">// 启动名为LISTENER的监听器</span><br><span class="line">lsnrctl start LISTENER</span><br></pre></td></tr></table></figure>
<p>当我们不指定监听器的名字时，就默认启动LISTENER监听器；</p>
<p>关闭监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl stop &lt;监听器的名字&gt;</span><br><span class="line"></span><br><span class="line">// 关闭名为LISTENER的监听器</span><br><span class="line">lsnrctl stop LISTENER</span><br></pre></td></tr></table></figure>
<p>当我们不指定监听器的名字时，就默认关闭LISTENER监听器；</p>
<p>查看监听器的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl status &lt;监听器的名字&gt;</span><br><span class="line"></span><br><span class="line">// 查看名为LISTENER的监听器的运行状态</span><br><span class="line">lsnrctl status LISTENER</span><br></pre></td></tr></table></figure>
<p>当我们不指定监听器的名字时，就默认查看LISTENER监听器的状态。</p>
<p>测试连通性<br>可以使用工具<code>TNSPING</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.jellythink.com/archives/985" target="_blank" rel="noopener">Oracle学习笔记——配置监听</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/09/25/Oracle学习笔记——Linux设置Oracle环境变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/25/Oracle学习笔记——Linux设置Oracle环境变量/" itemprop="url">
                  Oracle学习笔记——Linux设置Oracle环境变量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-25 16:32:06" itemprop="dateCreated datePublished" datetime="2017-09-25T16:32:06+08:00">2017-09-25</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/25/Oracle学习笔记——Linux设置Oracle环境变量/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/09/25/Oracle学习笔记——Linux设置Oracle环境变量/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有三种设置方法，具体如下：</p>
<p>方法一：直接运行export命令定义变量,<strong>该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的</strong>，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p>
<p>以设置oracle环境变量为例<br><img src="http://oo501cyv7.bkt.clouddn.com/15063281966273.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export ORACLE_BASE=/data/app/oracle; </span><br><span class="line">export ORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1; </span><br><span class="line">export ORACLE_SID=orcl; </span><br><span class="line">export PATH=$ORACLE_HOME/bin:$PATH;</span><br></pre></td></tr></table></figure>
<p>方法二：在用户目录下的.bash_profile文件中增加变量，改变量<strong>仅会对当前用户有效</strong>，并且是“永久的”。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/15063282260029.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/data/app/oracle;                          export ORACLE_BASE</span><br><span class="line">ORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1;      export ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl;                                       export ORACLE_SID</span><br><span class="line">PATH=$ORACLE_HOME/bin:$PATH;                           export PATH</span><br></pre></td></tr></table></figure>
<p>方法三： 在/etc/profile文件中添加变量，该变量将<strong>会对Linux下所有用户有效</strong>，并且是“永久的”。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/15063282550340.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/data/app/oracle;                        export ORACLE_BASE</span><br><span class="line">ORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1;    export ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl;                                     export ORACLE_SID</span><br><span class="line">PATH=$ORACLE_HOME/bin:$PATH;                         export PATH</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/09/25/Linux环境变量总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/25/Linux环境变量总结/" itemprop="url">
                  Linux环境变量总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-25 16:21:24" itemprop="dateCreated datePublished" datetime="2017-09-25T16:21:24+08:00">2017-09-25</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/" itemprop="url" rel="index"><span itemprop="name">理解计算器机</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/25/Linux环境变量总结/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/09/25/Linux环境变量总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Linux是一个多用户多任务的操作系统，可以==在Linux中为不同的用户设置不同的运行环境==，具体做法是设置不同用户的环境变量。</p>
<h3 id="Linux环境变量分类"><a href="#Linux环境变量分类" class="headerlink" title="Linux环境变量分类"></a>Linux环境变量分类</h3><p>一、按照生命周期来分，Linux环境变量可以分为两类：<br>1、永久的：需要用户修改相关的配置文件，变量永久生效。<br>2、临时的：用户利用export命令，在当前终端下声明环境变量，关闭Shell终端失效。</p>
<p>二、按照作用域来分，Linux环境变量可以分为：<br>1、系统环境变量：系统环境变量对该系统中所有用户都有效。<br>2、用户环境变量：顾名思义，这种类型的环境变量只对特定的用户有效。</p>
<h3 id="Linux设置环境变量的方法"><a href="#Linux设置环境变量的方法" class="headerlink" title="Linux设置环境变量的方法"></a>Linux设置环境变量的方法</h3><p>一、在<code>/etc/profile</code>文件中添加变量 <strong>对所有用户生效（永久的）</strong><br>用vim在文件<code>/etc/profile</code>文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。<br>例如：编辑<code>/etc/profile</code>文件，添加<code>CLASSPATH</code>变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile    </span><br><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure>
<p>注：修改文件后要想马上生效还要运行<code>source /etc/profile</code>不然只能在下次重进此用户时生效。</p>
<p>二、在用户目录下的<code>.bash_profile</code>文件中增加变量 【<strong>对单一用户生效（永久的）</strong>】<br>用<code>vim ~/.bash_profile</code>文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash.profile</span><br><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure>
<p>注：修改文件后要想马上生效还要运行<code>$ source ~/.bash_profile</code>不然只能在下次重进此用户时生效。</p>
<p>三、直接运行export命令定义变量 【<strong>只对当前shell（BASH）有效（临时的）</strong>】<br>在shell的命令行下直接使用<code>export 变量名=变量值</code><br>定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p>
<h3 id="Linux环境变量使用"><a href="#Linux环境变量使用" class="headerlink" title="Linux环境变量使用"></a>Linux环境变量使用</h3><p>一、Linux中常见的环境变量有：</p>
<p>PATH：指定命令的搜索路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PATH声明用法：</span><br><span class="line">PATH=$PAHT:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:--------:&lt; PATH n &gt;</span><br><span class="line">export PATH</span><br><span class="line">你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效。</span><br><span class="line">可以利用echo $PATH查看当前当前系统PATH路径。</span><br></pre></td></tr></table></figure>
<p>HOME：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）。<br>HISTSIZE：指保存历史命令记录的条数。<br>LOGNAME：指当前用户的登录名。<br>HOSTNAME：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的<br>SHELL：指当前用户用的是哪种Shell。<br>LANG/LANGUGE：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。<br>MAIL：指当前用户的邮件存放目录。</p>
<p>注意：上述变量的名字并不固定，如HOSTNAME在某些Linux系统中可能设置成HOST</p>
<p>二、Linux也提供了修改和查看环境变量的命令，下面通过几个实例来说明：</p>
<p>echo 显示某个环境变量值 echo $PATH<br>export 设置一个新的环境变量 export HELLO=”hello” (可以无引号)<br>env 显示所有环境变量<br>set 显示本地定义的shell变量<br>unset 清除环境变量 unset HELLO<br>readonly 设置只读环境变量 readonly HELLO</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/09/21/INSTALLATION-OF-ORACLE-11g-Release-2-on-CentOS-6-5-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/21/INSTALLATION-OF-ORACLE-11g-Release-2-on-CentOS-6-5-1/" itemprop="url">
                  Oracle学习笔记——在centos6.5上安装oracle11g
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-21 15:24:51" itemprop="dateCreated datePublished" datetime="2017-09-21T15:24:51+08:00">2017-09-21</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/21/INSTALLATION-OF-ORACLE-11g-Release-2-on-CentOS-6-5-1/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/09/21/INSTALLATION-OF-ORACLE-11g-Release-2-on-CentOS-6-5-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>操作系统：CentOS6.5（64位）<br>数据库：Oracle 11g Release2 (64-bit)</p>
<h2 id="第一步：配置yum以下载oracle的依赖"><a href="#第一步：配置yum以下载oracle的依赖" class="headerlink" title="第一步：配置yum以下载oracle的依赖"></a>第一步：配置yum以下载oracle的依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cd /etc/yum.repos.d</span><br><span class="line"># wget https://public-yum.oracle.com/public-yum-ol6.repo</span><br><span class="line">If case you received Certificate error then, use following command</span><br><span class="line"># wget https://public-yum.oracle.com/public-yum-ol6.repo –no-check-certificate</span><br></pre></td></tr></table></figure>
<p><img src="http://oo501cyv7.bkt.clouddn.com/15059722614907.png" alt></p>
<h2 id="第二步：导入GPG-Keys"><a href="#第二步：导入GPG-Keys" class="headerlink" title="第二步：导入GPG Keys"></a>第二步：导入GPG Keys</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># wget https://public-yum.oracle.com/RPM-GPG-KEY-oracle-ol6 -O /etc/pki/rpm-gpg/RPM-GPG-KEY-oracle</span><br><span class="line">If case you received Certificate error, then use following command</span><br><span class="line"># wget https://public-yum.oracle.com/RPM-GPG-KEY-oracle-ol6 -O /etc/pki/rpm-gpg/RPM-GPG-KEY-oracle –no-check-certificate</span><br></pre></td></tr></table></figure>
<h2 id="第三步：安装oracle的依赖"><a href="#第三步：安装oracle的依赖" class="headerlink" title="第三步：安装oracle的依赖"></a>第三步：安装oracle的依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install oracle-rdbms-server-11gR2-preinstall</span><br></pre></td></tr></table></figure>
<h2 id="第四步：设置服务器hsotname"><a href="#第四步：设置服务器hsotname" class="headerlink" title="第四步：设置服务器hsotname"></a>第四步：设置服务器hsotname</h2><p><code># vi /etc/hosts</code><br><img src="http://oo501cyv7.bkt.clouddn.com/15059724528724.jpg" alt></p>
<p><code># vi /etc/sysconfig/network</code></p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/15059725023188.jpg" alt></p>
<h2 id="第五步：在服务器创建oracle账户"><a href="#第五步：在服务器创建oracle账户" class="headerlink" title="第五步：在服务器创建oracle账户"></a>第五步：在服务器创建oracle账户</h2><p>在终端里执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># passwd oracle</span><br><span class="line">Change password for user oracle.</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD:it is based on a dictinory word</span><br><span class="line">BAD PASSWORD:is too simple</span><br><span class="line">Retype new password:</span><br><span class="line">passwd:all authentication tokens updated sucessfully.</span><br></pre></td></tr></table></figure>
<h2 id="第六步：配置文件“90-nproc-conf”"><a href="#第六步：配置文件“90-nproc-conf”" class="headerlink" title="第六步：配置文件“90-nproc.conf”"></a>第六步：配置文件“90-nproc.conf”</h2><p><code># vi /etc/security/limits.d/90-nproc.conf</code><br><img src="http://oo501cyv7.bkt.clouddn.com/15059730733689.jpg" alt></p>
<h2 id="第七步：配置selinux参数为“permissive”"><a href="#第七步：配置selinux参数为“permissive”" class="headerlink" title="第七步：配置selinux参数为“permissive”"></a>第七步：配置selinux参数为“permissive”</h2><p><code># vi /etc/selinux/config</code><br><img src="http://oo501cyv7.bkt.clouddn.com/15059731663187.jpg" alt></p>
<p><strong>重启服务器</strong>，然后使用『oracle』账户登录。使用其他账户登录的使用<code>su - oracle</code>切换到oracle账户下。</p>
<h2 id="第八步：在-“-bash-profile”-中添加oracle的相关配置"><a href="#第八步：在-“-bash-profile”-中添加oracle的相关配置" class="headerlink" title="第八步：在 “.bash_profile” 中添加oracle的相关配置"></a>第八步：在 “.bash_profile” 中添加oracle的相关配置</h2><p><code>[oracle@oracle~]# vi .bash_profile</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/home/oracle/app/oracle;                 export ORACLE_BASE</span><br><span class="line">ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1;    export ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl;                                     export ORACLE_SID</span><br><span class="line">PATH=$ORACLE_HOME/bin:$PATH;                         export PATH</span><br></pre></td></tr></table></figure>
<p>其中<code>ORACLE_BASE</code>、<code>ORACLE_HOME</code>一定要和oracle的安装目录一致，不一致需要后续做修改。<br><img src="http://oo501cyv7.bkt.clouddn.com/15059735547795.jpg" alt></p>
<p><code>[oracle@oracle~]# source .bash_profile #修改的文件立即生效</code></p>
<h2 id="第九步：在服务器的虚拟控制台调用图形界面安装"><a href="#第九步：在服务器的虚拟控制台调用图形界面安装" class="headerlink" title="第九步：在服务器的虚拟控制台调用图形界面安装"></a>第九步：在服务器的虚拟控制台调用图形界面安装</h2><p>转到存放oracle压缩文件的目录，执行<code>unzip</code>命令来解压缩文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[oracle@oracle~]# unzip /media/linux.x64_11gR2_database_1of2.zip </span><br><span class="line">[oracle@oracle~]# unzip /media/linux.x64_11gR2_database_2of2.zip</span><br></pre></td></tr></table></figure>
<p>文件会解压到一个<code>database</code>的目录。<br><img src="http://oo501cyv7.bkt.clouddn.com/15059738419976.jpg" alt></p>
<p>执行<code>./runInstaller</code>就可以调出图形化界面了。（==<strong>注意：这个需要在服务器上的终端来执行，SSH连接到服务器运行该命令是不行的，需要通过xhost单独设置。</strong>==）</p>
<p>在执行上边的命令后可能会遇到乱码，执行以下命令再重新运行<code>./runInstaller</code></p>
<p><code>[oracle@oracle~]# export LANG=en_US.utf-8</code></p>
<p>可能会遇到网络不通的情况，应该是hostname没有设置正确。需要在oracle账户下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[oracle@oracle~]# hostname oracle.xdf.cn</span><br><span class="line">[oracle@oracle~]# hostname</span><br><span class="line">oracle.xdf.cn #有这个信息出来就表示设置好了</span><br></pre></td></tr></table></figure>
<h3 id="输入接受一些安全问题的邮件地址（什么也不输入）"><a href="#输入接受一些安全问题的邮件地址（什么也不输入）" class="headerlink" title="输入接受一些安全问题的邮件地址（什么也不输入）"></a>输入接受一些安全问题的邮件地址（什么也不输入）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059753192771.jpg" alt></p>
<h3 id="选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件"><a href="#选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件" class="headerlink" title="选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件"></a>选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059753952572.jpg" alt></p>
<h3 id="选择服务器版本"><a href="#选择服务器版本" class="headerlink" title="选择服务器版本"></a>选择服务器版本</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754099248.jpg" alt></p>
<h3 id="单实例数据库"><a href="#单实例数据库" class="headerlink" title="单实例数据库"></a>单实例数据库</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754176925.jpg" alt></p>
<h3 id="高级模式安装"><a href="#高级模式安装" class="headerlink" title="高级模式安装"></a>高级模式安装</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754282905.jpg" alt></p>
<h3 id="添加支持的语言（可以不添加，只支持英文也行）"><a href="#添加支持的语言（可以不添加，只支持英文也行）" class="headerlink" title="添加支持的语言（可以不添加，只支持英文也行）"></a>添加支持的语言（可以不添加，只支持英文也行）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754352247.jpg" alt><br><img src="http://oo501cyv7.bkt.clouddn.com/15059754767809.jpg" alt></p>
<h3 id="选择要安装的版本"><a href="#选择要安装的版本" class="headerlink" title="选择要安装的版本"></a>选择要安装的版本</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754873760.jpg" alt></p>
<h3 id="安装数据库目录"><a href="#安装数据库目录" class="headerlink" title="安装数据库目录"></a>安装数据库目录</h3><p>Oracle Base: /hywl/oracle/app<br>Sofeware Location: /hywl/oracle/app/product/11.1.1/db_1<br>这个根据自己服务器的账户名不同有所差别<br><img src="http://oo501cyv7.bkt.clouddn.com/15059755417537.jpg" alt><br><img src="http://oo501cyv7.bkt.clouddn.com/15059755472755.jpg" alt></p>
<h3 id="数据库用途"><a href="#数据库用途" class="headerlink" title="数据库用途"></a>数据库用途</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059755567343.jpg" alt></p>
<h3 id="数据库名及服务名（可以修改为自己想要）"><a href="#数据库名及服务名（可以修改为自己想要）" class="headerlink" title="数据库名及服务名（可以修改为自己想要）"></a>数据库名及服务名（可以修改为自己想要）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059755645841.jpg" alt></p>
<h3 id="开启自动内存管理"><a href="#开启自动内存管理" class="headerlink" title="开启自动内存管理"></a>开启自动内存管理</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059755911915.jpg" alt></p>
<h3 id="设置默认编码为UTF8（如果未添加中文支持，无这步操作）"><a href="#设置默认编码为UTF8（如果未添加中文支持，无这步操作）" class="headerlink" title="设置默认编码为UTF8（如果未添加中文支持，无这步操作）"></a>设置默认编码为UTF8（如果未添加中文支持，无这步操作）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756322355.jpg" alt></p>
<h3 id="启用Oracle企业管理控制台OEM"><a href="#启用Oracle企业管理控制台OEM" class="headerlink" title="启用Oracle企业管理控制台OEM"></a>启用Oracle企业管理控制台OEM</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756411025.jpg" alt></p>
<h3 id="选择数据库文件目录"><a href="#选择数据库文件目录" class="headerlink" title="选择数据库文件目录"></a>选择数据库文件目录</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756495504.jpg" alt></p>
<h3 id="自动备份设置：不启用"><a href="#自动备份设置：不启用" class="headerlink" title="自动备份设置：不启用"></a>自动备份设置：不启用</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756573188.jpg" alt></p>
<h3 id="设置数据库用户名和密码"><a href="#设置数据库用户名和密码" class="headerlink" title="设置数据库用户名和密码"></a>设置数据库用户名和密码</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756639425.jpg" alt></p>
<h3 id="授权的组"><a href="#授权的组" class="headerlink" title="授权的组"></a>授权的组</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756730616.jpg" alt></p>
<h3 id="检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）"><a href="#检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）" class="headerlink" title="检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）"></a>检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756918240.jpg" alt></p>
<h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757013456.jpg" alt></p>
<h3 id="安装即将完成"><a href="#安装即将完成" class="headerlink" title="安装即将完成"></a>安装即将完成</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757103123.jpg" alt><br><img src="http://oo501cyv7.bkt.clouddn.com/15059757171035.jpg" alt></p>
<h3 id="解锁用户SCOTT，-SCOTT的默认口令为tiger（这步也可以不设置）"><a href="#解锁用户SCOTT，-SCOTT的默认口令为tiger（这步也可以不设置）" class="headerlink" title="解锁用户SCOTT， SCOTT的默认口令为tiger（这步也可以不设置）"></a>解锁用户SCOTT， SCOTT的默认口令为tiger（这步也可以不设置）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757313014.jpg" alt></p>
<h3 id="弹出“执行配置脚本”对对话框"><a href="#弹出“执行配置脚本”对对话框" class="headerlink" title="弹出“执行配置脚本”对对话框"></a>弹出“执行配置脚本”对对话框</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757540732.jpg" alt></p>
<p>安装完成了，系统提示需要用root账户执行两个脚本（orainstRoot.sh，root.sh）系统才算完全安装完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@oracle~]$ /hywl/oracle/app/oraInventory/orainstRoot.sh</span><br><span class="line"></span><br><span class="line">[root@oracle~]$ /hywl/oracle/app/product/11.2.0/dbhome_1/root.sh</span><br></pre></td></tr></table></figure>
<p>==<strong>很重要的一点，一定要记得在防火墙上开启<code>1521</code>端口，不然客户端是连接不上的，提示<code>no listner</code>。</strong>==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ su - root</span><br><span class="line"># /sbin/iptables -I INPUT -p tcp --dport 1251 -j ACCEPT </span><br><span class="line"># /etc/rc.d/init.d/iptables save</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.royalcyber.com/integration/installation-of-oracle-11g-release-2-on-centos-6-5/" target="_blank" rel="noopener">INSTALLATION OF ORACLE 11g Release 2 on CentOS 6.5</a></li>
<li><a href="http://77jiayuan.blog.51cto.com/386386/1569389" target="_blank" rel="noopener">CentOS 6.5_x64安装Oracle 11g R2</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/09/18/idea在tomcat中的热部署/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/18/idea在tomcat中的热部署/" itemprop="url">
                  IDEA在tomcat中的热部署
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-18 11:32:58" itemprop="dateCreated datePublished" datetime="2017-09-18T11:32:58+08:00">2017-09-18</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/利器/" itemprop="url" rel="index"><span itemprop="name">利器</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/18/idea在tomcat中的热部署/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/09/18/idea在tomcat中的热部署/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="idea在tomcat中的热部署"><a href="#idea在tomcat中的热部署" class="headerlink" title="idea在tomcat中的热部署"></a>idea在tomcat中的热部署</h1><p>如果每次jsp页面或后台代码有修改，都得重启，确实比较麻烦，现在找到一种利用jrebel这个插件来实现热不熟。</p>
<p>在idea的插件库中找到jrebel，如下图<br><img src="http://oo501cyv7.bkt.clouddn.com/15057048125945.jpg" alt></p>
<p>因为这个插件是需要收费，这里有办法可以免费获取激活码：</p>
<p>方法1：JRebel有一个免费获得激活码的方法，登录<a href="https://my.jrebel.com这个网站（FQ），然后用Twitter或者Facebook账号登录这个网站，就能获得免费的激活码。" target="_blank" rel="noopener">https://my.jrebel.com这个网站（FQ），然后用Twitter或者Facebook账号登录这个网站，就能获得免费的激活码。</a><br><img src="http://oo501cyv7.bkt.clouddn.com/15057048682483.jpg" alt></p>
<p>在IDEA里面Help-&gt;JRebel-&gt;Activate，复制粘贴激活码就行了。<br><img src="http://oo501cyv7.bkt.clouddn.com/15057048855064.jpg" alt></p>
<p>方法2：<br>1.激活时填写的 <a href="http://idea.jrebel.ml/ilanyu" target="_blank" rel="noopener">http://idea.jrebel.ml/ilanyu</a> 及 lanyu19950316@gmail.com，授权服务器地址格式为：<a href="http://idea.jrebel.ml/{用户名}，邮箱随意填写，idea.jrebel.ml" target="_blank" rel="noopener">http://idea.jrebel.ml/{用户名}，邮箱随意填写，idea.jrebel.ml</a> 可能随时会被封，可使用反向代理工具代理 <a href="http://idea.lanyus.com/，即可稳定使用授权服务器。" target="_blank" rel="noopener">http://idea.lanyus.com/，即可稳定使用授权服务器。</a></p>
<p>2.该激活方法可离线使用6个月，可根据需要点击 Renew offline seat 即可更新离线过期时间。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/21/数据库的事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/21/数据库的事务/" itemprop="url">
                  数据库事务详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-21 12:25:01" itemprop="dateCreated datePublished" datetime="2017-07-21T12:25:01+08:00">2017-07-21</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/21/数据库的事务/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/21/数据库的事务/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务。</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p>
<blockquote>
<p>1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。<br>2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</p>
</blockquote>
<p>当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</p>
<p>但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p>
<blockquote>
<p>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。<br>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。<br>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。<br>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</p>
</blockquote>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：</p>
<p>1、从A账号中把余额读出来（500）。<br>2、对A账号做减法操作（500-100）。<br>3、把结果写回A账号中（400）。<br>4、从B账号中把余额读出来（500）。<br>5、对B账号做加法操作（500+100）。<br>6、把结果写回B账号中（600）。</p>
<h3 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h3><p>保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。</p>
<p>为了实现原子性，需要通过日志：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。<br>如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。</p>
<p>原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。例如，事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上， 事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。</p>
<p>为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。用术语来说，就是多个事务并发执行后的状态，和它们串行执行后的状态是等价的。怎样实现隔离性，已经有很多人回答过了，原则上无非是两种类型的锁：1)悲观锁 2)乐观锁</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！</p>
<h2 id="原子性与隔离性"><a href="#原子性与隔离性" class="headerlink" title="原子性与隔离性"></a>原子性与隔离性</h2><p>一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关。<br>比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。</p>
<p>因此，事务的原子性与一致性缺一不可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.hollischuang.com/archives/898" target="_blank" rel="noopener">彻底理解数据库事务</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/21/MySQL存储引擎/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/21/MySQL存储引擎/" itemprop="url">
                  MySQL存储引擎
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-21 12:25:01" itemprop="dateCreated datePublished" datetime="2017-07-21T12:25:01+08:00">2017-07-21</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/21/MySQL存储引擎/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/21/MySQL存储引擎/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于初学者来说我们通常不关注存储引擎，但是 MySQL 提供了多个存储引擎，包括处理事物安全表的引擎和处理非食物安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p>
<h2 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h2><p>MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。 存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p>
<p>例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。我的电脑上安装的 MySQL 5.6.13 版，InnoDB就是作为默认的存储引擎。InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p>
<ul>
<li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li>
<li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li>
<li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li>
<li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li>
<li>支持自动增加列AUTO_INCREMENT属性。</li>
<li>从5.7开始innodb存储引擎成为默认的存储引擎。</li>
</ul>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：</p>
<ul>
<li>tb_demo.frm，存储表定义。</li>
<li>tb_demo.MYD，存储数据。</li>
<li>tb_demo.MYI，存储索引。</li>
</ul>
<p>MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：</p>
<ol>
<li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>
<li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li>
</ol>
<h3 id="MRG-MYISAM"><a href="#MRG-MYISAM" class="headerlink" title="MRG_MYISAM"></a>MRG_MYISAM</h3><p>MRG_MyISAM存储引擎是一组MyISAM表的组合，老版本叫 MERGE 其实是一回事儿，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。</p>
<p>Merge存储引擎的使用场景。对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。</p>
<ul>
<li>ENGINE=MERGE，指明使用MERGE引擎，其实是跟MRG_MyISAM一回事儿，也是对的，在MySQL 5.7已经看不到MERGE了。</li>
<li>UNION=(t1, t2)，指明了MERGE表中挂接了些哪表，可以通过alter table的方式修改UNION的值，以实现增删MERGE表子表的功能。比如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_merge <span class="keyword">engine</span>=<span class="keyword">merge</span> <span class="keyword">union</span>(tb_log1) insert_method=<span class="keyword">last</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>INSERT_METHOD=LAST，INSERT_METHOD指明插入方式，取值可以是：0 不允许插入；FIRST 插入到UNION中的第一个表； LAST 插入到UNION中的最后一个表。</li>
<li>MERGE表及构成MERGE数据表结构的各成员数据表必须具有完全一样的结构。每一个成员数据表的数据列必须按照同样的顺序定义同样的名字和类型，索引也必须按照同样的顺序和同样的方式定义。</li>
</ul>
<h3 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h3><p>使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。</p>
<p>一般在以下几种情况下使用Memory存储引擎：</p>
<ul>
<li>目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。</li>
<li>如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。</li>
<li>存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。</li>
<li>Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用&lt;、&gt;和&gt;=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和&lt;&gt;的操作符中，不适合在&lt;或&gt;操作符中，也同样不适合用在order by子句中。</li>
</ul>
<h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p>CSV 存储引擎是基于 CSV 格式文件存储数据。</p>
<ul>
<li>CSV 存储引擎因为自身文件格式的原因，所有列必须强制指定 NOT NULL 。</li>
<li>CSV 引擎也不支持索引，不支持分区。</li>
<li>CSV 存储引擎也会包含一个存储表结构的 .frm 文件，还会创建一个 .csv 存储数据的文件，还会创建一个同名的元信息文件，该文件的扩展名为 .CSM ，用来保存表的状态及表中保存的数据量。</li>
<li>每个数据行占用一个文本行。</li>
</ul>
<p>因为 csv 文件本身就可以被Office等软件直接编辑，保不齐就有不按规则出牌的情况，如果出现csv 文件中的内容损坏了的情况，也可以使用 CHECK TABLE 或者 REPAIR TABLE 命令检查和修复</p>
<h3 id="ARCHIVE"><a href="#ARCHIVE" class="headerlink" title="ARCHIVE"></a>ARCHIVE</h3><p>Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。</p>
<h3 id="BLACKHOLE"><a href="#BLACKHOLE" class="headerlink" title="BLACKHOLE"></a>BLACKHOLE</h3><p>黑洞存储引擎，所有插入的数据并不会保存，BLACKHOLE 引擎表永远保持为空，写入的任何数据都会消失，</p>
<h3 id="PERFORMANCE-SCHEMA"><a href="#PERFORMANCE-SCHEMA" class="headerlink" title="PERFORMANCE_SCHEMA"></a>PERFORMANCE_SCHEMA</h3><p>主要用于收集数据库服务器性能参数。MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表，一般用于记录binlog做复制的中继。在这里有官方的一些介绍<a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema.html" target="_blank" rel="noopener">MySQL Performance Schema</a></p>
<h3 id="FEDERATED"><a href="#FEDERATED" class="headerlink" title="FEDERATED"></a>FEDERATED</h3><p>主要用于访问其它远程MySQL服务器一个代理，它通过创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，而后完成数据存取；在MariaDB的上实现是FederatedX</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>这里列举一些其它数据库提供的存储引擎，OQGraph、SphinxSE、TokuDB、Cassandra、CONNECT、SQUENCE。提供的名字仅供参考。</p>
<h2 id="常用引擎对比"><a href="#常用引擎对比" class="headerlink" title="常用引擎对比"></a>常用引擎对比</h2><p>不同存储引起都有各自的特点，为适应不同的需求，需要选择不同的存储引擎，所以首先考虑这些存储引擎各自的功能和兼容。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>MEMORY</th>
<th>ARCHIVE</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制(Storage limits)</td>
<td>64TB</td>
<td>No</td>
<td>YES</td>
<td>No</td>
</tr>
<tr>
<td>支持事物(Transactions)</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>锁机制(Locking granularity)</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>B树索引(B-tree indexes)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>T树索引(T-tree indexes)</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>哈希索引(Hash indexes)</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>全文索引(Full-text indexes)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>集群索引(Clustered indexes)</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>数据缓存(Data caches)</td>
<td>Yes</td>
<td>No</td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td>索引缓存(Index caches)</td>
<td>Yes</td>
<td>Yes</td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td>数据可压缩(Compressed data)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>加密传输(Encrypted data<sup>[1]</sup>)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>集群数据库支持(Cluster databases support)</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>复制支持(Replication support<sup>[2]</sup>)</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>外键支持(Foreign key support)</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>存储空间消耗(Storage Cost)</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
<td>非常低</td>
</tr>
<tr>
<td>内存消耗(Memory Cost)</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
<td>低</td>
</tr>
<tr>
<td>数据字典更新(Update statistics for data dictionary)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>备份/时间点恢复(backup/point-in-time recovery<sup>[3]</sup>)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>多版本并发控制(Multi-Version Concurrency Control/MVCC)</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>批量数据写入效率(Bulk insert speed)</td>
<td>慢</td>
<td>快</td>
<td>快</td>
<td>非常快</td>
</tr>
<tr>
<td>地理信息数据类型(Geospatial datatype support)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>地理信息索引(Geospatial indexing support<sup>[4]</sup>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<ol>
<li>在服务器中实现（通过加密功能）。在其他表空间加密数据在MySQL 5.7或更高版本兼容。</li>
<li>在服务中实现的，而不是在存储引擎中实现的。</li>
<li>在服务中实现的，而不是在存储引擎中实现的。</li>
<li>地理位置索引，InnoDB支持可mysql5.7.5或更高版本兼容</li>
</ol>
<h2 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h2><p>使用“SHOW VARIABLES LIKE ‘%storage_engine%’;” 命令在mysql系统变量搜索磨人设置的存储引擎，输入语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE '%storage_engine%';</span><br><span class="line">+<span class="comment">----------------------------------+---------+</span></span><br><span class="line">| Variable_name                    | Value   |</span><br><span class="line">|<span class="comment">----------------------------------+---------|</span></span><br><span class="line">| default_storage_engine           | InnoDB  |</span><br><span class="line">| default_tmp_storage_engine       | InnoDB  |</span><br><span class="line">| disabled_storage_engines         |         |</span><br><span class="line">| internal_tmp_disk_storage_engine | InnoDB  |</span><br><span class="line">+<span class="comment">----------------------------------+---------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span></span><br><span class="line"><span class="keyword">Time</span>: <span class="number">0.005</span>s</span><br></pre></td></tr></table></figure>
<p>使用“SHOW ENGINES;”命令显示安装以后可用的所有的支持的存储引擎和默认引擎，后面带上 \G 可以列表输出结果，你可以尝试一下如“SHOW ENGINES\G;”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINES;</span><br><span class="line">+<span class="comment">--------------------+---------+--------------------------------------+-------------+--------+-----------+</span></span><br><span class="line">| Engine             | Support | <span class="keyword">Comment</span>                              | Transactions| XA     | Savepoints|</span><br><span class="line">|<span class="comment">--------------------+---------+--------------------------------------+-------------+--------+-----------|</span></span><br><span class="line">| <span class="keyword">InnoDB</span>             | <span class="keyword">DEFAULT</span> | Supports transactions,               | YES         | YES    | YES       |</span><br><span class="line">|                    |         | <span class="keyword">row</span>-<span class="keyword">level</span> locking, <span class="keyword">and</span> foreign <span class="keyword">keys</span>  |             |        |           |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection <span class="keyword">of</span> identical MyISAM <span class="keyword">tables</span>| <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| <span class="keyword">MEMORY</span>             | YES     | <span class="keyword">Hash</span> based, <span class="keyword">stored</span> <span class="keyword">in</span> <span class="keyword">memory</span>, useful | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">|                    |         | <span class="keyword">for</span> <span class="keyword">temporary</span> <span class="keyword">tables</span>                 |             |        |           |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/<span class="literal">null</span> <span class="keyword">storage</span> <span class="keyword">engine</span> (anything   | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">|                    |         | you write <span class="keyword">to</span> it disappears)          |             |        |           |</span><br><span class="line">| MyISAM             | YES     | MyISAM <span class="keyword">storage</span> <span class="keyword">engine</span>                | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| CSV                | YES     | CSV <span class="keyword">storage</span> <span class="keyword">engine</span>                   | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| <span class="keyword">ARCHIVE</span>            | YES     | <span class="keyword">Archive</span> <span class="keyword">storage</span> <span class="keyword">engine</span>               | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | <span class="keyword">Performance</span> <span class="keyword">Schema</span>                   | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| FEDERATED          | <span class="keyword">NO</span>      | Federated MySQL <span class="keyword">storage</span> <span class="keyword">engine</span>       | &lt;<span class="literal">null</span>&gt;      | &lt;<span class="literal">null</span>&gt; | &lt;<span class="literal">null</span>&gt;    |</span><br><span class="line">+<span class="comment">--------------------+---------+--------------------------------------+-------------+--------+-----------+</span></span><br></pre></td></tr></table></figure>
<p>由上面命令输出，可见当前系统的默认数据表类型是InnoDB。当然，我们可以通过修改数据库配置文件中的选项，设定默认表类型。</p>
<h2 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h2><p>对上面数据库存储引擎有所了解之后，你可以在<code>my.cnf</code> 配置文件中设置你需要的存储引擎，这个参数放在 [mysqld] 这个字段下面的 default_storage_engine 参数值，例如下面配置的片段</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">default_storage_engine=CSV</span><br></pre></td></tr></table></figure>
<p>在创建表的时候，对表设置存储引擎，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span>     <span class="built_in">int</span>(<span class="number">100</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span>   <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`mobile`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'手机'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>在创建用户表 user 的时候，SQL语句最后 ENGINE=InnoDB 就是设置这张表存储引擎为 InnoDB。</p>
<h2 id="如何选择合适的存储引擎"><a href="#如何选择合适的存储引擎" class="headerlink" title="如何选择合适的存储引擎"></a>如何选择合适的存储引擎</h2><p>提供几个选择标准，然后按照标准，选择对应的存储引擎即可，也可以根据<a href="#常用引擎对比">常用引擎对比</a>来选择你使用的存储引擎。使用哪种引擎需要根据需求灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。</p>
<ol>
<li>是否需要支持事务；</li>
<li>是否需要使用热备；</li>
<li>崩溃恢复，能否接受崩溃；</li>
<li>是否需要外键支持；</li>
<li>存储的限制；</li>
<li>对索引和缓存的支持；</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/20/java集合框架-HashMap实现原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/20/java集合框架-HashMap实现原理分析/" itemprop="url">
                  java HashMap工作原理和实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-20 18:21:57" itemprop="dateCreated datePublished" datetime="2017-07-20T18:21:57+08:00">2017-07-20</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/20/java集合框架-HashMap实现原理分析/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/20/java集合框架-HashMap实现原理分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-HashMap的数据结构"><a href="#1-HashMap的数据结构" class="headerlink" title="1. HashMap的数据结构"></a>1. HashMap的数据结构</h2><p>JDK1.8之前数据结构是<strong>数组和链表</strong>来实现对数据的存储，但这两者基本上是两个极端。JDK1.8当链表长度大于阈值（默认为8），将链表转化为红黑树，减少搜索时间。</p>
<h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：<strong>寻址容易，插入和删除困难；</strong></p>
<h3 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h3><p>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O(N)。链表的特点是：<strong>寻址困难，插入和删除容易</strong>。</p>
<h3 id="1-3-哈希表"><a href="#1-3-哈希表" class="headerlink" title="1.3 哈希表"></a>1.3 哈希表</h3><p>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p>
<p>哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：<br><img src="http://oo501cyv7.bkt.clouddn.com/14847296397735.jpg" alt></p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14847296679116.jpg" alt></p>
<p>从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p>
<p>　　HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。</p>
<p>　　首先HashMap里面实现一个静态内部类<code>Entry</code>，其重要的属性有 <code>key , value, next</code>，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="line"> */</span><br><span class="line">transient Entry[] table;</span><br></pre></td></tr></table></figure>
<h2 id="2-HashMap的存取实现"><a href="#2-HashMap的存取实现" class="headerlink" title="2. HashMap的存取实现"></a>2. HashMap的存取实现</h2><p>既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 存储时:</span><br><span class="line">int hash = key.hashCode(); // 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">Entry[index] = value;</span><br><span class="line"></span><br><span class="line">// 取值时:</span><br><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">return Entry[index];</span><br></pre></td></tr></table></figure>
<h3 id="2-1-put"><a href="#2-1-put" class="headerlink" title="2.1 put"></a>2.1 put</h3><p>疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？<br>　　这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。到这里为止，HashMap的大致实现，我们应该已经清楚了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            return putForNullKey(value); //null总是放在数组的第一个链表中</span><br><span class="line">        int hash = hash(key.hashCode());</span><br><span class="line">        int i = indexFor(hash, table.length);</span><br><span class="line">        //遍历链表</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            //如果key在链表中已存在，则替换为新value</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); //参数e, 是Entry.next</span><br><span class="line">    //如果size超过threshold，则扩充table大小。再散列</span><br><span class="line">    if (size++ &gt;= threshold)</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p>
<h3 id="2-2-get"><a href="#2-2-get" class="headerlink" title="2.2 get"></a>2.2 get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            return getForNullKey();</span><br><span class="line">        int hash = hash(key.hashCode());</span><br><span class="line">        //先定位到数组元素，再遍历该元素处的链表</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != null;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-null-key的存取"><a href="#2-3-null-key的存取" class="headerlink" title="2.3 null key的存取"></a>2.3 null key的存取</h3><p>null key总是存放在Entry[]数组的第一个元素。</p>
<p>保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">            if (e.key == null) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(0, null, value, 0);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private V getForNullKey() &#123;</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">        if (e.key == null)</span><br><span class="line">            return e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-确定数组indexhashcode-tablelength取模"><a href="#2-4-确定数组indexhashcode-tablelength取模" class="headerlink" title="2.4 确定数组indexhashcode tablelength取模"></a>2.4 确定数组indexhashcode tablelength取模</h3><p>HashMap存取时，都需要计算当前key应该对应Entry[]数组哪个元素，即计算数组下标；算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns index for hash code h.</span><br><span class="line">     */</span><br><span class="line">    static int indexFor(int h, int length) &#123;</span><br><span class="line">        return h &amp; (length-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>按位取并，作用上相当于取模mod或者取余%。<br><strong>这意味着数组下标相同，并不表示hashCode相同。</strong></p>
<h3 id="2-5-table初始大小"><a href="#2-5-table初始大小" class="headerlink" title="2.5 table初始大小"></a>2.5 table初始大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        .....</span><br><span class="line">        // Find a power of 2 &gt;= initialCapacity</span><br><span class="line">        int capacity = 1;</span><br><span class="line">        while (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= 1;</span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        threshold = (int)(capacity * loadFactor);</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意table初始大小并不是构造函数中的initialCapacity！！</p>
<p>而是 &gt;= initialCapacity的2的n次幂！！！！</p>
<h2 id="3-解决hash冲突的办法"><a href="#3-解决hash冲突的办法" class="headerlink" title="3. 解决hash冲突的办法"></a>3. 解决hash冲突的办法</h2><ol>
<li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li>
<li>再哈希法</li>
<li><strong>链地址法</strong></li>
<li>建立一个公共溢出区</li>
</ol>
<p>Java中hashmap的解决办法就是采用的链地址法。</p>
<h2 id="4-再散列rehash过程"><a href="#4-再散列rehash过程" class="headerlink" title="4. 再散列rehash过程"></a>4. 再散列rehash过程</h2><p>当哈希表的容量超过默认容量时，必须调整table的大小。当容量已经达到最大可能值时，那么该方法就将容量调整到Integer.MAX_VALUE返回，这时，需要创建一张新表，将原表的映射到新表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Rehashes the contents of this map into a new array with a</span><br><span class="line">     * larger capacity.  This method is called automatically when the</span><br><span class="line">     * number of keys in this map reaches its threshold.</span><br><span class="line">     *</span><br><span class="line">     * If current capacity is MAXIMUM_CAPACITY, this method does not</span><br><span class="line">     * resize the map, but sets threshold to Integer.MAX_VALUE.</span><br><span class="line">     * This has the effect of preventing future calls.</span><br><span class="line">     *</span><br><span class="line">     * @param newCapacity the new capacity, MUST be a power of two;</span><br><span class="line">     *        must be greater than current capacity unless current</span><br><span class="line">     *        capacity is MAXIMUM_CAPACITY (in which case value</span><br><span class="line">     *        is irrelevant).</span><br><span class="line">     */</span><br><span class="line">    void resize(int newCapacity) &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        int oldCapacity = oldTable.length;</span><br><span class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Transfers all entries from current table to newTable.</span><br><span class="line">     */</span><br><span class="line">    void transfer(Entry[] newTable) &#123;</span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        int newCapacity = newTable.length;</span><br><span class="line">        for (int j = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                src[j] = null;</span><br><span class="line">                do &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    //重新计算index</span><br><span class="line">                    int i = indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next = newTable[i];</span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; while (e != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="noopener">HashMap实现原理分析</a></li>
<li><a href="http://www.cnblogs.com/chenssy/p/3521565.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3521565.html</a></li>
<li><a href="http://www.importnew.com/10620.html" target="_blank" rel="noopener">http://www.importnew.com/10620.html</a></li>
<li><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/09/Servlet的线程安全问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/09/Servlet的线程安全问题/" itemprop="url">
                  Servlet的线程安全问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-09 11:36:48" itemprop="dateCreated datePublished" datetime="2017-07-09T11:36:48+08:00">2017-07-09</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/09/Servlet的线程安全问题/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/09/Servlet的线程安全问题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了有效利用JVM允许多个线程访问同一个实例的特性，来提高服务器性能。在非分布式系统中，Servlet容器只会维护一个Servlet的实例。</p>
<blockquote>
<p>如果 Web 应用中的 Servlet 被标注为分布式的,容器应该为每一个分布式应用程序的 JVM 维护一个 Servlet 实例池。</p>
</blockquote>
<p>Servlet容器通过维护一个线程池来处理多个请求，线程池中维护的是一组工作者线程（Worker Thread）。Servlet容器通过一个调度线程（Dispatcher Thread）来调度线程池中的线程。</p>
<p>当客户端的servlet请求到来时，调度线程会从线程池中选出一个工作者线程并将请求传递给该线程，该线程就会执行对应servlet实例的service方法。同样，当客户端发起另一个servlet请求时，调度线程会从线程池中选出另一个线程去执行servlet实例的service方法。Servlet容器并不关心这些线程访问的是同一个servlet还是不同的servlet，当多个线程访问同一个servlet时，该servlet实例的service方法将在多个线性中并发执行。</p>
<p>所以，<strong>==Servlet对象是单实例多线程，Servlet不是线程安全的==</strong></p>
<h2 id="为什么不安全？"><a href="#为什么不安全？" class="headerlink" title="为什么不安全？"></a>为什么不安全？</h2><p>先看两个定义：<br><strong>实例变量</strong>：实例变量在类中定义。类的每一个实例都拥有自己的实例变量，如果多个线程同时访问该实例的方法，而该方法又使用到实例变量，那么这些线程同时访问的是同一个实例变量，会共享该实例变量。</p>
<p><strong>局部变量</strong>：局部变量在方法中定义。每当一个线程访问局部变量所在的方法时，在线程的堆栈中就会创建这个局部变量，线程执行完这个方法时，该局部变量就被销毁。所有多个线程同时访问该方法时，每个线程都有自己的局部变量，不会共享。</p>
<p>看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyServlet extends HttpServlet&#123;</span><br><span class="line"> private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line"> private String userName1 = null;//实例变量</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void doGet(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">         throws ServletException, IOException&#123;</span><br><span class="line">  userName1 = req.getParameter(&quot;userName1&quot;);</span><br><span class="line"></span><br><span class="line">  String userName2 = req.getParameter(&quot;userName2&quot;);//局部变量</span><br><span class="line"></span><br><span class="line">  //TODO 其他处理</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>userName1则是共享变量，多个线程会同时访问该变量，是线程不安全的。</p>
<p>userName2是局部变量，不管多少个线程同时访问，都是线程安全的。</p>
<h2 id="解决Servlet的线程安全问题"><a href="#解决Servlet的线程安全问题" class="headerlink" title="解决Servlet的线程安全问题"></a>解决Servlet的线程安全问题</h2><p>如果不涉及到全局共享变量，就直接使用局部变量</p>
<p>如果使用到全局共享的场景，可以使用加锁的方式.对全局变量的读写操作置于synchronized同步块中，这样不同线程排队依次执行该代码块，从而避免线程不安全情况发生。还可以使用线程安全的数据类型。比如hashtable,blockQueue等</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.hollischuang.com/archives/849" target="_blank" rel="noopener">Servlet 3.1规范学习笔记（一）——Servlet生命周期和线程安全性问题</a></li>
<li><a href="http://www.charlestech.info/2014/04/13/servlet-thread-security/" target="_blank" rel="noopener">Servlet的线程安全问题</a></li>
<li><a href="http://haoran-10.iteye.com/blog/2245065" target="_blank" rel="noopener">java servlet拾遗（3）-servlet 线程安全问题</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/09/Servlet开发实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/09/Servlet开发实战/" itemprop="url">
                  Servlet开发实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-09 11:36:32" itemprop="dateCreated datePublished" datetime="2017-07-09T11:36:32+08:00">2017-07-09</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/09/Servlet开发实战/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/09/Servlet开发实战/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Web框架是开发者在使用某种语言编写Web应用服务端时关于架构的最佳实践。很多Web框架是从实际的Web项目抽取出来的，仅和Web的请求和响应处理有关，形成一个基础，在开发别的应用项目的时候则可以从这个剥离出来的基础做起，让开发者更关注更具体的业务问题，而不是Web的请求和响应的控制。 </p>
<p>框架很多，但套路基本类似，帮你隐藏很多关于 HTTP 协议细节内容，专注功能开发。 </p>
<p>但对一个初学者来说，过早的接触框架往往是事倍功半！同样一个问题，换一种框架你可能需要从头开始研究。 </p>
<p>下面是针对初学 Java 开发 Web 过程一些个人见解和思路，高手可略过。</p>
<p>然后将下面 XML 内容替换 Tomcat 下的 conf/server.xml 文件： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;</span><br><span class="line">Server&quot;8005&quot;shutdown&quot;SHUTDOWN&quot;</span><br><span class="line">  Service&quot;Catalina&quot;</span><br><span class="line">    Connector&quot;8080&quot;protocol&quot;HTTP/1.1&quot;connectionTimeout&quot;20000&quot;redirectPort&quot;8443&quot;URIEncoding&quot;UTF-8&quot;/&gt;</span><br><span class="line">    Engine&quot;Catalina&quot;defaultHost&quot;localhost&quot;</span><br><span class="line">      &quot;localhost&quot;</span><br><span class="line">    ContextdocBase&quot;D:\WORKDIR\ServletDemo\webapp&quot;reloadable&quot;true&quot;/&gt;</span><br><span class="line">      &lt;/</span><br><span class="line">    &lt;/Engine</span><br><span class="line">  &lt;/Service</span><br><span class="line">&lt;/Server</span><br></pre></td></tr></table></figure>
<p>再次启动 Tomcat 后在浏览器打开 <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 便可看到 Hello World 的输出信息。</p>
<h2 id="了解-Servlet-和-Filter"><a href="#了解-Servlet-和-Filter" class="headerlink" title="了解 Servlet 和 Filter"></a>了解 Servlet 和 Filter</h2><p>好了，我已经把环境搭起来了，接下来该干嘛呢？</p>
<p>前面的步骤为的是搭建一个测试的环境，然后让你了解一个最基本的 Java Web 项目的结构。</p>
<p>一个最基本的 Java Web 项目所需的 jar 包只需要一个 servlet-api.jar ，这个 jar 包中的类大部分都是接口，还有一些工具类，共有 2 个包，分别是 javax.servlet 和 javax.servlet.http。我把这个jar包放到了 webapp 目录外的一个独立 packages 文件夹里，这是因为所有的 Servlet 容器都带有这个包，你无需再放到Web项目里，我们放到这里只不过是编译的需要，运行是不需要的。如果你硬是把 servlet-api.jar 放到 webapp/WEB-INF/lib 目录下，那么 Tomcat 启动时还会报一个警告信息。</p>
<p>Java Web 项目还需要一个非常重要的配置文件 web.xml ，在这个项目中已经被我最小化了，只保留有用的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; </span><br><span class="line">	&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line"></span><br><span class="line">	&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">		&lt;servlet-class&gt;demo.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">	&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">	&lt;servlet-mapping&gt;</span><br><span class="line">		&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">		&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">	&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<p>每个 servlet 都必须在 web.xml 中定义并进行 URL 映射配置，早期 Java 开发 Web 在没有框架满天飞的时候，这个文件会定义了大量的 servlet，或者有人为了省事干脆来一个 /servlet/* 来通过类名直接调用 Servlet。</p>
<p>Servlet 规范里还有另外一个非常重要而且非常有用的接口那就是 Filter 过滤器。</p>
<p>下面是一个最简单的 Filter 类以及相应的定义方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package demo;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">public class HelloFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void init(FilterConfig arg0) throws ServletException &#123;</span><br><span class="line">		System.out.println(&quot;Filter 初始化&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void doFilter(ServletRequest req, ServletResponse res,</span><br><span class="line">			FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">		HttpServletRequest request = (HttpServletRequest)req;</span><br><span class="line">		System.out.println(&quot;拦截 URI=&quot;+request.getRequestURI());</span><br><span class="line">		chain.doFilter(req, res);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		System.out.println(&quot;Filter 结束&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 web.xml 中的配置必须放在 Servlet 的前面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; </span><br><span class="line">						 &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line"></span><br><span class="line">	&lt;filter&gt;</span><br><span class="line">		&lt;filter-name&gt;helloFilter&lt;/filter-name&gt;</span><br><span class="line">		&lt;filter-class&gt;demo.HelloFilter&lt;/filter-class&gt;</span><br><span class="line">	&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">	&lt;filter-mapping&gt;</span><br><span class="line">		&lt;filter-name&gt;helloFilter&lt;/filter-name&gt;</span><br><span class="line">		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">	&lt;/filter-mapping&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">		&lt;servlet-class&gt;demo.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">	&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">	&lt;servlet-mapping&gt;</span><br><span class="line">		&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">		&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">	&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<p>访问 <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 时看看 Tomcat 控制台有何输出信息。</p>
<h2 id="Servlet-和-HTTP-的对应关系"><a href="#Servlet-和-HTTP-的对应关系" class="headerlink" title="Servlet 和 HTTP 的对应关系"></a>Servlet 和 HTTP 的对应关系</h2><p>Servlet 是 J2EE 最重要的一部分，有了 Servlet 你就是 J2EE 了，J2EE 的其他方面的内容择需采用。而 Servlet 规范你需要掌握的就是 servlet 和 filter 这两项技术。绝大多数框架不是基于 servlet 就是基于 filter，如果它要在 Servlet 容器上运行，就永远也脱离不开这个模型。</p>
<p>为什么 Servlet 规范会有两个包，javax.servlet 和 javax.servlet.http ，早先设计该规范的人认为 Servlet 是一种服务模型，不一定是依赖某种网络协议之上，因此就抽象出了一个 javax.servlet ，同时在提供一个基于 HTTP 协议上的接口扩展。但是从实际运行这么多年来看，似乎没有发现有在其他协议上实现的 Servlet 技术。</p>
<p>javax.servlet 和 javax.servlet.http 这两个包总共加起来也不过是三十四个接口和类。你需要通过 J2EE 的 JavaDoc 文档 熟知每个类和接口的具体意思。特别是下面几个接口必须熟知每个方法的意思和用途：</p>
<ul>
<li>HttpServlet</li>
<li>ServetConfig</li>
<li>ServletContext</li>
<li>Filter</li>
<li>FilterConfig</li>
<li>FilterChain</li>
<li>RequestDispatcher</li>
<li>HttpServletRequest</li>
<li>HttpServletResponse</li>
<li>HttpSession</li>
<li>一些 Listenser 类</li>
</ul>
<p>再次强调 HttpServletRequest 和 HttpServletResponse 这两个接口更应该是烂熟于心。</p>
<p>如果你从字面上无法理解某个方法的意思，你可以在前面那个项目的基础上做实验看看其输出，再不行你可以到讨论区提问，这样的提问非常明确，很多人都可以帮到你。</p>
<p>为什么我这么强调 HttpServletRequest 和 HttpServletResponse 这两个接口，因为 Web 开发是离不开 HTTP 协议的，而 Servlet 规范其实就是对 HTTP 协议做面向对象的封装，HTTP协议中的请求和响应就是对应了 HttpServletRequest 和 HttpServletResponse 这两个接口。</p>
<p>你可以通过 HttpServletRequest 来获取所有请求相关的信息，包括 URI、Cookie、Header、请求参数等等，别无它路。因此当你使用某个框架时，你想获取HTTP请求的相关信息，只要拿到 HttpServletRequest 实例即可。</p>
<p>而 HttpServletResponse接口是用来生产 HTTP 回应，包含 Cookie、Header 以及回应的内容等等。</p>
<h2 id="再谈谈-Session"><a href="#再谈谈-Session" class="headerlink" title="再谈谈 Session"></a>再谈谈 Session</h2><p>HTTP 协议里是没有关于 Session 会话的定义，Session 是各种编程语言根据 HTTP 协议的无状态这种特点而产生的。其实现无非就是服务器端的一个哈希表，哈希表的Key就是传递给浏览器的名为 jsessionid 的 Cookie 值。</p>
<p>当需要将某个值保存到 session 时，容器会执行如下几步：</p>
<p>a. 获取 jsessionid 值，没有的话就生成一个，也就是 request.getSession() 这个方法<br>b. 拿到的 HttpSession 对象实例就相当于一个哈希表，你可以往哈希表里存放数据(setAttribute)<br>c. 你也可以通过 getAttribute 来获取某个值</p>
<p>而这个名为 jsessionid 的 Cookie 在浏览器关闭时会自动删除。把 Cookie 的 MaxAge 值设为 -1 就能达到浏览器关闭自动删除的效果。</p>
<h2 id="关于-JSP"><a href="#关于-JSP" class="headerlink" title="关于 JSP"></a>关于 JSP</h2><p>任何一个 JSP 页面在执行的时候都会编译成一个 Servlet 类文件，如果是 Tomcat 的话，这些生成的 java 文件会放置在 {TOMCAT}/work 目录下对应项目的子目录中，例如 Tomcat 生成的类文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.jsp;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import javax.servlet.jsp.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public final class test_jsp extends org.apache.jasper.runtime.HttpJspBase</span><br><span class="line">    implements org.apache.jasper.runtime.JspSourceDependent &#123;</span><br><span class="line"></span><br><span class="line">  private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();</span><br><span class="line"></span><br><span class="line">  private static java.util.List&lt;String&gt; _jspx_dependants;</span><br><span class="line"></span><br><span class="line">  private javax.el.ExpressionFactory _el_expressionfactory;</span><br><span class="line">  private org.apache.tomcat.InstanceManager _jsp_instancemanager;</span><br><span class="line"></span><br><span class="line">  public java.util.List&lt;String&gt; getDependants() &#123;</span><br><span class="line">    return _jspx_dependants;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspInit() &#123;</span><br><span class="line">    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();</span><br><span class="line">    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspDestroy() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspService(final HttpServletRequest request, final HttpServletResponse response)</span><br><span class="line">        throws java.io.IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    final PageContext pageContext;</span><br><span class="line">    HttpSession session = null;</span><br><span class="line">    final ServletContext application;</span><br><span class="line">    final ServletConfig config;</span><br><span class="line">    JspWriter out = null;</span><br><span class="line">    final Object page = this;</span><br><span class="line">    JspWriter _jspx_out = null;</span><br><span class="line">    PageContext _jspx_page_context = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">      pageContext = _jspxFactory.getPageContext(this, request, response,</span><br><span class="line">      			null, true, 8192, true);</span><br><span class="line">      _jspx_page_context = pageContext;</span><br><span class="line">      application = pageContext.getServletContext();</span><br><span class="line">      config = pageContext.getServletConfig();</span><br><span class="line">      session = pageContext.getSession();</span><br><span class="line">      out = pageContext.getOut();</span><br><span class="line">      _jspx_out = out;</span><br><span class="line"></span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;html&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;    &lt;title&gt;Test&lt;/title&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;    &lt;style&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;    &lt;/style&gt; \r\n&quot;);</span><br><span class="line">      out.write(&quot;  &lt;body&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;h1&gt;Test Demo (oschina)&lt;/h1&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;table cellspacing=\&quot;1\&quot; cellpadding=\&quot;5\&quot;&gt;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">Enumeration Names=request.getHeaderNames();</span><br><span class="line">while(Names.hasMoreElements())</span><br><span class="line">&#123;String name=(String)Names.nextElement();</span><br><span class="line">String value=request.getHeader(name);</span><br><span class="line"> </span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot; &lt;tr&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot; &lt;td&gt;&quot;);</span><br><span class="line">      out.print(name);</span><br><span class="line">      out.write(&quot;&lt;/td&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;  &lt;td&gt;&quot;);</span><br><span class="line">      out.print(value);</span><br><span class="line">      out.write(&quot;&lt;/td&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot; \r\n&quot;);</span><br><span class="line">      out.write(&quot; &lt;/tr&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot; &quot;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;/table&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;  &lt;/body&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">      if (!(t instanceof SkipPageException))&#123;</span><br><span class="line">        out = _jspx_out;</span><br><span class="line">        if (out != null &amp;&amp; out.getBufferSize() != 0)</span><br><span class="line">          try &#123; out.clearBuffer(); &#125; catch (java.io.IOException e) &#123;&#125;</span><br><span class="line">        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _jspxFactory.releasePageContext(_jspx_page_context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 servlet 中有一个包 javax.servlet.jsp 是跟 JSP 相关的一些接口规范定义。JSP 比 Servlet 方便的地方在于可直接修改立即生效，不像 Servlet 修改后必须重启容器才能生效。</p>
<p>因此 JSP 适合用来做视图，而 Servlet 则适合做控制层。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>罗哩罗嗦一大堆，归纳一下就是下面几点：</p>
<p>熟知 Servlet 规范之前，请不要学习任何框架<br>使用最简单的工具，不要任何向导和可视化<br>熟知 HTTP 协议<br>等你真的掌握了 Servlet 规范再去看框架，便会觉得一些都小菜。总之一点：不要被框架牵着鼻子走，框架是你的工具，它应该听你的！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.oschina.net/question/12_52027" target="_blank" rel="noopener">初学 Java Web 开发，请远离各种框架，从 Servlet 开发</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/09/Servlet生命周期和工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/09/Servlet生命周期和工作原理/" itemprop="url">
                  Servlet生命周期和工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-09 11:36:11" itemprop="dateCreated datePublished" datetime="2017-07-09T11:36:11+08:00">2017-07-09</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/09/Servlet生命周期和工作原理/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/09/Servlet生命周期和工作原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>名词解释：</p>
<ul>
<li>web.xml = 部署描述符（Deployment Descriptor ）</li>
<li>容器 = Servlet Container/Engine</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>主要有四个过程：init-&gt;service-&gt;doGet/doPost-&gt;destory</p>
<p>第一步：加载和实例化</p>
<ol>
<li>Servlet容器启动时自动装载某些Servlet，实现它只需要在web.XML文件中的<code>&lt;Servlet&gt;&lt;/Servlet&gt;</code>之间添加如下代码：<br><code>&lt;loadon-startup&gt;1&lt;/loadon-startup&gt;</code></li>
<li>在Servlet容器启动后，客户首次向Servlet发送请求</li>
<li>Servlet类文件被更新后，重新装载Servlet</li>
</ol>
<p>Servlet被装载后，Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化。在Servlet的整个生命周期内，init()方法只被调用一次。</p>
<p>第二步：初始化 </p>
<p>实例化后会立马进行初始化，并传递实现ServletConfig接口的对象。也就是执行init方法。在init（）方法中，Servlet可以部署描述符中读取配置参数，或者执行任何其他一次性活动。在Servlet的整个生命周期类，init（）方法只被调用一次。</p>
<p>第三步：请求处理</p>
<p>初始化后，Servlet就可以接受请求了。<br>基本方式是执行Servlet接口中的service方法。并把请求和响应对象作为参数传递。当并行的请求到来时，多个service（）方法能够同时运行在独立的线程中。<br>service()方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet()、doPost()、doPut()，doDelete() 等方法。<br>当然，API也提供了HttpServlet抽象类，其中有doGet、doPost等特殊方法。<br>注意：任意的容器按照规范必须实现上述几种方法，所以你的代码写在这几个方法中都可以。</p>
<p>第四步：终止服务</p>
<p>容器会在合适的时候销毁某个Servlet对象，这个策略取决于容器的开发者/商。<br>在容器关闭的时候Servlet对象一定会被销毁。<br>当1或2发生时，也就是Servlet对象被销毁时，destroy方法会被调用</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14995681398150.png" alt></p>
<p>PS:<strong>Servlet的生命（周期）是由容器管理的，换句话说，Servlet程序员不能用代码控制其生命。</strong></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>首先简单解释一下Servlet接收和响应客户请求的过程，首先客户发送一个请求，Servlet是调用service()方法对请求进行响应的，通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet,doPost等这些方法，然后再进入对应的方法中调用逻辑层的方法，实现对客户的响应。在Servlet接口和GenericServlet中是没有doGet,doPost等等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息，所以，我们每次定义一个Servlet的时候，都必须实现doGet或doPost等这些方法。</p>
<p>每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。所以我们定义Servlet的时候只需要继承HttpServlet即可。</p>
<p>Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类，所以HttpServlet中实现了service()方法，并将请求ServletRequest,ServletResponse强转为HttpRequest和HttpResponse。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void service(ServletRequest req,ServletResponse res) </span><br><span class="line">  throws ServletException,IOException</span><br><span class="line">&#123;</span><br><span class="line">      HttpRequest request;</span><br><span class="line">      HttpResponse response;</span><br><span class="line"> </span><br><span class="line">     try</span><br><span class="line">     &#123;</span><br><span class="line">         req = (HttpRequest)request;</span><br><span class="line">         res = (HttpResponse)response;</span><br><span class="line">      &#125;catch(ClassCastException e)</span><br><span class="line">      &#123;</span><br><span class="line">         throw new ServletException(&quot;non-HTTP request response&quot;); </span><br><span class="line">      &#125;</span><br><span class="line">      service(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的最后调用了HTTPServlet自己的service(request,response)方法，然后根据请求去调用对应的doXXX方法，因为HttpServlet中的doXXX方法都是返回错误信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest res,HttpServletResponse resp)</span><br><span class="line">  throws ServletException,IOException</span><br><span class="line">&#123;</span><br><span class="line">   String protocol = req.getProtocol();</span><br><span class="line">   String msg = IStrings.getString(&quot;http.method_get_not_supported&quot;);</span><br><span class="line">   if(protocol.equals(&quot;1.1&quot;))</span><br><span class="line">   &#123;</span><br><span class="line">      resp.sendError(HttpServletResponse.SC.METHOD.NOT.ALLOWED,msg);</span><br><span class="line">    &#125;</span><br><span class="line">   esle</span><br><span class="line">    &#123;</span><br><span class="line">      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以需要我们在自定义的Servlet中override这些方法！</p>
<h3 id="Servlet响应请求阶段"><a href="#Servlet响应请求阶段" class="headerlink" title="Servlet响应请求阶段"></a>Servlet响应请求阶段</h3><p>对于用户到达Servlet的请求，Servlet容器会创建特定于这个请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service方法。service方法从ServletRequest对象获得客户请求信息，处理该请求，并通过ServletResponse对象向客户返回响应信息。</p>
<p>对于Tomcat来说，它会将传递过来的参数放在一个Hashtable中，该Hashtable的定义是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Hashtable&lt;String String[]&gt; paramHashStringArray = new Hashtable&lt;String String[]&gt;();</span><br></pre></td></tr></table></figure>
<p>这是一个String–&gt;String[]的键值映射。</p>
<p>HashMap线程不安全的，Hashtable线程安全。</p>
<h3 id="Servlet终止阶段"><a href="#Servlet终止阶段" class="headerlink" title="Servlet终止阶段"></a>Servlet终止阶段</h3><p>当WEB应用被终止，或Servlet容器终止运行，或Servlet容器重新装载Servlet新实例时，Servlet容器会先调用Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。</p>
<h3 id="Servlet何时被创建"><a href="#Servlet何时被创建" class="headerlink" title="Servlet何时被创建"></a>Servlet何时被创建</h3><ol>
<li><p>默认情况下，当WEB客户第一次请求访问某个Servlet的时候，WEB容器将创建这个Servlet的实例。</p>
</li>
<li><p>当web.xml文件中如果<servlet>元素中指定了<load-on-startup>子元素时，Servlet容器在启动web服务器时，将按照顺序创建并初始化Servlet对象。</load-on-startup></servlet></p>
</li>
</ol>
<p>注意：在web.xml文件中，某些Servlet只有<serlvet>元素，没有<servlet-mapping>元素，这样我们无法通过url的方式访问这些Servlet，这种Servlet通常会在<servlet>元素中配置一个<load-on-startup>子元素，让容器在启动的时候自动加载这些Servlet并调用init()方法，完成一些全局性的初始化工作。</load-on-startup></servlet></servlet-mapping></serlvet></p>
<h3 id="Web应用何时被启动"><a href="#Web应用何时被启动" class="headerlink" title="Web应用何时被启动"></a>Web应用何时被启动</h3><ol>
<li>当Servlet容器启动的时候，所有的Web应用都会被启动</li>
<li>控制器启动web应用</li>
</ol>
<h2 id="JSP运行原理"><a href="#JSP运行原理" class="headerlink" title="JSP运行原理"></a>JSP运行原理</h2><p>当Web服务器上的JSP页面第一次被请求执行时，JSP引擎先将JSP页面文件转译成一个Java文件，即Servlet，Java Servlet是基于服务器端编程的API，用Java Servlet编写的Java程序称为servlet，servlet通过HTML与客户交互。服务器将前面转译成的Java文件编译成字节码文件，再执行这个字节码文件来响应客户的请求。当这个JSP页面再次被请求时，只要该JSP文件没有被改动，JSP引擎就直接调用已装载的Servlet。</p>
<p>JSP工作原理<br>所有JSP页面，在执行的时候都会被服务器端的JSP引擎转换为Servelet（.java），然后又由JSP引擎调用Java编译器，将Servelet（.java）编译为Class文件（.class），并由Java虚拟机（JVM）解释执行。下面验证这一点：<br>有一个JSP页面Test.jsp，在浏览器地址栏中输入<a href="http://localhost:8080/Test.jsp" target="_blank" rel="noopener">http://localhost:8080/Test.jsp</a> ,将会出现执行结果。同时在%CATALINA_HOME%/work/Catalina/localhost下多出两个文件：_Test_jsp.java和_Test_jsp.class，他们分别就是Servelet和Class文件</p>
<h2 id="JSP和servlet的运行原理探讨"><a href="#JSP和servlet的运行原理探讨" class="headerlink" title="JSP和servlet的运行原理探讨"></a>JSP和servlet的运行原理探讨</h2><p>&lt;%page language=”java”%&gt;在服务器端执行.<br>客户端用户填写 HTML 表单，发送请求。将请求发送给 服务器端servlet(tomcat是servlet的容器)。 servlet 将该 HTTP 请求转换成一个 MQSeries 消息，并将其放入一个队列。 后端应用程序处理该消息，然后通过消息队列发回一个应答。 servlet 从队列中检索消息，并将其存放在一个 Java Bean 中。 然后 servlet 调用编译过的 Java Server Page(JSP) 并动态生成结果 HTML 页面。 JSP 从 Java Bean 检索出该页面需要的数据，将其合并到 HTML，然后将结果页面发送给客户端。</p>
<p>JSP中的html代码和javascrīpt代码不会在服务器端执行，servlet 调用编译过的 Java Server Page(JSP) ，也就是运行由JSP编译成的class文件(运行的代码包括actionBean,formBean,一般的bean 和内嵌在JSP的Java代码).</p>
<p>一个Web运行程序（网站）可以有多个servlet，一般认为一个action就是一个servlet.</p>
<p>所谓Servlet是指运行在服务器端的Java小程序。用于响应客户端的请求。在默认情况下，Servlet采用一种无状态的请求-响应处理方式。Servlet代码的主要作用是为了增强Java服务器端的功能，它运行在服务器端，用于接收并且处理浏览器客户端发出的请求，该请求是通过配置文件web.xml的相关配置进行转发。也就是说Servlet是一个标准的Java类，它符合Java类的一般规则。和一般的Java类不同之处只是在于Servlet可以处理Http请求。</p>
<ol>
<li>servlet是持久的。servlet只需Web服务器加载一次,后续又用到这个servlet，就不需要再加载。(所谓加载是指servlet加载进JVM运行)</li>
<li>servlet是与平台无关的。</li>
<li>servlet是可扩展的。</li>
</ol>
<h2 id="Servlet与JSP的比较"><a href="#Servlet与JSP的比较" class="headerlink" title="Servlet与JSP的比较"></a>Servlet与JSP的比较</h2><ul>
<li>有许多相似之处，都可以生成动态网页。</li>
<li>JSP的优点是擅长于网页制作，生成动态页面比较直观，缺点是不容易跟踪与排错。</li>
<li>Servlet是纯Java语言，擅长于处理流程和业务逻辑，缺点是生成动态网页不直观。</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://blog.csdn.net/u010297957/article/details/51498018" target="_blank" rel="noopener">Servlet的历史与规范</a></li>
<li><a href="http://www.hollischuang.com/archives/849" target="_blank" rel="noopener">Servlet 3.1规范学习笔记（一）——Servlet生命周期和线程安全性问题</a></li>
<li><a href="http://www.cnblogs.com/cuiliang/archive/2011/10/21/2220671.html" target="_blank" rel="noopener">Servlet生命周期与工作原理</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/09/Servlet容器详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/09/Servlet容器详解/" itemprop="url">
                  Servlet容器详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-09 11:34:54" itemprop="dateCreated datePublished" datetime="2017-07-09T11:34:54+08:00">2017-07-09</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/09/Servlet容器详解/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/09/Servlet容器详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是-Servlet-容器？"><a href="#什么是-Servlet-容器？" class="headerlink" title="什么是 Servlet 容器？"></a>什么是 Servlet 容器？</h2><p>容器就是你的程序运行时需要的环境。<br>Servlet Container（Servlet 容器） 是 Web 服务器或者应用服务器的一部分，用于提供基于请求/响应发送模式的网络服务，解码基于 MIME 的请求，并且格式化基于 MIME 的响应。Servlet 容器同时也包含和管理他们的生命周期里Servlet。</p>
<p>Servlet容器可以嵌入到宿主的 Web 服务器中，或者通过 Web 服务器的本地扩展 API 单独作为附加组件安装。Servelt 容器也可能内嵌或安装到启用 Web 功能的应用服务器中。</p>
<p>所有的 Servlet 容器必须支持 HTTP 协议用于请求和响应，但额外的基于 请求/响应 的协议，如 HTTPS (HTTP over SSL)的支持是可选的。对于 HTTP 规范需要版本，容器必须支持 HTTP/1.0 和 HTTP/1.1。因为容器或许支持 RFC2616 (HTTP/1.1)描述的缓存机制，缓存机制可能在将客户端请求交给 Servlet 处理之前修改它们，也可能在将 Servlet 生成的响应发送给客户端之前修改它们，或者可能根据 RFC2616 规范直接对请求作出响应而不交给 Servlet 进行处理。</p>
<p>Servlet 容器应该使 Servlet 执行在一个安全限制的环境中。在 Java 平台标准版（J2SE, v.1.3 或更高） 或者 Java平台企业版(Java EE, v.1.3 或更高) 的环境下，这些限制应该被放置在 Java 平台定义的安全许可架构中。比如，高端的应用服务器为了保证容器的其他组件不受到负面影响可能会限制 Thread 对象的创建。</p>
<p>Java SE 7 是构建 Servlet 容器最低的 Java平 台版本。</p>
<h2 id="常见的Servlet容器"><a href="#常见的Servlet容器" class="headerlink" title="常见的Servlet容器"></a>常见的Servlet容器</h2><p>Tomcat，apache,Jetty是Servlet的运行环境，即一个Servlet容器,做过java web开发的应该都知道。 </p>
<h2 id="Servlet的执行流程"><a href="#Servlet的执行流程" class="headerlink" title="Servlet的执行流程"></a>Servlet的执行流程</h2><ol>
<li>Servlet容器的作用是负责处理客户请求，当客户请求来到时，Servlet容器获取请求，然后调用某个Servlet，并把Servlet的执行结果返回给客户</li>
<li>Servlet容器的工作过程是：当客户请求某个资源时，Servlet容器使用ServletRequest对象把客户的请求信息封装起来，然后调用java Servlet API中定义的Servlet的一些生命周期方法，完成Servlet的执行，接着把Servlet执行的要返回给客户的结果封装到 ServletResponse对象中，最后Servlet容器把客户的请求发送给客户，完成为客户的一次服务过程。每一个Servlet的类都执行 init（）、service（）、destory（）三个函数的自动调用，在启动时调用一次init（）函数用以进行参数的初始化，在服务期间每当接收到对该Servlet的请求时都会调用Service（）函数执行该Servlet的服务操作，当容器销毁时调用一次destory（）函数。 </li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/08/Servlet的概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/08/Servlet的概述/" itemprop="url">
                  Servlet的概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-08 21:51:05" itemprop="dateCreated datePublished" datetime="2017-07-08T21:51:05+08:00">2017-07-08</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/08/Servlet的概述/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/08/Servlet的概述/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是Servlet？"><a href="#什么是Servlet？" class="headerlink" title="什么是Servlet？"></a>什么是Servlet？</h2><p>servlet 是基于 Java 的 Web 组件，由容器（Servlet容器）进行管理，来生成动态内容。像其他基于 Java 的组件技术一样，servlet 也是基于平台无关的 Java 类格式，被编译为平台无关的字节码，可以被基于 Java 技术的 Web 服务器动态加载并运行。容器（Container），有时候也叫做 servlet 引擎，是 Web 服务器为支持 servlet 功能扩展的部分。客户端通过 servlet 容器实现的 request/response paradigm（请求/应答模式） 与 Servlet 进行交互。</p>
<h2 id="Servlet与其他技术的对比"><a href="#Servlet与其他技术的对比" class="headerlink" title="Servlet与其他技术的对比"></a>Servlet与其他技术的对比</h2><p>从功能上看，servlet 位于Common Gateway Interface（公共网关接口，简称 CGI）程序和私有的服务器扩展如 Netscape Server API（NSAPI）或 Apache Modules 这两者之间。<br>相对于其他服务器扩展机制 Servlet 有如下优势：</p>
<ul>
<li>它们通常比 CGI 脚本更快，因为采用不同的处理模型。</li>
<li>它们采用标准的 API 从而支持更多的Web 服务器。</li>
<li>它们拥有 Java 编程语言的所有优势，包括容易开发和平台无关。</li>
<li>它们可以访问 Java 平台提供的大量的 API。</li>
</ul>
<h2 id="Servlet的历史"><a href="#Servlet的历史" class="headerlink" title="Servlet的历史"></a>Servlet的历史</h2><h3 id="Servlet的由来"><a href="#Servlet的由来" class="headerlink" title="Servlet的由来"></a>Servlet的由来</h3><ul>
<li>背景<br>上世纪90年代，随着Internet和浏览器的飞速发展，基于浏览器的B/S模式随之火爆发展起来。<br>最初，用户使用浏览器向WEB服务器发送的请求都是请求静态的资源，比如html、css等。<br>但是可以想象：根据用户请求的不同动态的处理并返回资源是理所当然必须的要求。</li>
<li><p>CGI （现在几乎不用了）<br>必须要满足上述需求，所以CGI（Common Gateway Interface）出现了。CGI程序使用C、Shell Script或Perl编写，CGI是为特定操作系统编写的（如UNIX或Windows），不可移植，CGI程序对每个请求产生新的进程去处理。步骤如下：</p>
<ol>
<li>WEB服务器接收一个用户请求；</li>
<li>WEB服务器将请求转交给CGI程序处理；</li>
<li>CGI程序将处理结果返回给WEB服务器；</li>
<li>WEB服务器把结果送回用户； </li>
</ol>
</li>
<li><p>Java<br>与此同时，Java语言也在迅速发展。必然的，Java要支持上述需求。<br>Java有两种方案来实现动态需求，它们都属于JavaEE技术的一部分。</p>
</li>
</ul>
<ol>
<li>applet （中文意思：小程序）<br>这是纯客户端（浏览器）方案（基本被flash、ajax和HTMLL5替代），applet就是浏览器中的Java插件，浏览器通过它就能够解释执行WEB服务器发过来的Java代码，从而实现动态。但是，显然这种方案不好，既需要浏览器必须安装插件，又受限于浏览器，所以Java代码不能太多和太复杂。<br>比如，如果安装了JRE，虽然IE浏览器会自动启用Java插件，但是你可以轻易禁止。再比如Chrome还需要你手动去安装插件才行，普通用户连Java是什么都不知道他怎么会去装呢？<br>IE如下图：<br><img src="http://oo501cyv7.bkt.clouddn.com/14995213644794.png" alt></li>
<li>Servlet<br>既然浏览器不方便执行Java代码，那自然还是服务端来执行了，所以Servlet出现了，Servlet就是server端的applet的意思。</li>
</ol>
<h3 id="Servlet的工作原理概述"><a href="#Servlet的工作原理概述" class="headerlink" title="Servlet的工作原理概述"></a>Servlet的工作原理概述</h3><p>其实Servlet的工作原理基本类似上面的CGI，不过Servlet比CGI更好。</p>
<ol>
<li><p>WEB服务器接收一个用户请求；</p>
</li>
<li><p>WEB服务器将请求转交给WEB服务器关联的Servlet容器；</p>
</li>
<li><p>Servlet容器找到对应的Servlet并执行这个Servlet；</p>
</li>
<li><p>Servlet容器将处理结果返回给WEB服务器；</p>
</li>
<li><p>WEB服务器把结果送回用户；</p>
</li>
</ol>
<h3 id="Servlet的发展"><a href="#Servlet的发展" class="headerlink" title="Servlet的发展"></a>Servlet的发展</h3><ol>
<li><p>Servlet诞生后，SUN公司很快发现了Servlet编程非常繁琐，这是因为：</p>
<ul>
<li>Servlet代码中有大量冗余代码，每个Servlet都有一模一样的或基本近似的代码，比如out输出你可能就得写成百遍；</li>
<li>开发Servlet必须精通网页前端和美工，你得非常不直观的在Servlet中写前端代码，这使得实现各种页面效果和风格非常困难。</li>
</ul>
</li>
<li><p>所以，SUN借鉴了Microsoft的ASP，正式提出JSP（Servlet1.1），已期望能代替Servlet。但是很快，SUN发现JSP也有问题：</p>
<ul>
<li>前端开发人员需要看JSP中大量的令他困惑的后端代码；</li>
<li>同样，Servlet开发人员也得在复杂的前端代码中找到其能写Servlet代码的地方；</li>
</ul>
</li>
<li><p>所以，Servlet1.2出现了，这个版本的Servlet倡导了MVC思想：</p>
<ul>
<li>JSP（V）：将后端代码封装在标签中，使用大量的标签，JSP只用来写前端代码而不要有后台代码；</li>
<li>Servlet（C）：Servlet完成Controller的功能再加上部分代码逻辑；</li>
<li>Model（M）：Servlet将数据发送给Model，Model包括部分代码逻辑，最主要的Model也代表着被组织好的用于返回的数据。最终，Model数据会被显示在JSP上（V）。<br>基本上到这里Servlet的大方向已经固定了，随之，成熟的发展至今 - 2016年5月26日…</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/04/java之NIO编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/04/java之NIO编程/" itemprop="url">
                  java之NIO编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-04 00:30:59" itemprop="dateCreated datePublished" datetime="2017-07-04T00:30:59+08:00">2017-07-04</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/04/java之NIO编程/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/04/java之NIO编程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>NIO（Non-blocking I/O，在Java领域，也称为New I/O，从 Java 1.4 开始），是一种==同步非阻塞的I/O模型==，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p>
<p>主要包括三个核心组件：<br>NIO的工具包提出了基于Selector（选择器）、Buffer（缓冲区）、Channel（通道）的新模式；Selector（选择器）、可选择的Channel（通道）和SelectionKey（选择键）配合起来使用，可以实现并发的非阻塞型I/O能力。</p>
<p>NI/O 是一种同步非阻塞的 I/O 模型。同步是指线程不断轮询 I/O 事件是否就绪，非阻塞是指线程在等待 I/O 的时候，可以同时做其他任务。同步的核心就是 Selector，Selector 代替了线程本身轮询 I/O 事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区，当 I/O 事件就绪时，可以通过写道缓冲区，保证 I/O 的成功，而无需线程阻塞式地等待。</p>
<h2 id="优缺点？"><a href="#优缺点？" class="headerlink" title="优缺点？"></a>优缺点？</h2><p>相较之前的io，效率更高，提升了并发量</p>
<p>I/O相比于BI/O,采用一种基于通道和缓存区的I/O方式 ,它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆的 DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<h3 id="Java-NIO-和-IO-的主要区别"><a href="#Java-NIO-和-IO-的主要区别" class="headerlink" title="Java NIO 和 IO 的主要区别"></a>Java NIO 和 IO 的主要区别</h3><p>下表总结了 Java NIO 和 IO 之间的主要差别，我会更详细地描述表中每部分的差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IO                NIO</span><br><span class="line">面向流            面向缓冲</span><br><span class="line">阻塞IO            非阻塞IO</span><br><span class="line">无                选择器</span><br></pre></td></tr></table></figure>
<p>面向流I/O的系统，一次处理一个字节的数据。一个输入流会产生一个字节的数据，而一个输出流同样一次消费一个字节的数据。对于流式数据，很容易创建过滤器。可以相对简单地把几个过滤器连接在一起，每个过滤器完成自己的工作，也是按字节进行过滤，精细的处理机制。另一方面，面向流I/O的通信往往比较缓慢。</p>
<p>面向块I/O的系统，以块为单位处理数据。每个操作步骤会生成或消费一个块的数据。以块为单位处理数据，其处理速度远快于以字节流为单位的方式。但是，与面向流I/O的通信相比，面向块I/O的通信缺乏优雅和简洁。</p>
<h3 id="什么时候应该使用java-io？什么时候又该使用java-nio呢？"><a href="#什么时候应该使用java-io？什么时候又该使用java-nio呢？" class="headerlink" title="什么时候应该使用java.io？什么时候又该使用java.nio呢？"></a>什么时候应该使用java.io？什么时候又该使用java.nio呢？</h3><p>1、 可扩展性。这可能会促使你选择不同的软件包。Java.net需要每个Socket通信都有一个线程。编码将大为简化。java.nio更富有效率，但相对难以编码。</p>
<p>2、 在处理成千上万的连接时，你可能需要更好的扩展性；但是如果连接数较低时，你可能更注重块I/O的高吞吐率。</p>
<p>3、当使用SSL (Secure Sockets Layer，安全套接字层) 工作时，选择java.nio则实现难度很大。</p>
<h2 id="内部的原理？"><a href="#内部的原理？" class="headerlink" title="内部的原理？"></a>内部的原理？</h2><p>假设某银行只有10个职员。该银行的业务流程分为以下4个步骤：</p>
<p>1） 顾客填申请表（5分钟）；</p>
<p>2） 职员审核（1分钟）；</p>
<p>3） 职员叫保安去金库取钱（3分钟）；</p>
<p>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。</p>
<p>　　我们看看银行不同的工作方式对其工作效率到底有何影响。</p>
<p>1 BIO方式<br>　　每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。</p>
<p>　　我们算算这个银行一个小时到底能处理多少顾客？一个职员处理一个顾客需要10分钟（5+1+3+1）时间，一个小时（60分钟）能处理6个顾客，一共10个职员，那就是只能处理60个顾客。</p>
<p>　　可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。</p>
<p>　　这种工作其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待 。</p>
<p>2 NIO方式<br>　　如何提高银行的吞吐量呢？</p>
<p>　　思路：分而治之，将任务拆分开来，由专门的人负责专门的任务。</p>
<p>　　具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写，每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。</p>
<p>　　我们计算下这种工作方式下银行一个小时到底能处理多少顾客？</p>
<p>　　假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理，柜台一个职员5分钟能处理完一个顾客，一个小时9名职员能处理：9*（60/5）=108。</p>
<p>　　可见工作方式的转变能带来效率的极大提升。</p>
<p>  这种工作方式其实就NIO的思路。下图是非常经典的NIO说明图，mainReactor线程负责监听server socket，accept新连接，并将建立的socket分派给subReactor；subReactor可以是一个线程，也可以是线程池（一般可以设置为CPU核数），负责多路分离已连接的socket，读写网络数据，这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成。</p>
<p>　　可以看到典型NIO有三类线程，分别是mainReactor线程、subReactor线程、work线程。不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14991017840585.jpg" alt></p>
<h2 id="具体的用法是什么？"><a href="#具体的用法是什么？" class="headerlink" title="具体的用法是什么？"></a>具体的用法是什么？</h2><h2 id="应用场景？"><a href="#应用场景？" class="headerlink" title="应用场景？"></a>应用场景？</h2><p>netty</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.itpub.net/thread-1372775-1-1.html" target="_blank" rel="noopener">Java NIO与Java IO的分析比较</a></li>
<li><a href="http://www.cnblogs.com/LBSer/p/4622749.html" target="_blank" rel="noopener">一个故事讲清楚NIO</a><br><a href="https://yq.aliyun.com/articles/2371" target="_blank" rel="noopener">https://yq.aliyun.com/articles/2371</a><br><a href="http://www.yangyong.me/java-nio%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">http://www.yangyong.me/java-nio%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3/</a><br><a href="http://www.hollischuang.com/archives/184" target="_blank" rel="noopener">http://www.hollischuang.com/archives/184</a><br><a href="http://wiki.jikexueyuan.com/project/java-nio/nio-io.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/java-nio/nio-io.html</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/02/网络协议进阶2——TCP-UDP协议详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/网络协议进阶2——TCP-UDP协议详解/" itemprop="url">
                  网络协议进阶2——TCP/UDP协议详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-02 11:17:47" itemprop="dateCreated datePublished" datetime="2017-07-02T11:17:47+08:00">2017-07-02</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/" itemprop="url" rel="index"><span itemprop="name">理解计算器机</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/02/网络协议进阶2——TCP-UDP协议详解/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/02/网络协议进阶2——TCP-UDP协议详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分开叙述tcp、ip、http/https等协议</p>
<p>这个协议在java中的体现？</p>
<p>分为应用层、传输层、网络层和实体层<br><img src="http://oo501cyv7.bkt.clouddn.com/14816321462047.jpg" alt></p>
<p>一、TCP/IP协议</p>
<p>TCP/IP协议（传输控制协议）由网络层的IP协议和传输层的TCP协议组成。IP层负责网络主机的定位，数据传输的路由，由IP地址可以唯一的确定Internet上的一台主机。TCP层负责面向应用的可靠的或非可靠的数据传输机制，这是网络编程的主要对象。</p>
<p>二、TCP与UDP</p>
<p>TCP是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。</p>
<p>　　UDP是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816330764039.jpg" alt></p>
<p>TCP与UDP区别：</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816332469431.jpg" alt></p>
<p>TCP特点：</p>
<p>　　1、TCP是面向连接的协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接协议，所以只能用于点对点的通讯。而且建立连接也需要消耗时间和开销。</p>
<p>　　2、TCP传输数据无大小限制，进行大数据传输。</p>
<p>　　3、TCP是一个可靠的协议，它能保证接收方能够完整正确地接收到发送方发送的全部数据。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816333163774.jpg" alt></p>
<p>UDP特点：</p>
<p>　　1、UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</p>
<p>　　2、UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。</p>
<p>　　3、UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816333420719.jpg" alt></p>
<p>TCP与UDP应用：</p>
<p>　　1、TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。</p>
<p>　　2，UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些</p>
<p>TCP通信需要服务器端侦听listen、接收客户端连接请求accept，等待客户端connect建立连接后才能进行数据包的收发(recv/send)工作。</p>
<p>而UDP则服务器和客户端的概念不明显，服务器端即接收端需要绑定端口，等待客户端的数据的到来。后续便可以进行数据的收发(recvfrom/sendto)工作。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816331321116.jpg" alt></p>
<p>参考</p>
<ul>
<li><a href="http://www.cnblogs.com/ghj1976/p/4295346.html" target="_blank" rel="noopener">HTTP TCP UDP Socket 关系的几个经典图</a></li>
<li><a href="https://krystalchisholm.wordpress.com/2010/11/24/chapter-17/" target="_blank" rel="noopener">Chapter 7 – ISP Services</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/02/网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路/" itemprop="url">
                  网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-02 11:16:14" itemprop="dateCreated datePublished" datetime="2017-07-02T11:16:14+08:00">2017-07-02</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/" itemprop="url" rel="index"><span itemprop="name">理解计算器机</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/02/网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/02/网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://oo501cyv7.bkt.clouddn.com/14816335778945.jpg" alt></p>
<p>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。</p>
<p>本文介绍 HTTP协议的历史演变和设计思路。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816948261078.jpg" alt></p>
<h2 id="一、HTTP-0-9"><a href="#一、HTTP-0-9" class="headerlink" title="一、HTTP/0.9"></a>一、HTTP/0.9</h2><p>HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p>
<p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure>
<p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p>
<p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>服务器发送完毕，就关闭TCP连接。</p>
<h2 id="二、HTTP-1-0"><a href="#二、HTTP-1-0" class="headerlink" title="二、HTTP/1.0"></a>二、HTTP/1.0</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p>
<p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p>
<p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。<br>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p>
<p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>
<h3 id="2-2-请求格式"><a href="#2-2-请求格式" class="headerlink" title="2.2 请求格式"></a>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>
<p>可以看到，这个格式与0.9版有很大变化。<br>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p>
<h3 id="2-3-回应格式"><a href="#2-3-回应格式" class="headerlink" title="2.3 回应格式"></a>2.3 回应格式</h3><p>服务器的回应如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>回应的格式是”头信息 + 一个空行（<code>\r\n</code>） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p>
<h3 id="2-4-Content-Type-字段"><a href="#2-4-Content-Type-字段" class="headerlink" title="2.4 Content-Type 字段"></a>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。<br>下面是一些常见的<code>Content-Type</code>字段的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* text/plain</span><br><span class="line">* text/html</span><br><span class="line">* text/css</span><br><span class="line">* image/jpeg</span><br><span class="line">* image/png</span><br><span class="line">* image/svg+xml</span><br><span class="line">* audio/mp4</span><br><span class="line">* video/mp4</span><br><span class="line">* application/javascript</span><br><span class="line">* application/pdf</span><br><span class="line">* application/zip</span><br><span class="line">* application/atom+xml</span><br></pre></td></tr></table></figure>
<p>这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。<br>除了预定义的类型，厂商也可以自定义类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.debian.binary-package</span><br></pre></td></tr></table></figure>
<p>上面的类型表明，发送的是Debian系统的二进制数据包。<br>MIME type还可以在尾部使用分号，添加参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>上面的类型表明，发送的是网页，而且编码是UTF-8。<br>客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>
<p>上面代码中，客户端声明自己可以接受任何格式的数据。<br>MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-Content-Encoding-字段"><a href="#2-5-Content-Encoding-字段" class="headerlink" title="2.5 Content-Encoding 字段"></a>2.5 Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure>
<p>客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>
<h3 id="2-6-缺点"><a href="#2-6-缺点" class="headerlink" title="2.6 缺点"></a>2.6 缺点</h3><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。<br>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。<br>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h2 id="三、HTTP-1-1"><a href="#三、HTTP-1-1" class="headerlink" title="三、HTTP/1.1"></a>三、HTTP/1.1</h2><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p>
<h3 id="3-1-持久连接"><a href="#3-1-持久连接" class="headerlink" title="3.1 持久连接"></a>3.1 持久连接</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。<br>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h3 id="3-2-管道机制"><a href="#3-2-管道机制" class="headerlink" title="3.2 管道机制"></a>3.2 管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h3 id="3-3-Content-Length-字段"><a href="#3-3-Content-Length-字段" class="headerlink" title="3.3 Content-Length 字段"></a>3.3 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure>
<p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。<br>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>
<h3 id="3-4-分块传输编码"><a href="#3-4-分块传输编码" class="headerlink" title="3.4 分块传输编码"></a>3.4 分块传输编码</h3><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>
<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p>
<p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure>
<p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="3-5-其他功能"><a href="#3-5-其他功能" class="headerlink" title="3.5 其他功能"></a>3.5 其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p>
<p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>
<p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
<h3 id="3-6-缺点"><a href="#3-6-缺点" class="headerlink" title="3.6 缺点"></a>3.6 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank" rel="noopener">队头堵塞</a>“（Head-of-line blocking）。</p>
<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h2 id="四、SPDY-协议"><a href="#四、SPDY-协议" class="headerlink" title="四、SPDY 协议"></a>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。<br>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p>
<h2 id="五、HTTP-2"><a href="#五、HTTP-2" class="headerlink" title="五、HTTP/2"></a>五、HTTP/2</h2><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p>
<h3 id="5-1-二进制协议"><a href="#5-1-二进制协议" class="headerlink" title="5.1 二进制协议"></a>5.1 二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>
<p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h3 id="5-2-多工"><a href="#5-2-多工" class="headerlink" title="5.2 多工"></a>5.2 多工</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>
<p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p>
<p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<h3 id="5-3-数据流"><a href="#5-3-数据流" class="headerlink" title="5.3 数据流"></a>5.3 数据流</h3><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p>
<p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p>
<p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h3 id="5-4-头信息压缩"><a href="#5-4-头信息压缩" class="headerlink" title="5.4 头信息压缩"></a>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>
<p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h3 id="5-5-服务器推送"><a href="#5-5-服务器推送" class="headerlink" title="5.5 服务器推送"></a>5.5 服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>
<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a></li>
<li><a href="http://www.open-open.com/solution/view/1455863940495" target="_blank" rel="noopener">http协议和tcp协议的区别是什么</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/02/网络协议入门（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/网络协议入门（二）/" itemprop="url">
                  网络协议入门（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-02 11:04:45" itemprop="dateCreated datePublished" datetime="2017-07-02T11:04:45+08:00">2017-07-02</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/" itemprop="url" rel="index"><span itemprop="name">理解计算器机</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/02/网络协议入门（二）/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/02/网络协议入门（二）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="七、一个小结"><a href="#七、一个小结" class="headerlink" title="七、一个小结"></a>七、一个小结</h2><p>先对前面的内容，做一个小结。</p>
<p>我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816280847955.jpg" alt></p>
<p>发送这个包，需要知道两个地址：</p>
<ul>
<li>对方的MAC地址</li>
<li>对方的IP地址</li>
</ul>
<p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816281262864.jpg" alt></p>
<p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p>
<p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：<br><img src="http://oo501cyv7.bkt.clouddn.com/14816281721776.jpg" alt></p>
<p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。</p>
<h2 id="八、用户的上网设置"><a href="#八、用户的上网设置" class="headerlink" title="八、用户的上网设置"></a>八、用户的上网设置</h2><h3 id="8-1-静态IP地址"><a href="#8-1-静态IP地址" class="headerlink" title="8.1 静态IP地址"></a>8.1 静态IP地址</h3><p>你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816282063772.jpg" alt></p>
<p>通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p>
<ul>
<li>本机的IP地址</li>
<li>子网掩码</li>
<li>网关的IP地址</li>
<li>DNS的IP地址</li>
</ul>
<p>下图是Windows系统的设置窗口。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816283222474.jpg" alt></p>
<p>这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。</p>
<p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p>
<h3 id="8-2-动态IP地址"><a href="#8-2-动态IP地址" class="headerlink" title="8.2 动态IP地址"></a>8.2 动态IP地址</h3><p>所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。</p>
<p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p>
<p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p>
<p>DHCP协议做了一些巧妙的规定。</p>
<h3 id="8-3-DHCP协议"><a href="#8-3-DHCP协议" class="headerlink" title="8.3 DHCP协议"></a>8.3 DHCP协议</h3><p>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816284096522.jpg" alt></p>
<p>   （1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p>
<p>  （2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p>
<p>　（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。<br>　<br>　这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。<br>　<br>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p>
<p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p>
<h3 id="8-4-上网设置：小结"><a href="#8-4-上网设置：小结" class="headerlink" title="8.4 上网设置：小结"></a>8.4 上网设置：小结</h3><p>这个部分，需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p>
<ul>
<li>本机的IP地址</li>
<li>子网掩码</li>
<li>网关的IP地址</li>
<li>DNS的IP地址</li>
</ul>
<p>有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。</p>
<h2 id="九、一个实例：访问网页"><a href="#九、一个实例：访问网页" class="headerlink" title="九、一个实例：访问网页"></a>九、一个实例：访问网页</h2><h3 id="9-1-本机参数"><a href="#9-1-本机参数" class="headerlink" title="9.1 本机参数"></a>9.1 本机参数</h3><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数：</p>
<ul>
<li>本机的IP地址：192.168.1.100</li>
<li>子网掩码：255.255.255.0</li>
<li>网关的IP地址：192.168.1.1</li>
<li>DNS的IP地址：8.8.8.8</li>
</ul>
<p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816286436708.jpg" alt></p>
<p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p>
<h3 id="9-2-DNS协议"><a href="#9-2-DNS协议" class="headerlink" title="9.2 DNS协议"></a>9.2 DNS协议</h3><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。</p>
<p><a href="http://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">DNS协议</a>可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816287378399.jpg" alt></p>
<p>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p>
<h3 id="9-3-子网掩码"><a href="#9-3-子网掩码" class="headerlink" title="9.3 子网掩码"></a>9.3 子网掩码</h3><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p>
<p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p>
<p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p>
<h3 id="9-4-应用层协议"><a href="#9-4-应用层协议" class="headerlink" title="9.4 应用层协议"></a>9.4 应用层协议</h3><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816289059177.jpg" alt></p>
<p>HTTP部分的内容，类似于下面这样：</p>
<p>```<br>　　GET / HTTP/1.1<br>　　Host: www.google.com<br>　　Connection: keep-alive<br>　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ……<br>　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>　　Accept-Encoding: gzip,deflate,sdch<br>　　Accept-Language: zh-CN,zh;q=0.8<br>　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3<br>　　Cookie: … …</p>
<p>```　<br>　<br>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p>
<h3 id="9-5-TCP协议"><a href="#9-5-TCP协议" class="headerlink" title="9.5 TCP协议"></a>9.5 TCP协议</h3><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p>
<p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p>
<h3 id="9-6-IP协议"><a href="#9-6-IP协议" class="headerlink" title="9.6 IP协议"></a>9.6 IP协议</h3><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p>
<p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p>
<h3 id="9-7-以太网协议"><a href="#9-7-以太网协议" class="headerlink" title="9.7 以太网协议"></a>9.7 以太网协议</h3><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p>
<p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p>
<p><img src="media/14816259798684/14816290203170.jpg" alt></p>
<h3 id="9-8-服务器端响应"><a href="#9-8-服务器端响应" class="headerlink" title="9.8 服务器端响应"></a>9.8 服务器端响应</h3><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p>
<p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p>
<p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>
<p><img src="media/14816259798684/14816290564421.jpg" alt></p>
<p>这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">互联网协议入门（二）</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/02/网络协议入门（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/网络协议入门（一）/" itemprop="url">
                  网络协议入门（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-02 10:54:17" itemprop="dateCreated datePublished" datetime="2017-07-02T10:54:17+08:00">2017-07-02</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/" itemprop="url" rel="index"><span itemprop="name">理解计算器机</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理解计算器机/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/02/网络协议入门（一）/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/02/网络协议入门（一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络协议入门（一）"><a href="#网络协议入门（一）" class="headerlink" title="网络协议入门（一）"></a>网络协议入门（一）</h1><p>我们每天使用互联网，你是否想过，它是如何实现的？<br>全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？</p>
<p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。</p>
<p>下面就是我的学习笔记。因为这些协议实在太复杂、太庞大，我想整理一个简洁的框架，帮助自己从总体上把握它们。为了保证简单易懂，我做了大量的简化，有些地方并不全面和精确，但是应该能够说清楚互联网的原理。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-五层模型"><a href="#1-1-五层模型" class="headerlink" title="1.1 五层模型"></a>1.1 五层模型</h3><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p>
<p>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p>
<p>如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816246370013.jpg" alt></p>
<p>如上图所示，最底下的一层叫做”实体层”（Physical Layer），最上面的一层叫做”应用层”（Application Layer），中间的三层（自下而上）分别是”链接层”（Link Layer）、”网络层”（Network Layer）和”传输层”（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p>
<p>它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。</p>
<h3 id="1-2-层与协议"><a href="#1-2-层与协议" class="headerlink" title="1.2 层与协议"></a>1.2 层与协议</h3><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。<br>大家都遵守的规则，就叫做”协议”（protocol）。</p>
<p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p>
<h2 id="二、实体层"><a href="#二、实体层" class="headerlink" title="二、实体层"></a>二、实体层</h2><p>我们从最底下的一层开始。</p>
<p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816251058498.jpg" alt></p>
<p>这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p>
<h2 id="三、链接层"><a href="#三、链接层" class="headerlink" title="三、链接层"></a>三、链接层</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p>
<p>这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。</p>
<h3 id="3-2-以太网协议"><a href="#3-2-以太网协议" class="headerlink" title="3.2 以太网协议"></a>3.2 以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p>
<p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816251883055.jpg" alt></p>
<p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p>
<p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>
<h3 id="3-3-MAC地址"><a href="#3-3-MAC地址" class="headerlink" title="3.3 MAC地址"></a>3.3 MAC地址</h3><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p>
<p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816253012951.jpg" alt></p>
<p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816253370028.jpg" alt></p>
<p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>
<h3 id="3-4-广播"><a href="#3-4-广播" class="headerlink" title="3.4 广播"></a>3.4 广播</h3><p>定义地址只是第一步，后面还有更多的步骤。</p>
<p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p>
<p>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</p>
<p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？</p>
<p>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816253745582.jpg" alt></p>
<p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p>
<p>有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</p>
<h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><h3 id="4-1-网络层的由来"><a href="#4-1-网络层的由来" class="headerlink" title="4.1 网络层的由来"></a>4.1 网络层的由来</h3><p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p>
<p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p>
<p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816254458858.jpg" alt></p>
<p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>
<p><strong>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p>
<p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p>
<p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p>
<h3 id="4-2-IP协议"><a href="#4-2-IP协议" class="headerlink" title="4.2 IP协议"></a>4.2 IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p>
<p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。<br><img src="http://oo501cyv7.bkt.clouddn.com/14816255100692.jpg" alt></p>
<p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p>
<p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p>
<p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p>
<p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。</p>
<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p>
<p>总结一下，<strong>IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络</strong>。</p>
<h3 id="4-3-IP数据包"><a href="#4-3-IP数据包" class="headerlink" title="4.3 IP数据包"></a>4.3 IP数据包</h3><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p>
<p>但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p>
<p>回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p>
<p>具体来说，IP数据包也分为”标头”和”数据”两个部分。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816255957408.jpg" alt></p>
<p>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816256121670.jpg" alt></p>
<p>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<h3 id="4-4-ARP协议"><a href="#4-4-ARP协议" class="headerlink" title="4.4 ARP协议"></a>4.4 ARP协议</h3><p>关于”网络层”，还有最后一点需要说明。</p>
<p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p>
<p>所以，我们需要一种机制，能够从IP地址得到MAC地址。</p>
<p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p>
<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p>
<p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p>
<h2 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h2><h3 id="5-1-传输层的由来"><a href="#5-1-传输层的由来" class="headerlink" title="5.1 传输层的由来"></a>5.1 传输层的由来</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p><strong>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流</strong>。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>
<h3 id="5-2-UDP协议"><a href="#5-2-UDP协议" class="headerlink" title="5.2 UDP协议"></a>5.2 UDP协议</h3><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p>
<p>UDP数据包，也是由”标头”和”数据”两部分组成。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816257733505.jpg" alt></p>
<p>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816257948856.jpg" alt></p>
<p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p>
<h3 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a>5.3 TCP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>
<p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>
<p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p>
<p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<h2 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h2><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p>
<p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。</p>
<p><img src="http://oo501cyv7.bkt.clouddn.com/14816258786010.jpg" alt></p>
<p>至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门（一）</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/07/01/java反射基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/01/java反射基础知识/" itemprop="url">
                  java反射基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-01 14:50:46" itemprop="dateCreated datePublished" datetime="2017-07-01T14:50:46+08:00">2017-07-01</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/01/java反射基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/07/01/java反射基础知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p><strong>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性</strong>；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制.</p>
<p>白话<br>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。</p>
<p>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p>反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java反射框架主要提供以下功能：</p>
<p>1.在运行时判断任意一个对象所属的类；<br>2.在运行时构造任意一个类的对象；<br>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>4.在运行时调用任意一个对象的方法</p>
<p><strong>==重点：是运行时而不是编译时==</strong></p>
<h2 id="有什么用处？"><a href="#有什么用处？" class="headerlink" title="有什么用处？"></a>有什么用处？</h2><p>==反射最重要的用途就是开发各种通用框架。具有强大的解耦性==</p>
<p>JUnit的@Test和Spring的@Controller和@RequestMapping是很好的例子。</p>
<p>当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p>
<p>很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p>
<p>举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如：</p>
<action name="login" class="org.ScZyhSoft.test.action.SimpleLoginAction" method="execute"><br>           <result>/shop/shop-index.jsp</result><br>           <result name="error">login.jsp</result><br>  </action>

<p>配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。<br>——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。<br>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
<h2 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h2><p>JAVA的反射你一定要知道四个类:</p>
<p>Class，Constructor，Field，Method;<br>Class 代表类的对象<br>Constructor 代表类的构造器对象<br>Field 代表了类的成员变量<br>Method 代表了类的方法对象</p>
<p>获得Class对象</p>
<p>方法有三种<br>(1)使用Class类的forName静态方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String className)</span><br><span class="line">Class c1=Class.forName(&quot;me.light.Person&quot;);</span><br></pre></td></tr></table></figure>
<p>(2)直接获取某一个对象的class，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = int.class;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br><span class="line">Class c2=me.light.Person.class;</span><br></pre></td></tr></table></figure>
<p>(3)调用某个对象的getClass()方法,比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = new StringBuilder(&quot;123&quot;);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br><span class="line">Class c3=person.getClass();</span><br></pre></td></tr></table></figure>
<p>2、判断是否为某个类的实例</p>
<p>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的<code>isInstance()</code>方法来判断是否为某个类的实例，它是一个Native方法：</p>
<p><code>public native boolean isInstance(Object obj);</code></p>
<p>3、创建实例</p>
<p>通过反射来生成对象主要有两种方式。</p>
<p>（1）使用Class对象的<code>newInstance()</code>方法来创建Class对象对应类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure>
<p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p>
<p>//获取String所对应的Class对象<br><code>Class&lt;?&gt; c = String.class;</code><br>//获取String类带一个String参数的构造器<br><code>Constructor constructor = c.getConstructor(String.class);</code><br>//根据构造器创建实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = constructor.newInstance(&quot;23333&quot;);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>
<p>4、获取方法</p>
<p>获取某个Class对象的方法集合，主要有以下几个方法：</p>
<p>4.1 <code>getDeclaredMethods()</code>方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。<br><code>public Method[] getDeclaredMethods() throws SecurityException</code></p>
<p>4.2 <code>getMethods()</code>方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。<br><code>public Method[] getMethods() throws SecurityException</code></p>
<p>4.3 <code>getMethod()</code>方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象<br><code>public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></p>
<p>通过getMethods()获取的方法可以获取到父类的方法,比如java.lang.Object下定义的各个方法。</p>
<p>5、获取构造器信息<br>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:</p>
<p><code>public T newInstance(Object ... initargs)</code></p>
<p>此方法可以根据传入的参数来调用对应的Constructor创建对象实例~</p>
<p>6、获取类的成员变量（字段）信息<br>主要是这几个方法，在此不再赘述：<br>getFiled: 访问公有的成员变量<br>getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）</p>
<p>7、调用方法<br>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">        throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">           InvocationTargetException</span><br></pre></td></tr></table></figure>
<p>下面是一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; klass = methodClass.class;</span><br><span class="line">        //创建methodClass的实例</span><br><span class="line">        Object obj = klass.newInstance();</span><br><span class="line">        //获取methodClass类的add方法</span><br><span class="line">        Method method = klass.getMethod(&quot;add&quot;,int.class,int.class);</span><br><span class="line">        //调用method对应的方法 =&gt; add(1,4)</span><br><span class="line">        Object result = method.invoke(obj,1,4);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class methodClass &#123;</span><br><span class="line">    public final int fuck = 3;</span><br><span class="line">    public int add(int a,int b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sub(int a,int b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于invoke()方法的详解，后面我会专门写一篇文章来深入解析invoke的过程。</p>
<p>一些注意事项</p>
<p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。<br>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F" target="_blank" rel="noopener">深入解析Java反射（1） - 基础</a></li>
<li><a href="https://juejin.im/post/58c93ea144d9040069eb72ba" target="_blank" rel="noopener">开发笔记之你弄不懂的JAVA反射机制</a></li>
<li><a href="https://juejin.im/post/5906f77461ff4b0066cb88f7" target="_blank" rel="noopener">Java 基础与提高干货系列—Java 反射机制 | 掘金技术征文</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/05/08/Mac下shadowsocks全自动地代理翻墙/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/08/Mac下shadowsocks全自动地代理翻墙/" itemprop="url">
                  Mac下shadowsocks全自动地代理翻墙
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-08 15:07:16" itemprop="dateCreated datePublished" datetime="2017-05-08T15:07:16+08:00">2017-05-08</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/利器/" itemprop="url" rel="index"><span itemprop="name">利器</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/08/Mac下shadowsocks全自动地代理翻墙/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/05/08/Mac下shadowsocks全自动地代理翻墙/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Shadowsocks服务端"><a href="#Shadowsocks服务端" class="headerlink" title="Shadowsocks服务端"></a>Shadowsocks服务端</h2><p>可以搭建自己服务，也可以买现成的服务。我就是在shadowsocks.com买的服务。</p>
<h3 id="测速-speed-test"><a href="#测速-speed-test" class="headerlink" title="测速 speed test"></a>测速 speed test</h3><h4 id="手机上下载-【BestTrace】-app-测试连接翻墙服务节点的路由跳数，并绘制地图："><a href="#手机上下载-【BestTrace】-app-测试连接翻墙服务节点的路由跳数，并绘制地图：" class="headerlink" title="手机上下载 【BestTrace】 app 测试连接翻墙服务节点的路由跳数，并绘制地图："></a>手机上下载 【BestTrace】 app 测试连接翻墙服务节点的路由跳数，并绘制地图：</h4><ol>
<li>路由跳数</li>
<li>地图：是否有绕路</li>
</ol>
<h4 id="MAC和windows"><a href="#MAC和windows" class="headerlink" title="MAC和windows"></a>MAC和windows</h4><p>官方网站 下载：<a href="https://www.ipip.net/download.html" target="_blank" rel="noopener">https://www.ipip.net/download.html</a></p>
<p>Windows / Mac OS X 客户端<br>android / iOS 客户端</p>
<h2 id="Shadowsocks客户端配置"><a href="#Shadowsocks客户端配置" class="headerlink" title="Shadowsocks客户端配置"></a>Shadowsocks客户端配置</h2><h3 id="shadowsocks-on-Mac-OS-X"><a href="#shadowsocks-on-Mac-OS-X" class="headerlink" title="shadowsocks on Mac OS X"></a>shadowsocks on Mac OS X</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>github release 下载地址：</p>
<ul>
<li>Mac 新版客户端：<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases/" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG/releases/</a></li>
<li>Mac 旧版客户端：<a href="https://github.com/shadowsocks/shadowsocks-iOS/releases/" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-iOS/releases/</a></li>
</ul>
<h4 id="MD5-hash"><a href="#MD5-hash" class="headerlink" title="MD5 hash"></a>MD5 hash</h4><p>打开 终端 应用，使用 <code>md5</code> 命令校验下载文件的 MD5 哈希值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ md5 Downloads/ShadowsocksX-2.6.3.dmg</span><br><span class="line">MD5 (Downloads/ShadowsocksX-2.6.3.dmg) = c3406e8d4a5009efaa74d3a37b53fed8</span><br></pre></td></tr></table></figure>
<h4 id="ShadowsocksX安装配置"><a href="#ShadowsocksX安装配置" class="headerlink" title="ShadowsocksX安装配置"></a>ShadowsocksX安装配置</h4><ol>
<li>运行 ShadowsocksX</li>
<li>配置 代理服务器</li>
<li>连接 代理服务器</li>
<li>开启 系统代理</li>
<li>测试 科学上网</li>
<li>从 <code>GFWList</code> 更新 PAC 文件</li>
</ol>
<p>【运行】ShadowsocksX<br>运行 ShadowsocksX 后，会在 menubar 显示 「纸飞机」 图标<br>默认图标为 灰色 表示 「系统代理」 未启动<br><img src="http://images.insuncle.com/mweb/14813822404491.jpg" alt></p>
<p>【编辑】代理服务器</p>
<p>点击 「纸飞机」 选择 「服务器」 菜单，然后点击 【打开服务器设定】 选项：<br><img src="http://images.insuncle.com/mweb/14813824182249.jpg" alt></p>
<p>弹出 「服务器设定」 窗口：<br><img src="http://images.insuncle.com/mweb/14813824401968.jpg" alt></p>
<p>【连接】代理服务器</p>
<p>选中 「服务器」 菜单创建的代理服务器配置，出现对号 「√」 表示与代理服务器建立连接<br>成功与代理服务器建立连接后，便会创建 「SOCKS5 代理」<br><img src="http://images.insuncle.com/mweb/14813826263320.jpg" alt></p>
<p>【开启】系统代理</p>
<p>点击「主菜单」 第二行 【打开 shadowsocks】 启用 「系统代理」：</p>
<ol>
<li>第一行：系统代理 运行 状态，显示 「关闭」 状态</li>
<li>第二行：系统代理 运行 开关，默认 系统代理 没有启动（ 图标为 灰色 ）<br><img src="http://images.insuncle.com/mweb/14813827865115.jpg" alt></li>
</ol>
<p>系统代理 启动后 menubar 的 「纸飞机」 图标也变为 黑色：<br><img src="http://images.insuncle.com/mweb/14813828342006.jpg" alt></p>
<p>「系统代理」 与 「SOCKS5 代理」 区别：<br>系统代理</p>
<ul>
<li>浏览器的访问请求全部由 shadowsocks 创建的 系统代理 处理</li>
<li>浏览器默认不需要任何设置，也无需安装 代理插件 （Firefox 除外）</li>
<li>如果浏览器安装了代理插件，需要 禁用 代理插件 或把插件设置为 使用系统代理</li>
</ul>
<p>SOCKS5 代理</p>
<ul>
<li>若不 【启用系统代理】 shadowsocks 成功连接代理服务器后，仅创建了 「SOCKS5 代理」</li>
<li>浏览器需要安装 代理插件 或设置浏览器的代理配置，才能科学上网</li>
</ul>
<p>【测试】科学上网</p>
<p>如果 系统代理 运行成功，就可以访问 google 。如果失败，请检查 「服务器配置」 是否正确：<br><img src="http://images.insuncle.com/mweb/14813829541791.jpg" alt></p>
<p>【更新】PAC 文件</p>
<p>最后在主菜单中点击 「从 GFWList 更新 PAC 文件」 更新翻墙列表：<br><img src="http://images.insuncle.com/mweb/14813830308088.jpg" alt></p>
<p>SOCKS5 代理<br>默认 ShadowsocksX 创建的 「SOCKS5 代理」端口 是 1080 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep 127 ~/.ShadowsocksX/gfwlist.js</span><br><span class="line">var proxy = &quot;SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT;&quot;;</span><br></pre></td></tr></table></figure>
<p>ShadowsocksX-NG 本地端口更换为 1086 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat &quot;/Users/yourname/Library/Application Support/ShadowsocksX-NG/ss-local-config.json&quot;a</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;method&quot; : &quot;rc4-md5&quot;,</span><br><span class="line">  &quot;server&quot; : &quot;IP&quot;,</span><br><span class="line">  &quot;password&quot; : &quot;...&quot;,</span><br><span class="line">  &quot;local_address&quot; : &quot;127.0.0.1&quot;,</span><br><span class="line">  &quot;server_port&quot; : ...,</span><br><span class="line">  &quot;auth&quot; : false,</span><br><span class="line">  &quot;timeout&quot; : 60,</span><br><span class="line">  &quot;local_port&quot; : 1086</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以自行修改 ~/.ShadowsocksX/gfwlist.js 配置文件，自定义 「SOCKS5 代理」端口</p>
<h3 id="shadowsocks-on-IOS"><a href="#shadowsocks-on-IOS" class="headerlink" title="shadowsocks on IOS"></a>shadowsocks on IOS</h3><h4 id="Potatso"><a href="#Potatso" class="headerlink" title="Potatso"></a>Potatso</h4><p>APP Store ：<a href="https://itunes.apple.com/app/apple-store/id1070901416" target="_blank" rel="noopener">https://itunes.apple.com/app/apple-store/id1070901416</a><br><a href="https://potatso.com/" target="_blank" rel="noopener">https://potatso.com/</a><br><a href="https://manual.potatso.com/" target="_blank" rel="noopener">https://manual.potatso.com/</a><br><a href="https://github.com/shadowsocks/Potatso" target="_blank" rel="noopener">https://github.com/shadowsocks/Potatso</a></p>
<h4 id="Mume-VPN"><a href="#Mume-VPN" class="headerlink" title="Mume VPN"></a>Mume VPN</h4><p>基于 Potatso 开发的 Shadowsocks 协议 VPN 客户端<br>APP Store ：<a href="https://itunes.apple.com/cn/app/mume-vpn/id1144787928" target="_blank" rel="noopener">https://itunes.apple.com/cn/app/mume-vpn/id1144787928</a><br><a href="https://github.com/liruqi/Mume-iOS" target="_blank" rel="noopener">https://github.com/liruqi/Mume-iOS</a><br><a href="http://vpn.liruqi.info/ios/" target="_blank" rel="noopener">http://vpn.liruqi.info/ios/</a><br><a href="http://api.liruqi.info/" target="_blank" rel="noopener">http://api.liruqi.info/</a><br><a href="http://mume.site/" target="_blank" rel="noopener">http://mume.site/</a></p>
<h2 id="PAC代理模式"><a href="#PAC代理模式" class="headerlink" title="PAC代理模式"></a>PAC代理模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>翻墙原理就是通过 「<strong>SOCKS5 代理</strong>」 来访问被和谐的网站</p>
<p>shadowsocks 客户端除了创建 「<strong>SOCKS5 代理</strong>」 外，还实现了创建 「系统代理」 的功能，通过 「系统代理」 来管理浏览器的访问请求（分流）。「系统代理」 支持 2 种 代理模式：</p>
<ol>
<li>自动代理模式 ( 即 PAC 模式 ，默认 )</li>
<li>全局代理模式</li>
</ol>
<h4 id="PAC-代理模式"><a href="#PAC-代理模式" class="headerlink" title="PAC 代理模式"></a>PAC 代理模式</h4><p>PAC 维基百科：<a href="http://zh.wikipedia.org/zh/PAC" target="_blank" rel="noopener">http://zh.wikipedia.org/zh/PAC</a></p>
<p>默认 shadowsocks 启用 「系统代理」 后使用的是 【<strong>PAC 代理模式</strong>】</p>
<p>Shadowsocks 成功 连接代理服务器 后，会创建一个 「<strong>SOCKS5 代理</strong>」</p>
<p>Socks 5 代理 使用的是本机 <code>127.0.0.1:1080</code> 端口</p>
<p>【<strong>PAC 代理模式</strong>】 当浏览器访问某个网站时，会去匹配 <strong>PAC 配置文件</strong> pac.txt 里 URL 列表。如果能匹配到 PAC 文件配置的 URL 就会使用「SOCKS5 代理」访问该网站。否则不使用代理，直接访问网站。既节省 ss 流量，也会提高 国内 网站的访问速度，不然访问国内网站要绕到国外代理再绕回来。</p>
<h4 id="全局代理模式"><a href="#全局代理模式" class="headerlink" title="全局代理模式"></a>全局代理模式</h4><p>全局代理模式 所有请求全部走 「<strong>SOCKS5 代理</strong>」。访问 国内 网站时，将会先绕到 国外 的代理服务器，然后在绕回来，南辕北辙了。当访问的网站没有包含在 PAC 文件的匹配规则列表时，可以 临时 开启全局代理进行访问。</p>
<p>菜单<br><img src="http://images.insuncle.com/mweb/14813841973907.jpg" alt></p>
<h3 id="编辑-PAC-规则"><a href="#编辑-PAC-规则" class="headerlink" title="编辑 PAC 规则"></a>编辑 PAC 规则</h3><p>从 GFWList 同步的 PAC 规则后，会在本地生成的 PAC 文件 ：</p>
<p>Mac OS X 是在<code>~/.ShadowsocksX/gfwlist.js</code>里</p>
<p>新版本的可以在shadowsocks里直接设置</p>
<p><img src="http://images.insuncle.com/mweb/14813844089754.jpg" alt></p>
<p>然后在弹框中输入<br><img src="http://images.insuncle.com/mweb/14813844540632.jpg" alt></p>
<p>里边的文档格式可以参考<a href="Adblock Plus filters explained">https://adblockplus.org/en/filter-cheatsheet</a>，两者的写法完全相同，下面是我的用户规则文件user-rule.txt的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">! Put user rules line by line in this file.</span><br><span class="line">! See https://adblockplus.org/en/filter-cheatsheet</span><br><span class="line"></span><br><span class="line">||aws.amazon.com^</span><br><span class="line">||amazonwebservices.com^</span><br><span class="line">||cloudfront.net^</span><br><span class="line">||google.com^</span><br></pre></td></tr></table></figure>
<p>找出非常隐蔽的被墙掉的地址</p>
<p>好了，既然学会了自定义PAC文件，那么，想必应该是配置完毕了吧？当然不是，你有没有遇到过这种情况，明明把指定网址加到PAC里面了，但是打开该网址还是非常缓慢，或者只能看到部分控件，而网页主体始终刷不出来？但是将代理模式切到全局模式，又能正常打开该网页。</p>
<p>这又是为何？</p>
<p>其实，虽然目标网址是走了代理，但是目标网址上的一些资源（可能是某些JavaScript、CSS文件），可能是储存在某些被墙掉的地方，但是又没有添加到PAC文件里，所以使用全局代理模式时能轻松打开，但是使用自动代理模式时却又显示不出来，那么，如何解决呢？</p>
<h4 id="使用日志来查找"><a href="#使用日志来查找" class="headerlink" title="使用日志来查找"></a>使用日志来查找</h4><p>从菜单里点击<code>显示日志...</code>，其实就是打开系统应用<code>控制台</code>，系统日志中所有以 <strong>ShadowsocksX</strong>: 开头的是Shadowsocks的日志，我们再右上角输入ShadowsocksX，即可只显示Shadowsocks的日志。我们在全局模式下，刷新一次在自动代理模式下打不开的网页，然后马上切到控制台查看Shadowsocks的日志，看看是否有遗漏没有添加到PAC文件的网址，如图中的<em>*</em>.cloudfront.net。<br><img src="http://images.insuncle.com/mweb/14813851228563.jpg" alt></p>
<p>我们在用户规则文件user-rule.txt添加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">! Put user rules line by line in this file.</span><br><span class="line">! See https://adblockplus.org/en/filter-cheatsheet</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">||cloudfront.net^</span><br></pre></td></tr></table></figure>
<p>并执行一遍从GFWList更新PAC文件，即可。</p>
<h4 id="使用浏览器来查找"><a href="#使用浏览器来查找" class="headerlink" title="使用浏览器来查找"></a>使用浏览器来查找</h4><p>当然，可以使用浏览器的开发者工具来查看目标网址所需的网络请求，然后将可以的地址加入到PAC文件即可。<br><img src="http://images.insuncle.com/mweb/14813852310687.jpg" alt></p>
<h4 id="ShadowSocks-的-Alfred-Workflow来添加规则"><a href="#ShadowSocks-的-Alfred-Workflow来添加规则" class="headerlink" title="ShadowSocks 的 Alfred Workflow来添加规则"></a>ShadowSocks 的 Alfred Workflow来添加规则</h4><p>如果你是 小帽子 Alfred 的用户，你可以直接使用我写的 <a href="https://github.com/echohn/shadowsocks-alfred-workflow/raw/master/shadowsocks.alfredworkflow" target="_blank" rel="noopener">ShadowSocks-Workflow</a>(点击下载)。在 Alfred 中执行 ssadd ，然后粘贴你准备加入 gfwlist 的 url，url 的域名就添加进 ShadowScoks 了。<br><img src="http://images.insuncle.com/mweb/14813861026193.jpg" alt></p>
<h2 id="浏览器代理插件"><a href="#浏览器代理插件" class="headerlink" title="浏览器代理插件"></a>浏览器代理插件</h2><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>Chrome 代理插件：Proxy SwitchyOmega</p>
<ol>
<li><p>如果你不想用全局 PAC 代理，想配合 SwitchySharp 等插件使用，可在菜单栏图标里点关闭 Shadowsocks。关闭后代理仍会运行在 127.0.0.1:1080 上，代理类型为 SOCKS v5。之所以不叫关闭 PAC，因为很多人不懂什么是 PAC。写关闭 Shadowsocks 更容易理解。</p>
</li>
<li><p>切换服务器后，因为 Chrome 保持长连接，可能需要重启浏览器才能生效。也可以重启 ShadowsocksX 来强制 Chrome 重新连接。</p>
</li>
</ol>
<h2 id="Shadowsocks的PAC模式与全局模式与VPN的区别"><a href="#Shadowsocks的PAC模式与全局模式与VPN的区别" class="headerlink" title="Shadowsocks的PAC模式与全局模式与VPN的区别"></a>Shadowsocks的PAC模式与全局模式与VPN的区别</h2><h3 id="VPN，即虚拟专用网络"><a href="#VPN，即虚拟专用网络" class="headerlink" title="VPN，即虚拟专用网络"></a>VPN，即虚拟专用网络</h3><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。</p>
<h4 id="Shadowsocks，即Sock5代理"><a href="#Shadowsocks，即Sock5代理" class="headerlink" title="Shadowsocks，即Sock5代理"></a>Shadowsocks，即Sock5代理</h4><p>采用socks协议的代理服务器就是SOCKS服务器，是一种通用的代理服务器。Socks是个电路级的底层网关，是DavidKoblas在1990年开发的，此后就一直作为Internet RFC标准的开放标准。Socks 不要求应用程序遵循特定的操作系统平台，Socks 代理与应用层代理、 HTTP 层代理不同，Socks 代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。所以，Socks代理比其他应用层代理要快得多。</p>
<p>VPN顾名思义，虚拟专网，你接入VPN就是接入了一个专有网络，那么你访问网络都是从这个专有网络的出口出去，好比你在家，你家路由器后面的网络设备是在同一个网络，而VPN则是让你的设备进入了另一个网络。同时你的IP地址也变成了由VPN分配的一个IP地址。通常是一个私网地址。你和VPN服务器之间的通信是否加密取决于连接VPN的具体方式/协议。</p>
<p>Sock5代理服务器则是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地。你没有加入任何新的网络，只是http/socks数据经过代理服务器的转发送出，并从代理服务器接收回应。你与代理服务器通信过程不会被额外处理，如果你用https，那本身就是加密的。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>VPN</strong>的开发目的是给企业内网直接传输加密数据，最重要的就是安全性，相反VPN的流量特征变得很明显，特别是SSL VPN类型，比如Openvpn有SSL证书的加密，安全性不必多说，但是握手依然是明文，流量更加明显，导致匹配流量特征很容易，在我这里一旦链接Openvpn那就是秒封。</p>
<p>VPN目前就科学上网方面来讲，PPTP大部分地区已死，L2TP大部分地区已经出现干扰和断开连接情况，Openvpn一封一个准。而anyconnect大多数都是企业用的，所以墙不敢乱封，IKEv1/IKEv2需要注意证书中间人攻击问题。</p>
<p>所以，在VPN科学上网这方面，一些地区已经根据VPN的流量特征做出了相应的匹配策略，可以有效封杀VPN了。</p>
<p><strong>Shadowsocks</strong>的开发目的就是穿透防火墙，最重要的是增加墙的匹配流量效率封杀成本和难度，也就是混淆隐秘性。</p>
<p><strong>Shadowsocks是更注重流量混淆隐秘，VPN则是更注重加密安全性。</strong>如果你需要安全你可能需要 VPN 或者 Shadowsocks+TOR匿名 ，否则就抗干扰能力来说Shadowsocks更适合拿来科学上网，VPN中的Opnevpn是最安全的VPN协议之一，然而第一个被墙宣布效率检测、封杀！</p>
<p>没有完美的工具，VPN和Shadowsocks在某种程度上可以说是两种相反的技术，开发目的不一样，注重点也不一样，缺点相应的也不一样，所以根据当地运营商的封杀策略选择最适合自己的方式。</p>
<h2 id="通过ProxyChains让Iterm终端上网"><a href="#通过ProxyChains让Iterm终端上网" class="headerlink" title="通过ProxyChains让Iterm终端上网"></a>通过ProxyChains让Iterm终端上网</h2><p>如我们之前所说的，浏览器科学上网只是一部分，身为一名工程师或非 Windows 用户，我们经常会使用到一些命令行工具，想让命令行工具科学上网肿么办？</p>
<p>ProxyChains 就是一个这样用途的工具，它可以让你的其它工具通过 Socks 或 HTTP 代理访问网络。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先从 Homebrew 安装 ProxyChains。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install proxychains-ng</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>编辑配置文件 <code>mvim /usr/local/etc/proxychains.conf</code><br>在 [ProxyList] 下面（也就是末尾）加入代理类型，代理地址和端口<br>例如使用 TOR 代理，注释掉原来的代理并添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">strict_chain</span><br><span class="line">proxy_dns</span><br><span class="line">remote_dns_subnet 224</span><br><span class="line">tcp_read_time_out 15000</span><br><span class="line">tcp_connect_time_out 8000</span><br><span class="line">localnet 127.0.0.0/255.0.0.0</span><br><span class="line">quiet_mode</span><br><span class="line">[ProxyList]</span><br><span class="line">socks5  127.0.0.1 1086</span><br></pre></td></tr></table></figure>
<p>需要说明一点，在这里我配置的是 strict_chain。如果你有多重代理，类似我之前一样，比如让命令先通过 Lantern 代理出去，如果失败再走 SS 代理，可以配置成 dynamic_chain 模式。不过这超出今天的文章范畴了，我还是以 strict_chain 举例，如果你对 dynamic_chain 感兴趣，可以自行研究。</p>
<p>每次使用 <code>proxychains4</code> 命令其实有些不爽，太长容易输错。<br>编辑 <code>~/.bash_profile</code> 文件，添加下面一行命令为 <code>proxychains4</code> 设置别名为 pc 或者你喜欢的任何命令。重启终端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias pc=&quot;proxychains4 -f ~/.proxychains.conf&quot;</span><br></pre></td></tr></table></figure>
<p>在执行 <code>source ~/.bash_profile</code> 重新加载环境变量之后，就可以尝试是否配置成功了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc curl https://twitter.com</span><br></pre></td></tr></table></figure>
<h2 id="为git-nodejs-gradle-maven等进行代理服务器的配置"><a href="#为git-nodejs-gradle-maven等进行代理服务器的配置" class="headerlink" title="为git,nodejs,gradle,maven等进行代理服务器的配置"></a>为git,nodejs,gradle,maven等进行代理服务器的配置</h2><p><a href="http://www.snowdream.tech/2016/03/31/proxy-settings-with-shadowsocks/#IDEA" target="_blank" rel="noopener">http://www.snowdream.tech/2016/03/31/proxy-settings-with-shadowsocks/#IDEA</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://echohn.github.io/2016/05/29/to-build-the-fullstack-tools-for-over-the-wall/" target="_blank" rel="noopener">打造基于 ShadowSocks + ProxyChains 的全栈式科学上网工具</a></li>
<li><a href="https://www.gitbook.com/book/lvii/outman/details" target="_blank" rel="noopener">科学上网漫游指南</a></li>
<li><a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-%E5%B8%AE%E5%8A%A9" target="_blank" rel="noopener">Shadowsocks for OSX 帮助</a></li>
<li><a href="https://www.dou-bi.co/ss-jc9/" target="_blank" rel="noopener">Shadowsocks（Sock5代理）的PAC模式与全局模式与VPN的区别</a></li>
<li><a href="http://celerysoft.github.io/2016-01-17.html" target="_blank" rel="noopener">Shadowsocks-GUI For Mac OS使用指南</a></li>
<li><a href="https://adblockplus.org/en/filter-cheatsheet" target="_blank" rel="noopener">用户自定义规则参考之Adblock Plus filters explained</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haoweiguang.me/2017/05/08/MySQL中text、blob字段类型的不同/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Light微光">
      <meta itemprop="description" content="关于技术、产品、个人感悟等的记录">
      <meta itemprop="image" content="/uploads/2578.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微光的Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/08/MySQL中text、blob字段类型的不同/" itemprop="url">
                  MySQL中text、blob字段类型的不同
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-08 14:50:46" itemprop="dateCreated datePublished" datetime="2017-05-08T14:50:46+08:00">2017-05-08</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/08/MySQL中text、blob字段类型的不同/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2017/05/08/MySQL中text、blob字段类型的不同/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在MySQL中有两个字段类型容易让人感觉混淆，那就是TEXT与BLOB，特别是自己写博客程序的博主不知道改为自己的博客正文字段选择TEXT还是BLOB类型。</p>
<p>下面给出几点区别：</p>
<h3 id="一、主要差别"><a href="#一、主要差别" class="headerlink" title="一、主要差别"></a>一、主要差别</h3><p>TEXT与BLOB的主要差别就是BLOB保存二进制数据，TEXT保存字符数据。目前几乎所有博客内容里的图片都不是以二进制存储在数据库的，而是把图片上传到服务器然后正文里使用<code>&lt;img&gt;</code>标签引用，这样的博客就可以使用TEXT类型。而BLOB就可以把图片换算成二进制保存到数据库中。</p>
<h3 id="二、类型区别"><a href="#二、类型区别" class="headerlink" title="二、类型区别"></a>二、类型区别</h3><p>BLOB有4种类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同<br>TEXT也有4种类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些类型同BLOB类型一样，有相同的最大长度和存储需求。</p>
<h3 id="三、字符集"><a href="#三、字符集" class="headerlink" title="三、字符集"></a>三、字符集</h3><p>BLOB列没有字符集，并且排序和比较基于列值字节的数值值。TEXT列有一个字符集，并且根据字符集的校对规则对值进行排序和比较</p>
<h3 id="四、大小写"><a href="#四、大小写" class="headerlink" title="四、大小写"></a>四、大小写</h3><p>在TEXT或BLOB列的存储或检索过程中，不存在大小写转换，都一样！</p>
<h3 id="五、严格模式"><a href="#五、严格模式" class="headerlink" title="五、严格模式"></a>五、严格模式</h3><p>运行在非严格模式时，如果你为BLOB或TEXT列分配一个超过该列类型的最大长度的值值，值被截取以保证适合。如果截掉的字符不是空格，将会产生一条警告。使用严格SQL模式，会产生错误，并且值将被拒绝而不是截取并给出警告。</p>
<h3 id="六、其它"><a href="#六、其它" class="headerlink" title="六、其它"></a>六、其它</h3><p>当保存或检索BLOB和TEXT列的值时不删除尾部空格。<br>对于BLOB和TEXT列的索引，必须指定索引前缀的长度。<br>BLOB和TEXT列不能有默认值。<br>当排序时只使用该列的前max_sort_length个字节。max_sort_length的 默认值是1024.<br>当你想要使超过max_sort_length的字节有意义，对含长值的BLOB或TEXT列使用GROUP BY或ORDER BY的另一种方式是将列值转换为固定长度的对象。标准方法是使用SUBSTRING函数。<br>BLOB或TEXT对象的最大大小由其类型确定，但在客户端和服务器之间实际可以传递的最大值由可用内存数量和通信缓存区大小确定。你可以通过更改max_allowed_packet变量的值更改消息缓存区的大小，但必须同时修改服务器和客户端程序。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/2578.jpg" alt="Light微光">
            
              <p class="site-author-name" itemprop="name">Light微光</p>
              <p class="site-description motion-element" itemprop="description">关于技术、产品、个人感悟等的记录</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">33</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/haoweiguang" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i></a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:haoweiguang1986#gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i></a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Light微光</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.4.1</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'FR41X5AqL4IcM2cE5qBmHU1Q-gzGzoHsz',
        appKey: 'iXWuS118CuMxx8GkdQl53Xry',
        placeholder: '说两句吧~~',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: false
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
