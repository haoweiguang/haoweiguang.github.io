<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郝伟光的Notes</title>
  
  <subtitle>梦想是要有的，万一实现了呢</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-22T07:07:16.971Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>light</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员健康生活指南总目录</title>
    <link href="http://yoursite.com/2019/04/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%81%A5%E5%BA%B7%E7%94%9F%E6%B4%BB%E6%8C%87%E5%8D%97%E6%80%BB%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2019/04/22/程序员健康生活指南总目录/</id>
    <published>2019-04-22T07:07:16.000Z</published>
    <updated>2019-04-22T07:07:16.971Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>比特币的前世今生</title>
    <link href="http://yoursite.com/2018/06/25/bition-history/"/>
    <id>http://yoursite.com/2018/06/25/bition-history/</id>
    <published>2018-06-25T13:54:01.000Z</published>
    <updated>2018-06-27T15:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="比特币诞生的背景？"><a href="#比特币诞生的背景？" class="headerlink" title="比特币诞生的背景？"></a>比特币诞生的背景？</h3><p>2008年，金融危机，当时政府和银行管理经济的能力遭到各方质疑，信用降入谷底。美国政府向华尔街和底特律汽车公司注入大笔资金，美联储推出“量化宽松”政策，本质上就是大量印美钞刺激经济，金价上涨。相当于政府拿民众的钱来补贴这些资本家。</p><h3 id="为什么要创建加密电子货币？"><a href="#为什么要创建加密电子货币？" class="headerlink" title="为什么要创建加密电子货币？"></a>为什么要创建加密电子货币？</h3><p>其实一直有一帮自由主义者密码极客希望创建一种完全去中心化的电子现金系统。可以脱离政府自由流通和发展。</p><p>因为之前的信用卡或者货币都存在诸多问题。比如信用卡需要用户的真实身份，对于用户的隐私保护不够。货币就存在超发的情况，政府通过这种方式从民众手里掠夺财富。</p><h3 id="加密电子货币的坎坷之路"><a href="#加密电子货币的坎坷之路" class="headerlink" title="加密电子货币的坎坷之路"></a>加密电子货币的坎坷之路</h3><p>1983年大卫·乔姆（David Chaum）最早提出把加密技术运用于现金上的想法。写了论文《不可被追踪的交易》，使用盲签（blind signature）的技术来实现匿名的网络支付系统。1989年大卫·乔姆创建了数字现金公司；在之前系统基础上创建了电子现金（Ecash）系统，这个系统还有一个别名为网络现金（cyberbucks）系统。得到了微软和visa等巨头的支持。但是因为理念太超前，未得到大范围的支持，另外，该系统支持企业对企业转账也是其失败的原因。</p><p>1998年，戴伟（Wei Dai）阐述了一种匿名的、分布式的电子现金系统：b-money。B.money强调点对点的交易和不可更改的交易记录。每个交易者都保持对交易追踪的权力。但是B.money系统中，大卫并没有解决账本同步的问题。</p><p>1998年，尼克·萨博（Nick Szabo）发明了比特黄金（BitGold），提出了工作量证明机制。</p><p>哈尔·芬尼（Hal Finney）发明了哈希现金（HashCash）则把该机制进一步完善为一种”可重复<br>利用的工作量证明（RPOW）“。“RPOW”的特色在于可重复使用，且虽然控管权集中，但发行者没有通胀压力。</p><p>2008年10月31日，名不见经传的中本聪在metzdowd.com的密码学邮件组列表中发表了比特币白皮书《Bitcoin: A Peer-to-Peer Electronic Cash System》（《比特币：一种点对点的现金支付系统》)。</p><p>2009年1月3日，比特币网络诞生，中本聪本人发布了开源的第一版比特币客户端。</p><p>2009年1月3日，比特币网络的第一个区块诞生了。<br><img src="http://oo501cyv7.bkt.clouddn.com/15301134448308.jpg" alt=""></p><p>2009年1月9日，中本聪本人发布了开源的0.1版比特币客户端。<br><img src="http://oo501cyv7.bkt.clouddn.com/15301134591691.jpg" alt=""></p><p>2009年1月12日，第一笔比特币交易，中本聪发送了 10 比特币给开发者、密码学活动份子，Hal Finney（哈尔·芬尼）。</p><p>2009年10月5日，有记录的最早比特币汇率： 1 美元 = 1309.03 比特币。</p><p>参考：<br><a href="https://en.wikipedia.org/wiki/Ecash" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ecash</a><br><a href="https://daimajia.com/2018/02/10/blockchain-share-in-freesfund" target="_blank" rel="noopener">https://daimajia.com/2018/02/10/blockchain-share-in-freesfund</a><br><a href="https://zhuanlan.zhihu.com/p/32754317" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32754317</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;比特币诞生的背景？&quot;&gt;&lt;a href=&quot;#比特币诞生的背景？&quot; class=&quot;headerlink&quot; title=&quot;比特币诞生的背景？&quot;&gt;&lt;/a&gt;比特币诞生的背景？&lt;/h3&gt;&lt;p&gt;2008年，金融危机，当时政府和银行管理经济的能力遭到各方质疑，信用降入谷底。美国政
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="比特币" scheme="http://yoursite.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链和生产关系</title>
    <link href="http://yoursite.com/2018/03/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E7%94%9F%E4%BA%A7%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2018/03/11/区块链和生产关系/</id>
    <published>2018-03-11T09:04:27.000Z</published>
    <updated>2018-03-11T09:04:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>之所以说区块链是生产关系，就是因为区块链技术可以很完美地为不同参与者分配利益。各方人对这种利益的分配规则的认可，就是一种共识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之所以说区块链是生产关系，就是因为区块链技术可以很完美地为不同参与者分配利益。各方人对这种利益的分配规则的认可，就是一种共识。&lt;/p&gt;

      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>《数字黄金》读书笔记</title>
    <link href="http://yoursite.com/2018/02/04/2018-02-04/"/>
    <id>http://yoursite.com/2018/02/04/2018-02-04/</id>
    <published>2018-02-04T13:42:26.000Z</published>
    <updated>2018-02-04T14:41:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比特币的优势"><a href="#比特币的优势" class="headerlink" title="比特币的优势"></a>比特币的优势</h2><ul><li>匿名</li><li>绝对个人所有</li><li>跨境支付，速度快，手续费低</li><li>抗通货膨胀</li></ul><p>相比于现有货币，具备稀缺，分割性更强，耐用性更强，流通性更强</p><h2 id="比特币的价格"><a href="#比特币的价格" class="headerlink" title="比特币的价格"></a>比特币的价格</h2><p>全世界的黄金的价值应该是7万亿美元。假如比特币在全世界一半的地区流行，每个比特币的价格应该在50万美元</p><p>全球货币种类：170种（来自于维基百科），大概只有5%比较有价值，8种左右，美元、欧元、人民币、日元、英镑</p><h2 id="比特币的价值"><a href="#比特币的价值" class="headerlink" title="比特币的价值"></a>比特币的价值</h2><p>比特币的价值在于存储价值，不一定在交易上有多强悍的功能，类似黄金，比特币它自身有支付功能，但重点不在支付。它的重点是资产，是资产带支付，而不是支付带资产，反过来。什么意思呢？就是这个东西本身像黄金，也是一个商品嘛。但黄金有没有免费的支付，黄金从这边搬到那边要把它搬过去的 ，黄金没有脚不会走过去。比特币就不同，比特币是资产啊，但你叫它走过去，它可以自己走过去的。因为移动数字很便宜，没有成本嘛。所以它是资产带支付。</p><p>13年的时候百度的云保安服务就开始接收比特币支付，这个还挺让人惊奇的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;比特币的优势&quot;&gt;&lt;a href=&quot;#比特币的优势&quot; class=&quot;headerlink&quot; title=&quot;比特币的优势&quot;&gt;&lt;/a&gt;比特币的优势&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;匿名&lt;/li&gt;
&lt;li&gt;绝对个人所有&lt;/li&gt;
&lt;li&gt;跨境支付，速度快，手续费低&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="比特币" scheme="http://yoursite.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习笔记——配置监听</title>
    <link href="http://yoursite.com/2017/09/26/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%9B%91%E5%90%AC/"/>
    <id>http://yoursite.com/2017/09/26/Oracle学习笔记——配置监听/</id>
    <published>2017-09-26T07:58:26.000Z</published>
    <updated>2017-09-26T07:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是监听"><a href="#什么是监听" class="headerlink" title="什么是监听"></a>什么是监听</h3><p>如果你做过网络开发，对于监听listen就比较熟悉了，监听是什么，在网络开发中，就是监听某个端口，等待客户端的连接。同理，在Oracle中，监听的意思也和这差不多。</p><p>在Oracle数据库服务器中，通过一个叫“监听器”的组件接收来自客户端的连接请求，它是客户端和 服务器端中间的桥梁。监听器虽然在Oracle服务器端，但是它和Oracle主进程并不绑定，它是一个独立运行在服务器端的后台进程，独立于数据库运行。它负责对客户端传入的连接请求进行监听，并且对服务器端的连接负荷进行调整。当客户端准备建立一个到服务器端的连接时，监听器接收客户端的连接请求， 然后再将这个客户端连接请求交给服务器进行处理，一旦客户端和服务器建立连接，客户端和服务器以后就直接进行通信，而不再需要监听器的参与，这就好比师傅 领进门，修行靠个人。就如下图所示：<br><img src="http://oo501cyv7.bkt.clouddn.com/15064117419478.png" alt=""></p><ol><li>客户端向服务器端发出连接请求，监听器监听到客户端的连接请求；</li><li>监听器把客户端的连接请求交给数据库服务器进行处理；</li><li>经过监听器建立连接以后，客户端与服务器端就可以直接进行通信，而不再需要监听器的参与了。<br>以上就是监听器干的活，也就是说，你对数据库服务器的第一次，肯定会给监听器，如果监听器没有配好，你就甭想连数据库了。那么，怎么才能配好监听器呢？主要涉及以下三个文件：</li></ol><p><strong>listener.ora、sqlnet.ora和tnsnames.ora文件</strong></p><h4 id="listener-ora文件"><a href="#listener-ora文件" class="headerlink" title="listener.ora文件"></a>listener.ora文件</h4><p>打开listener.ora文件看看，贴上一部分有代表性的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#这是一个名为LISTENER1的监听器</span><br><span class="line">#监听的协议是TCP协议</span><br><span class="line">#监听的主机IP是127.0.0.1</span><br><span class="line">#监听的端口是1521端口</span><br><span class="line">LISTENER1 =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">    (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#记录了监听器LISTENER1服务的全局数据库名、数据库路径和数据库实例名</span><br><span class="line">SID_LIST_LISTENER1 =</span><br><span class="line">    (SID_LIST =</span><br><span class="line">        (SID_DESC =</span><br><span class="line">            (GLOBAL_DBNAME = ORCL)</span><br><span class="line">            (ORACLE_HOME = C:\Oracle11g\product\11.2.0\dbhome_1)</span><br><span class="line">            (SID_NAME = ORCL)</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="sqlnet-ora文件"><a href="#sqlnet-ora文件" class="headerlink" title="sqlnet.ora文件"></a>sqlnet.ora文件</h4><p>打开sqlnet.ora文件看看，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQLNET.AUTHENTICATION_SERVICES= (NTS)</span><br><span class="line">NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT)</span><br></pre></td></tr></table></figure><p>这个sqlnet.ora文件实际上就是一个配置文件，主要是和接下来说的tnsnames.ora配合使用。</p><h4 id="tnsnames-ora文件"><a href="#tnsnames-ora文件" class="headerlink" title="tnsnames.ora文件"></a>tnsnames.ora文件</h4><p>tnsnames.ora文件存放于客户端机器上，和sqlnet.ora文件配合使用。可以简单的看看tnsnames.ora文件中的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ORCL是个别名</span><br><span class="line">#这条信息记录了我们使用TCP协议，去连接IP地址为127.0.0.1，端口号为1521的数据库主机上服务名为orcl的数据库</span><br><span class="line">ORCL =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">        (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</span><br><span class="line">        (CONNECT_DATA =</span><br><span class="line">            (SERVER = DEDICATED)</span><br><span class="line">            (SERVICE_NAME = orcl)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">以后，我们还会配置更多的数据库连接信息，比如我要连接192.168.10.2主机上的数据库，我们只需要在tnsnames.ora中继续追加新的连接信息即可，比如：</span><br><span class="line"></span><br><span class="line">STDB =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">        (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.10.2)(PORT = 1521))</span><br><span class="line">        (CONNECT_DATA =</span><br><span class="line">            (SERVER = DEDICATED)</span><br><span class="line">            (SERVICE_NAME = stdb)</span><br><span class="line">        )</span><br><span class="line">     )</span><br></pre></td></tr></table></figure><h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><p>直接编辑listener.ora，就像下面这样，配置一个新的监听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LISTENER =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">    (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SID_LIST_LISTENER =</span><br><span class="line">    (SID_LIST =</span><br><span class="line">        (SID_DESC =</span><br><span class="line">            (GLOBAL_DBNAME = ORCL)</span><br><span class="line">            (ORACLE_HOME = C:\Oracle11g\product\11.2.0\dbhome_1)</span><br><span class="line">            (SID_NAME = ORCL)</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>你想在哪个数据库上配置一个新的监听，就修改对应的内容即可。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>启动监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl start &lt;监听器的名字&gt;</span><br><span class="line"></span><br><span class="line">// 启动名为LISTENER的监听器</span><br><span class="line">lsnrctl start LISTENER</span><br></pre></td></tr></table></figure><p>当我们不指定监听器的名字时，就默认启动LISTENER监听器；</p><p>关闭监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl stop &lt;监听器的名字&gt;</span><br><span class="line"></span><br><span class="line">// 关闭名为LISTENER的监听器</span><br><span class="line">lsnrctl stop LISTENER</span><br></pre></td></tr></table></figure><p>当我们不指定监听器的名字时，就默认关闭LISTENER监听器；</p><p>查看监听器的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl status &lt;监听器的名字&gt;</span><br><span class="line"></span><br><span class="line">// 查看名为LISTENER的监听器的运行状态</span><br><span class="line">lsnrctl status LISTENER</span><br></pre></td></tr></table></figure><p>当我们不指定监听器的名字时，就默认查看LISTENER监听器的状态。</p><p>测试连通性<br>可以使用工具<code>TNSPING</code></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.jellythink.com/archives/985" target="_blank" rel="noopener">Oracle学习笔记——配置监听</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是监听&quot;&gt;&lt;a href=&quot;#什么是监听&quot; class=&quot;headerlink&quot; title=&quot;什么是监听&quot;&gt;&lt;/a&gt;什么是监听&lt;/h3&gt;&lt;p&gt;如果你做过网络开发，对于监听listen就比较熟悉了，监听是什么，在网络开发中，就是监听某个端口，等待客户端的连接。
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习笔记——Linux设置Oracle环境变量</title>
    <link href="http://yoursite.com/2017/09/25/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Linux%E8%AE%BE%E7%BD%AEOracle%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2017/09/25/Oracle学习笔记——Linux设置Oracle环境变量/</id>
    <published>2017-09-25T08:32:06.000Z</published>
    <updated>2017-09-25T08:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>有三种设置方法，具体如下：</p><p>方法一：直接运行export命令定义变量,<strong>该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的</strong>，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p><p>以设置oracle环境变量为例<br><img src="http://oo501cyv7.bkt.clouddn.com/15063281966273.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export ORACLE_BASE=/data/app/oracle; </span><br><span class="line">export ORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1; </span><br><span class="line">export ORACLE_SID=orcl; </span><br><span class="line">export PATH=$ORACLE_HOME/bin:$PATH;</span><br></pre></td></tr></table></figure><p>方法二：在用户目录下的.bash_profile文件中增加变量，改变量<strong>仅会对当前用户有效</strong>，并且是“永久的”。</p><p><img src="http://oo501cyv7.bkt.clouddn.com/15063282260029.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/data/app/oracle;                          export ORACLE_BASE</span><br><span class="line">ORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1;      export ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl;                                       export ORACLE_SID</span><br><span class="line">PATH=$ORACLE_HOME/bin:$PATH;                           export PATH</span><br></pre></td></tr></table></figure><p>方法三： 在/etc/profile文件中添加变量，该变量将<strong>会对Linux下所有用户有效</strong>，并且是“永久的”。</p><p><img src="http://oo501cyv7.bkt.clouddn.com/15063282550340.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/data/app/oracle;                        export ORACLE_BASE</span><br><span class="line">ORACLE_HOME=$ORACLE_BASE/product/12.1.0/dbhome_1;    export ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl;                                     export ORACLE_SID</span><br><span class="line">PATH=$ORACLE_HOME/bin:$PATH;                         export PATH</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有三种设置方法，具体如下：&lt;/p&gt;
&lt;p&gt;方法一：直接运行export命令定义变量,&lt;strong&gt;该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的&lt;/strong&gt;，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用
      
    
    </summary>
    
      <category term="oracle" scheme="http://yoursite.com/categories/oracle/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境变量总结</title>
    <link href="http://yoursite.com/2017/09/25/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/09/25/Linux环境变量总结/</id>
    <published>2017-09-25T08:21:24.000Z</published>
    <updated>2017-09-25T08:22:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux是一个多用户多任务的操作系统，可以==在Linux中为不同的用户设置不同的运行环境==，具体做法是设置不同用户的环境变量。</p><h3 id="Linux环境变量分类"><a href="#Linux环境变量分类" class="headerlink" title="Linux环境变量分类"></a>Linux环境变量分类</h3><p>一、按照生命周期来分，Linux环境变量可以分为两类：<br>1、永久的：需要用户修改相关的配置文件，变量永久生效。<br>2、临时的：用户利用export命令，在当前终端下声明环境变量，关闭Shell终端失效。</p><p>二、按照作用域来分，Linux环境变量可以分为：<br>1、系统环境变量：系统环境变量对该系统中所有用户都有效。<br>2、用户环境变量：顾名思义，这种类型的环境变量只对特定的用户有效。</p><h3 id="Linux设置环境变量的方法"><a href="#Linux设置环境变量的方法" class="headerlink" title="Linux设置环境变量的方法"></a>Linux设置环境变量的方法</h3><p>一、在<code>/etc/profile</code>文件中添加变量 <strong>对所有用户生效（永久的）</strong><br>用vim在文件<code>/etc/profile</code>文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。<br>例如：编辑<code>/etc/profile</code>文件，添加<code>CLASSPATH</code>变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile    </span><br><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure><p>注：修改文件后要想马上生效还要运行<code>source /etc/profile</code>不然只能在下次重进此用户时生效。</p><p>二、在用户目录下的<code>.bash_profile</code>文件中增加变量 【<strong>对单一用户生效（永久的）</strong>】<br>用<code>vim ~/.bash_profile</code>文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash.profile</span><br><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure><p>注：修改文件后要想马上生效还要运行<code>$ source ~/.bash_profile</code>不然只能在下次重进此用户时生效。</p><p>三、直接运行export命令定义变量 【<strong>只对当前shell（BASH）有效（临时的）</strong>】<br>在shell的命令行下直接使用<code>export 变量名=变量值</code><br>定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p><h3 id="Linux环境变量使用"><a href="#Linux环境变量使用" class="headerlink" title="Linux环境变量使用"></a>Linux环境变量使用</h3><p>一、Linux中常见的环境变量有：</p><p>PATH：指定命令的搜索路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PATH声明用法：</span><br><span class="line">PATH=$PAHT:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:--------:&lt; PATH n &gt;</span><br><span class="line">export PATH</span><br><span class="line">你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效。</span><br><span class="line">可以利用echo $PATH查看当前当前系统PATH路径。</span><br></pre></td></tr></table></figure><p>HOME：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）。<br>HISTSIZE：指保存历史命令记录的条数。<br>LOGNAME：指当前用户的登录名。<br>HOSTNAME：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的<br>SHELL：指当前用户用的是哪种Shell。<br>LANG/LANGUGE：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。<br>MAIL：指当前用户的邮件存放目录。</p><p>注意：上述变量的名字并不固定，如HOSTNAME在某些Linux系统中可能设置成HOST</p><p>二、Linux也提供了修改和查看环境变量的命令，下面通过几个实例来说明：</p><p>echo 显示某个环境变量值 echo $PATH<br>export 设置一个新的环境变量 export HELLO=”hello” (可以无引号)<br>env 显示所有环境变量<br>set 显示本地定义的shell变量<br>unset 清除环境变量 unset HELLO<br>readonly 设置只读环境变量 readonly HELLO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux是一个多用户多任务的操作系统，可以==在Linux中为不同的用户设置不同的运行环境==，具体做法是设置不同用户的环境变量。&lt;/p&gt;
&lt;h3 id=&quot;Linux环境变量分类&quot;&gt;&lt;a href=&quot;#Linux环境变量分类&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="理解计算器机" scheme="http://yoursite.com/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E5%99%A8%E6%9C%BA/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="环境变量" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习笔记——在centos6.5上安装oracle11g</title>
    <link href="http://yoursite.com/2017/09/21/INSTALLATION-OF-ORACLE-11g-Release-2-on-CentOS-6-5-1/"/>
    <id>http://yoursite.com/2017/09/21/INSTALLATION-OF-ORACLE-11g-Release-2-on-CentOS-6-5-1/</id>
    <published>2017-09-21T07:24:51.000Z</published>
    <updated>2017-09-21T07:27:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统：CentOS6.5（64位）<br>数据库：Oracle 11g Release2 (64-bit)</p><h2 id="第一步：配置yum以下载oracle的依赖"><a href="#第一步：配置yum以下载oracle的依赖" class="headerlink" title="第一步：配置yum以下载oracle的依赖"></a>第一步：配置yum以下载oracle的依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cd /etc/yum.repos.d</span><br><span class="line"># wget https://public-yum.oracle.com/public-yum-ol6.repo</span><br><span class="line">If case you received Certificate error then, use following command</span><br><span class="line"># wget https://public-yum.oracle.com/public-yum-ol6.repo –no-check-certificate</span><br></pre></td></tr></table></figure><p><img src="http://oo501cyv7.bkt.clouddn.com/15059722614907.png" alt=""></p><h2 id="第二步：导入GPG-Keys"><a href="#第二步：导入GPG-Keys" class="headerlink" title="第二步：导入GPG Keys"></a>第二步：导入GPG Keys</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># wget https://public-yum.oracle.com/RPM-GPG-KEY-oracle-ol6 -O /etc/pki/rpm-gpg/RPM-GPG-KEY-oracle</span><br><span class="line">If case you received Certificate error, then use following command</span><br><span class="line"># wget https://public-yum.oracle.com/RPM-GPG-KEY-oracle-ol6 -O /etc/pki/rpm-gpg/RPM-GPG-KEY-oracle –no-check-certificate</span><br></pre></td></tr></table></figure><h2 id="第三步：安装oracle的依赖"><a href="#第三步：安装oracle的依赖" class="headerlink" title="第三步：安装oracle的依赖"></a>第三步：安装oracle的依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install oracle-rdbms-server-11gR2-preinstall</span><br></pre></td></tr></table></figure><h2 id="第四步：设置服务器hsotname"><a href="#第四步：设置服务器hsotname" class="headerlink" title="第四步：设置服务器hsotname"></a>第四步：设置服务器hsotname</h2><p><code># vi /etc/hosts</code><br><img src="http://oo501cyv7.bkt.clouddn.com/15059724528724.jpg" alt=""></p><p><code># vi /etc/sysconfig/network</code></p><p><img src="http://oo501cyv7.bkt.clouddn.com/15059725023188.jpg" alt=""></p><h2 id="第五步：在服务器创建oracle账户"><a href="#第五步：在服务器创建oracle账户" class="headerlink" title="第五步：在服务器创建oracle账户"></a>第五步：在服务器创建oracle账户</h2><p>在终端里执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># passwd oracle</span><br><span class="line">Change password for user oracle.</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD:it is based on a dictinory word</span><br><span class="line">BAD PASSWORD:is too simple</span><br><span class="line">Retype new password:</span><br><span class="line">passwd:all authentication tokens updated sucessfully.</span><br></pre></td></tr></table></figure><h2 id="第六步：配置文件“90-nproc-conf”"><a href="#第六步：配置文件“90-nproc-conf”" class="headerlink" title="第六步：配置文件“90-nproc.conf”"></a>第六步：配置文件“90-nproc.conf”</h2><p><code># vi /etc/security/limits.d/90-nproc.conf</code><br><img src="http://oo501cyv7.bkt.clouddn.com/15059730733689.jpg" alt=""></p><h2 id="第七步：配置selinux参数为“permissive”"><a href="#第七步：配置selinux参数为“permissive”" class="headerlink" title="第七步：配置selinux参数为“permissive”"></a>第七步：配置selinux参数为“permissive”</h2><p><code># vi /etc/selinux/config</code><br><img src="http://oo501cyv7.bkt.clouddn.com/15059731663187.jpg" alt=""></p><p><strong>重启服务器</strong>，然后使用『oracle』账户登录。使用其他账户登录的使用<code>su - oracle</code>切换到oracle账户下。</p><h2 id="第八步：在-“-bash-profile”-中添加oracle的相关配置"><a href="#第八步：在-“-bash-profile”-中添加oracle的相关配置" class="headerlink" title="第八步：在 “.bash_profile” 中添加oracle的相关配置"></a>第八步：在 “.bash_profile” 中添加oracle的相关配置</h2><p><code>[oracle@oracle~]# vi .bash_profile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_BASE=/home/oracle/app/oracle;                 export ORACLE_BASE</span><br><span class="line">ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1;    export ORACLE_HOME</span><br><span class="line">ORACLE_SID=orcl;                                     export ORACLE_SID</span><br><span class="line">PATH=$ORACLE_HOME/bin:$PATH;                         export PATH</span><br></pre></td></tr></table></figure><p>其中<code>ORACLE_BASE</code>、<code>ORACLE_HOME</code>一定要和oracle的安装目录一致，不一致需要后续做修改。<br><img src="http://oo501cyv7.bkt.clouddn.com/15059735547795.jpg" alt=""></p><p><code>[oracle@oracle~]# source .bash_profile #修改的文件立即生效</code></p><h2 id="第九步：在服务器的虚拟控制台调用图形界面安装"><a href="#第九步：在服务器的虚拟控制台调用图形界面安装" class="headerlink" title="第九步：在服务器的虚拟控制台调用图形界面安装"></a>第九步：在服务器的虚拟控制台调用图形界面安装</h2><p>转到存放oracle压缩文件的目录，执行<code>unzip</code>命令来解压缩文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[oracle@oracle~]# unzip /media/linux.x64_11gR2_database_1of2.zip </span><br><span class="line">[oracle@oracle~]# unzip /media/linux.x64_11gR2_database_2of2.zip</span><br></pre></td></tr></table></figure><p>文件会解压到一个<code>database</code>的目录。<br><img src="http://oo501cyv7.bkt.clouddn.com/15059738419976.jpg" alt=""></p><p>执行<code>./runInstaller</code>就可以调出图形化界面了。（==<strong>注意：这个需要在服务器上的终端来执行，SSH连接到服务器运行该命令是不行的，需要通过xhost单独设置。</strong>==）</p><p>在执行上边的命令后可能会遇到乱码，执行以下命令再重新运行<code>./runInstaller</code></p><p><code>[oracle@oracle~]# export LANG=en_US.utf-8</code></p><p>可能会遇到网络不通的情况，应该是hostname没有设置正确。需要在oracle账户下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[oracle@oracle~]# hostname oracle.xdf.cn</span><br><span class="line">[oracle@oracle~]# hostname</span><br><span class="line">oracle.xdf.cn #有这个信息出来就表示设置好了</span><br></pre></td></tr></table></figure><h3 id="输入接受一些安全问题的邮件地址（什么也不输入）"><a href="#输入接受一些安全问题的邮件地址（什么也不输入）" class="headerlink" title="输入接受一些安全问题的邮件地址（什么也不输入）"></a>输入接受一些安全问题的邮件地址（什么也不输入）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059753192771.jpg" alt=""></p><h3 id="选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件"><a href="#选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件" class="headerlink" title="选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件"></a>选择安装数据库软件并创建数据，也可以选择第二项仅安装数据库软件</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059753952572.jpg" alt=""></p><h3 id="选择服务器版本"><a href="#选择服务器版本" class="headerlink" title="选择服务器版本"></a>选择服务器版本</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754099248.jpg" alt=""></p><h3 id="单实例数据库"><a href="#单实例数据库" class="headerlink" title="单实例数据库"></a>单实例数据库</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754176925.jpg" alt=""></p><h3 id="高级模式安装"><a href="#高级模式安装" class="headerlink" title="高级模式安装"></a>高级模式安装</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754282905.jpg" alt=""></p><h3 id="添加支持的语言（可以不添加，只支持英文也行）"><a href="#添加支持的语言（可以不添加，只支持英文也行）" class="headerlink" title="添加支持的语言（可以不添加，只支持英文也行）"></a>添加支持的语言（可以不添加，只支持英文也行）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754352247.jpg" alt=""><br><img src="http://oo501cyv7.bkt.clouddn.com/15059754767809.jpg" alt=""></p><h3 id="选择要安装的版本"><a href="#选择要安装的版本" class="headerlink" title="选择要安装的版本"></a>选择要安装的版本</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059754873760.jpg" alt=""></p><h3 id="安装数据库目录"><a href="#安装数据库目录" class="headerlink" title="安装数据库目录"></a>安装数据库目录</h3><p>Oracle Base: /hywl/oracle/app<br>Sofeware Location: /hywl/oracle/app/product/11.1.1/db_1<br>这个根据自己服务器的账户名不同有所差别<br><img src="http://oo501cyv7.bkt.clouddn.com/15059755417537.jpg" alt=""><br><img src="http://oo501cyv7.bkt.clouddn.com/15059755472755.jpg" alt=""></p><h3 id="数据库用途"><a href="#数据库用途" class="headerlink" title="数据库用途"></a>数据库用途</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059755567343.jpg" alt=""></p><h3 id="数据库名及服务名（可以修改为自己想要）"><a href="#数据库名及服务名（可以修改为自己想要）" class="headerlink" title="数据库名及服务名（可以修改为自己想要）"></a>数据库名及服务名（可以修改为自己想要）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059755645841.jpg" alt=""></p><h3 id="开启自动内存管理"><a href="#开启自动内存管理" class="headerlink" title="开启自动内存管理"></a>开启自动内存管理</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059755911915.jpg" alt=""></p><h3 id="设置默认编码为UTF8（如果未添加中文支持，无这步操作）"><a href="#设置默认编码为UTF8（如果未添加中文支持，无这步操作）" class="headerlink" title="设置默认编码为UTF8（如果未添加中文支持，无这步操作）"></a>设置默认编码为UTF8（如果未添加中文支持，无这步操作）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756322355.jpg" alt=""></p><h3 id="启用Oracle企业管理控制台OEM"><a href="#启用Oracle企业管理控制台OEM" class="headerlink" title="启用Oracle企业管理控制台OEM"></a>启用Oracle企业管理控制台OEM</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756411025.jpg" alt=""></p><h3 id="选择数据库文件目录"><a href="#选择数据库文件目录" class="headerlink" title="选择数据库文件目录"></a>选择数据库文件目录</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756495504.jpg" alt=""></p><h3 id="自动备份设置：不启用"><a href="#自动备份设置：不启用" class="headerlink" title="自动备份设置：不启用"></a>自动备份设置：不启用</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756573188.jpg" alt=""></p><h3 id="设置数据库用户名和密码"><a href="#设置数据库用户名和密码" class="headerlink" title="设置数据库用户名和密码"></a>设置数据库用户名和密码</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756639425.jpg" alt=""></p><h3 id="授权的组"><a href="#授权的组" class="headerlink" title="授权的组"></a>授权的组</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756730616.jpg" alt=""></p><h3 id="检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）"><a href="#检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）" class="headerlink" title="检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）"></a>检查Oracle一些安装要求，包都已经安装，（直接忽略，因为yum安装过依赖了）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059756918240.jpg" alt=""></p><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757013456.jpg" alt=""></p><h3 id="安装即将完成"><a href="#安装即将完成" class="headerlink" title="安装即将完成"></a>安装即将完成</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757103123.jpg" alt=""><br><img src="http://oo501cyv7.bkt.clouddn.com/15059757171035.jpg" alt=""></p><h3 id="解锁用户SCOTT，-SCOTT的默认口令为tiger（这步也可以不设置）"><a href="#解锁用户SCOTT，-SCOTT的默认口令为tiger（这步也可以不设置）" class="headerlink" title="解锁用户SCOTT， SCOTT的默认口令为tiger（这步也可以不设置）"></a>解锁用户SCOTT， SCOTT的默认口令为tiger（这步也可以不设置）</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757313014.jpg" alt=""></p><h3 id="弹出“执行配置脚本”对对话框"><a href="#弹出“执行配置脚本”对对话框" class="headerlink" title="弹出“执行配置脚本”对对话框"></a>弹出“执行配置脚本”对对话框</h3><p><img src="http://oo501cyv7.bkt.clouddn.com/15059757540732.jpg" alt=""></p><p>安装完成了，系统提示需要用root账户执行两个脚本（orainstRoot.sh，root.sh）系统才算完全安装完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@oracle~]$ /hywl/oracle/app/oraInventory/orainstRoot.sh</span><br><span class="line"></span><br><span class="line">[root@oracle~]$ /hywl/oracle/app/product/11.2.0/dbhome_1/root.sh</span><br></pre></td></tr></table></figure><p>==<strong>很重要的一点，一定要记得在防火墙上开启<code>1521</code>端口，不然客户端是连接不上的，提示<code>no listner</code>。</strong>==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ su - root</span><br><span class="line"># /sbin/iptables -I INPUT -p tcp --dport 1251 -j ACCEPT </span><br><span class="line"># /etc/rc.d/init.d/iptables save</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.royalcyber.com/integration/installation-of-oracle-11g-release-2-on-centos-6-5/" target="_blank" rel="noopener">INSTALLATION OF ORACLE 11g Release 2 on CentOS 6.5</a></li><li><a href="http://77jiayuan.blog.51cto.com/386386/1569389" target="_blank" rel="noopener">CentOS 6.5_x64安装Oracle 11g R2</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;操作系统：CentOS6.5（64位）&lt;br&gt;数据库：Oracle 11g Release2 (64-bit)&lt;/p&gt;
&lt;h2 id=&quot;第一步：配置yum以下载oracle的依赖&quot;&gt;&lt;a href=&quot;#第一步：配置yum以下载oracle的依赖&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>idea在tomcat中的热部署</title>
    <link href="http://yoursite.com/2017/09/18/idea%E5%9C%A8tomcat%E4%B8%AD%E7%9A%84%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2017/09/18/idea在tomcat中的热部署/</id>
    <published>2017-09-18T03:32:58.000Z</published>
    <updated>2017-09-18T03:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="idea在tomcat中的热部署"><a href="#idea在tomcat中的热部署" class="headerlink" title="idea在tomcat中的热部署"></a>idea在tomcat中的热部署</h1><p>如果每次jsp页面或后台代码有修改，都得重启，确实比较麻烦，现在找到一种利用jrebel这个插件来实现热不熟。</p><p>在idea的插件库中找到jrebel，如下图<br><img src="http://oo501cyv7.bkt.clouddn.com/15057048125945.jpg" alt=""></p><p>因为这个插件是需要收费，这里有办法可以免费获取激活码：</p><p>方法1：JRebel有一个免费获得激活码的方法，登录<a href="https://my.jrebel.com这个网站（FQ），然后用Twitter或者Facebook账号登录这个网站，就能获得免费的激活码。" target="_blank" rel="noopener">https://my.jrebel.com这个网站（FQ），然后用Twitter或者Facebook账号登录这个网站，就能获得免费的激活码。</a><br><img src="http://oo501cyv7.bkt.clouddn.com/15057048682483.jpg" alt=""></p><p>在IDEA里面Help-&gt;JRebel-&gt;Activate，复制粘贴激活码就行了。<br><img src="http://oo501cyv7.bkt.clouddn.com/15057048855064.jpg" alt=""></p><p>方法2：<br>1.激活时填写的 <a href="http://idea.jrebel.ml/ilanyu" target="_blank" rel="noopener">http://idea.jrebel.ml/ilanyu</a> 及 lanyu19950316@gmail.com，授权服务器地址格式为：<a href="http://idea.jrebel.ml/{用户名}，邮箱随意填写，idea.jrebel.ml" target="_blank" rel="noopener">http://idea.jrebel.ml/{用户名}，邮箱随意填写，idea.jrebel.ml</a> 可能随时会被封，可使用反向代理工具代理 <a href="http://idea.lanyus.com/，即可稳定使用授权服务器。" target="_blank" rel="noopener">http://idea.lanyus.com/，即可稳定使用授权服务器。</a></p><p>2.该激活方法可离线使用6个月，可根据需要点击 Renew offline seat 即可更新离线过期时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;idea在tomcat中的热部署&quot;&gt;&lt;a href=&quot;#idea在tomcat中的热部署&quot; class=&quot;headerlink&quot; title=&quot;idea在tomcat中的热部署&quot;&gt;&lt;/a&gt;idea在tomcat中的热部署&lt;/h1&gt;&lt;p&gt;如果每次jsp页面或后台代码
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="idea" scheme="http://yoursite.com/tags/idea/"/>
    
      <category term="tomcat" scheme="http://yoursite.com/tags/tomcat/"/>
    
      <category term="热部署" scheme="http://yoursite.com/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务详解</title>
    <link href="http://yoursite.com/2017/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2017/07/21/数据库的事务/</id>
    <published>2017-07-21T04:25:01.000Z</published>
    <updated>2018-10-09T09:18:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p><blockquote><p>1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。<br>2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</p></blockquote><p>当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</p><p>但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p><blockquote><p>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。<br>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。<br>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。<br>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：</p><p>1、从A账号中把余额读出来（500）。<br>2、对A账号做减法操作（500-100）。<br>3、把结果写回A账号中（400）。<br>4、从B账号中把余额读出来（500）。<br>5、对B账号做加法操作（500+100）。<br>6、把结果写回B账号中（600）。</p><h3 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h3><p>保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。</p><p>为了实现原子性，需要通过日志：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。<br>如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。</p><p>原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。例如，事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上， 事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。</p><p>为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。用术语来说，就是多个事务并发执行后的状态，和它们串行执行后的状态是等价的。怎样实现隔离性，已经有很多人回答过了，原则上无非是两种类型的锁：1)悲观锁 2)乐观锁</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！</p><h2 id="原子性与隔离性"><a href="#原子性与隔离性" class="headerlink" title="原子性与隔离性"></a>原子性与隔离性</h2><p>一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关。<br>比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。</p><p>因此，事务的原子性与一致性缺一不可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.hollischuang.com/archives/898" target="_blank" rel="noopener">彻底理解数据库事务</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎</title>
    <link href="http://yoursite.com/2017/07/21/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2017/07/21/MySQL存储引擎/</id>
    <published>2017-07-21T04:25:01.000Z</published>
    <updated>2017-07-21T08:45:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于初学者来说我们通常不关注存储引擎，但是 MySQL 提供了多个存储引擎，包括处理事物安全表的引擎和处理非食物安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p><h2 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h2><p>MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。 存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><p>例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。我的电脑上安装的 MySQL 5.6.13 版，InnoDB就是作为默认的存储引擎。InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p><ul><li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li><li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li><li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li><li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li><li>支持自动增加列AUTO_INCREMENT属性。</li><li>从5.7开始innodb存储引擎成为默认的存储引擎。</li></ul><p>一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：</p><ul><li>tb_demo.frm，存储表定义。</li><li>tb_demo.MYD，存储数据。</li><li>tb_demo.MYI，存储索引。</li></ul><p>MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：</p><ol><li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li><li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li></ol><h3 id="MRG-MYISAM"><a href="#MRG-MYISAM" class="headerlink" title="MRG_MYISAM"></a>MRG_MYISAM</h3><p>MRG_MyISAM存储引擎是一组MyISAM表的组合，老版本叫 MERGE 其实是一回事儿，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。</p><p>Merge存储引擎的使用场景。对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。</p><ul><li>ENGINE=MERGE，指明使用MERGE引擎，其实是跟MRG_MyISAM一回事儿，也是对的，在MySQL 5.7已经看不到MERGE了。</li><li>UNION=(t1, t2)，指明了MERGE表中挂接了些哪表，可以通过alter table的方式修改UNION的值，以实现增删MERGE表子表的功能。比如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_merge <span class="keyword">engine</span>=<span class="keyword">merge</span> <span class="keyword">union</span>(tb_log1) insert_method=<span class="keyword">last</span>;</span><br></pre></td></tr></table></figure><ul><li>INSERT_METHOD=LAST，INSERT_METHOD指明插入方式，取值可以是：0 不允许插入；FIRST 插入到UNION中的第一个表； LAST 插入到UNION中的最后一个表。</li><li>MERGE表及构成MERGE数据表结构的各成员数据表必须具有完全一样的结构。每一个成员数据表的数据列必须按照同样的顺序定义同样的名字和类型，索引也必须按照同样的顺序和同样的方式定义。</li></ul><h3 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h3><p>使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。</p><p>一般在以下几种情况下使用Memory存储引擎：</p><ul><li>目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。</li><li>如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。</li><li>存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。</li><li>Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用&lt;、&gt;和&gt;=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和&lt;&gt;的操作符中，不适合在&lt;或&gt;操作符中，也同样不适合用在order by子句中。</li></ul><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p>CSV 存储引擎是基于 CSV 格式文件存储数据。</p><ul><li>CSV 存储引擎因为自身文件格式的原因，所有列必须强制指定 NOT NULL 。</li><li>CSV 引擎也不支持索引，不支持分区。</li><li>CSV 存储引擎也会包含一个存储表结构的 .frm 文件，还会创建一个 .csv 存储数据的文件，还会创建一个同名的元信息文件，该文件的扩展名为 .CSM ，用来保存表的状态及表中保存的数据量。</li><li>每个数据行占用一个文本行。</li></ul><p>因为 csv 文件本身就可以被Office等软件直接编辑，保不齐就有不按规则出牌的情况，如果出现csv 文件中的内容损坏了的情况，也可以使用 CHECK TABLE 或者 REPAIR TABLE 命令检查和修复</p><h3 id="ARCHIVE"><a href="#ARCHIVE" class="headerlink" title="ARCHIVE"></a>ARCHIVE</h3><p>Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。</p><h3 id="BLACKHOLE"><a href="#BLACKHOLE" class="headerlink" title="BLACKHOLE"></a>BLACKHOLE</h3><p>黑洞存储引擎，所有插入的数据并不会保存，BLACKHOLE 引擎表永远保持为空，写入的任何数据都会消失，</p><h3 id="PERFORMANCE-SCHEMA"><a href="#PERFORMANCE-SCHEMA" class="headerlink" title="PERFORMANCE_SCHEMA"></a>PERFORMANCE_SCHEMA</h3><p>主要用于收集数据库服务器性能参数。MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表，一般用于记录binlog做复制的中继。在这里有官方的一些介绍<a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema.html" target="_blank" rel="noopener">MySQL Performance Schema</a></p><h3 id="FEDERATED"><a href="#FEDERATED" class="headerlink" title="FEDERATED"></a>FEDERATED</h3><p>主要用于访问其它远程MySQL服务器一个代理，它通过创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，而后完成数据存取；在MariaDB的上实现是FederatedX</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>这里列举一些其它数据库提供的存储引擎，OQGraph、SphinxSE、TokuDB、Cassandra、CONNECT、SQUENCE。提供的名字仅供参考。</p><h2 id="常用引擎对比"><a href="#常用引擎对比" class="headerlink" title="常用引擎对比"></a>常用引擎对比</h2><p>不同存储引起都有各自的特点，为适应不同的需求，需要选择不同的存储引擎，所以首先考虑这些存储引擎各自的功能和兼容。</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>ARCHIVE</th></tr></thead><tbody><tr><td>存储限制(Storage limits)</td><td>64TB</td><td>No</td><td>YES</td><td>No</td></tr><tr><td>支持事物(Transactions)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>锁机制(Locking granularity)</td><td>行锁</td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引(B-tree indexes)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>T树索引(T-tree indexes)</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>哈希索引(Hash indexes)</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>全文索引(Full-text indexes)</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>集群索引(Clustered indexes)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>数据缓存(Data caches)</td><td>Yes</td><td>No</td><td>N/A</td><td>No</td></tr><tr><td>索引缓存(Index caches)</td><td>Yes</td><td>Yes</td><td>N/A</td><td>No</td></tr><tr><td>数据可压缩(Compressed data)</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>加密传输(Encrypted data<sup>[1]</sup>)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>集群数据库支持(Cluster databases support)</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>复制支持(Replication support<sup>[2]</sup>)</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>外键支持(Foreign key support)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>存储空间消耗(Storage Cost)</td><td>高</td><td>低</td><td>N/A</td><td>非常低</td></tr><tr><td>内存消耗(Memory Cost)</td><td>高</td><td>低</td><td>N/A</td><td>低</td></tr><tr><td>数据字典更新(Update statistics for data dictionary)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>备份/时间点恢复(backup/point-in-time recovery<sup>[3]</sup>)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>多版本并发控制(Multi-Version Concurrency Control/MVCC)</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>批量数据写入效率(Bulk insert speed)</td><td>慢</td><td>快</td><td>快</td><td>非常快</td></tr><tr><td>地理信息数据类型(Geospatial datatype support)</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>地理信息索引(Geospatial indexing support<sup>[4]</sup>)</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr></tbody></table><ol><li>在服务器中实现（通过加密功能）。在其他表空间加密数据在MySQL 5.7或更高版本兼容。</li><li>在服务中实现的，而不是在存储引擎中实现的。</li><li>在服务中实现的，而不是在存储引擎中实现的。</li><li>地理位置索引，InnoDB支持可mysql5.7.5或更高版本兼容</li></ol><h2 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h2><p>使用“SHOW VARIABLES LIKE ‘%storage_engine%’;” 命令在mysql系统变量搜索磨人设置的存储引擎，输入语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE '%storage_engine%';</span><br><span class="line">+<span class="comment">----------------------------------+---------+</span></span><br><span class="line">| Variable_name                    | Value   |</span><br><span class="line">|<span class="comment">----------------------------------+---------|</span></span><br><span class="line">| default_storage_engine           | InnoDB  |</span><br><span class="line">| default_tmp_storage_engine       | InnoDB  |</span><br><span class="line">| disabled_storage_engines         |         |</span><br><span class="line">| internal_tmp_disk_storage_engine | InnoDB  |</span><br><span class="line">+<span class="comment">----------------------------------+---------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span></span><br><span class="line"><span class="keyword">Time</span>: <span class="number">0.005</span>s</span><br></pre></td></tr></table></figure><p>使用“SHOW ENGINES;”命令显示安装以后可用的所有的支持的存储引擎和默认引擎，后面带上 \G 可以列表输出结果，你可以尝试一下如“SHOW ENGINES\G;”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINES;</span><br><span class="line">+<span class="comment">--------------------+---------+--------------------------------------+-------------+--------+-----------+</span></span><br><span class="line">| Engine             | Support | <span class="keyword">Comment</span>                              | Transactions| XA     | Savepoints|</span><br><span class="line">|<span class="comment">--------------------+---------+--------------------------------------+-------------+--------+-----------|</span></span><br><span class="line">| <span class="keyword">InnoDB</span>             | <span class="keyword">DEFAULT</span> | Supports transactions,               | YES         | YES    | YES       |</span><br><span class="line">|                    |         | <span class="keyword">row</span>-<span class="keyword">level</span> locking, <span class="keyword">and</span> foreign <span class="keyword">keys</span>  |             |        |           |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection <span class="keyword">of</span> identical MyISAM <span class="keyword">tables</span>| <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| <span class="keyword">MEMORY</span>             | YES     | <span class="keyword">Hash</span> based, <span class="keyword">stored</span> <span class="keyword">in</span> <span class="keyword">memory</span>, useful | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">|                    |         | <span class="keyword">for</span> <span class="keyword">temporary</span> <span class="keyword">tables</span>                 |             |        |           |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/<span class="literal">null</span> <span class="keyword">storage</span> <span class="keyword">engine</span> (anything   | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">|                    |         | you write <span class="keyword">to</span> it disappears)          |             |        |           |</span><br><span class="line">| MyISAM             | YES     | MyISAM <span class="keyword">storage</span> <span class="keyword">engine</span>                | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| CSV                | YES     | CSV <span class="keyword">storage</span> <span class="keyword">engine</span>                   | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| <span class="keyword">ARCHIVE</span>            | YES     | <span class="keyword">Archive</span> <span class="keyword">storage</span> <span class="keyword">engine</span>               | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | <span class="keyword">Performance</span> <span class="keyword">Schema</span>                   | <span class="keyword">NO</span>          | <span class="keyword">NO</span>     | <span class="keyword">NO</span>        |</span><br><span class="line">| FEDERATED          | <span class="keyword">NO</span>      | Federated MySQL <span class="keyword">storage</span> <span class="keyword">engine</span>       | &lt;<span class="literal">null</span>&gt;      | &lt;<span class="literal">null</span>&gt; | &lt;<span class="literal">null</span>&gt;    |</span><br><span class="line">+<span class="comment">--------------------+---------+--------------------------------------+-------------+--------+-----------+</span></span><br></pre></td></tr></table></figure><p>由上面命令输出，可见当前系统的默认数据表类型是InnoDB。当然，我们可以通过修改数据库配置文件中的选项，设定默认表类型。</p><h2 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h2><p>对上面数据库存储引擎有所了解之后，你可以在<code>my.cnf</code> 配置文件中设置你需要的存储引擎，这个参数放在 [mysqld] 这个字段下面的 default_storage_engine 参数值，例如下面配置的片段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">default_storage_engine=CSV</span><br></pre></td></tr></table></figure><p>在创建表的时候，对表设置存储引擎，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span>     <span class="built_in">int</span>(<span class="number">100</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span>   <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`mobile`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'手机'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>在创建用户表 user 的时候，SQL语句最后 ENGINE=InnoDB 就是设置这张表存储引擎为 InnoDB。</p><h2 id="如何选择合适的存储引擎"><a href="#如何选择合适的存储引擎" class="headerlink" title="如何选择合适的存储引擎"></a>如何选择合适的存储引擎</h2><p>提供几个选择标准，然后按照标准，选择对应的存储引擎即可，也可以根据<a href="#常用引擎对比">常用引擎对比</a>来选择你使用的存储引擎。使用哪种引擎需要根据需求灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。</p><ol><li>是否需要支持事务；</li><li>是否需要使用热备；</li><li>崩溃恢复，能否接受崩溃；</li><li>是否需要外键支持；</li><li>存储的限制；</li><li>对索引和缓存的支持；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于初学者来说我们通常不关注存储引擎，但是 MySQL 提供了多个存储引擎，包括处理事物安全表的引擎和处理非食物安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。&lt;/p&gt;
&lt;h2 id=&quot;存储引擎简介
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="数据库" scheme="http://yoursite.com/categories/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="存储引擎" scheme="http://yoursite.com/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>java HashMap工作原理和实现</title>
    <link href="http://yoursite.com/2017/07/20/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/07/20/java集合框架-HashMap实现原理分析/</id>
    <published>2017-07-20T10:21:57.000Z</published>
    <updated>2018-09-22T16:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-HashMap的数据结构"><a href="#1-HashMap的数据结构" class="headerlink" title="1. HashMap的数据结构"></a>1. HashMap的数据结构</h2><p>JDK1.8之前数据结构是<strong>数组和链表</strong>来实现对数据的存储，但这两者基本上是两个极端。JDK1.8当链表长度大于阈值（默认为8），将链表转化为红黑树，减少搜索时间。</p><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：<strong>寻址容易，插入和删除困难；</strong></p><h3 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h3><p>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O(N)。链表的特点是：<strong>寻址困难，插入和删除容易</strong>。</p><h3 id="1-3-哈希表"><a href="#1-3-哈希表" class="headerlink" title="1.3 哈希表"></a>1.3 哈希表</h3><p>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p><p>哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：<br><img src="http://oo501cyv7.bkt.clouddn.com/14847296397735.jpg" alt=""></p><p><img src="http://oo501cyv7.bkt.clouddn.com/14847296679116.jpg" alt=""></p><p>从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p><p>　　HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。</p><p>　　首先HashMap里面实现一个静态内部类<code>Entry</code>，其重要的属性有 <code>key , value, next</code>，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="line"> */</span><br><span class="line">transient Entry[] table;</span><br></pre></td></tr></table></figure><h2 id="2-HashMap的存取实现"><a href="#2-HashMap的存取实现" class="headerlink" title="2. HashMap的存取实现"></a>2. HashMap的存取实现</h2><p>既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 存储时:</span><br><span class="line">int hash = key.hashCode(); // 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">Entry[index] = value;</span><br><span class="line"></span><br><span class="line">// 取值时:</span><br><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">return Entry[index];</span><br></pre></td></tr></table></figure><h3 id="2-1-put"><a href="#2-1-put" class="headerlink" title="2.1 put"></a>2.1 put</h3><p>疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？<br>　　这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。到这里为止，HashMap的大致实现，我们应该已经清楚了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            return putForNullKey(value); //null总是放在数组的第一个链表中</span><br><span class="line">        int hash = hash(key.hashCode());</span><br><span class="line">        int i = indexFor(hash, table.length);</span><br><span class="line">        //遍历链表</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            //如果key在链表中已存在，则替换为新value</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); //参数e, 是Entry.next</span><br><span class="line">    //如果size超过threshold，则扩充table大小。再散列</span><br><span class="line">    if (size++ &gt;= threshold)</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p><h3 id="2-2-get"><a href="#2-2-get" class="headerlink" title="2.2 get"></a>2.2 get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            return getForNullKey();</span><br><span class="line">        int hash = hash(key.hashCode());</span><br><span class="line">        //先定位到数组元素，再遍历该元素处的链表</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != null;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-null-key的存取"><a href="#2-3-null-key的存取" class="headerlink" title="2.3 null key的存取"></a>2.3 null key的存取</h3><p>null key总是存放在Entry[]数组的第一个元素。</p><p>保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">            if (e.key == null) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(0, null, value, 0);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private V getForNullKey() &#123;</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">        if (e.key == null)</span><br><span class="line">            return e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-确定数组indexhashcode-tablelength取模"><a href="#2-4-确定数组indexhashcode-tablelength取模" class="headerlink" title="2.4 确定数组indexhashcode tablelength取模"></a>2.4 确定数组indexhashcode tablelength取模</h3><p>HashMap存取时，都需要计算当前key应该对应Entry[]数组哪个元素，即计算数组下标；算法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns index for hash code h.</span><br><span class="line">     */</span><br><span class="line">    static int indexFor(int h, int length) &#123;</span><br><span class="line">        return h &amp; (length-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>按位取并，作用上相当于取模mod或者取余%。<br><strong>这意味着数组下标相同，并不表示hashCode相同。</strong></p><h3 id="2-5-table初始大小"><a href="#2-5-table初始大小" class="headerlink" title="2.5 table初始大小"></a>2.5 table初始大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        .....</span><br><span class="line">        // Find a power of 2 &gt;= initialCapacity</span><br><span class="line">        int capacity = 1;</span><br><span class="line">        while (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= 1;</span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        threshold = (int)(capacity * loadFactor);</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意table初始大小并不是构造函数中的initialCapacity！！</p><p>而是 &gt;= initialCapacity的2的n次幂！！！！</p><h2 id="3-解决hash冲突的办法"><a href="#3-解决hash冲突的办法" class="headerlink" title="3. 解决hash冲突的办法"></a>3. 解决hash冲突的办法</h2><ol><li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li><li>再哈希法</li><li><strong>链地址法</strong></li><li>建立一个公共溢出区</li></ol><p>Java中hashmap的解决办法就是采用的链地址法。</p><h2 id="4-再散列rehash过程"><a href="#4-再散列rehash过程" class="headerlink" title="4. 再散列rehash过程"></a>4. 再散列rehash过程</h2><p>当哈希表的容量超过默认容量时，必须调整table的大小。当容量已经达到最大可能值时，那么该方法就将容量调整到Integer.MAX_VALUE返回，这时，需要创建一张新表，将原表的映射到新表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Rehashes the contents of this map into a new array with a</span><br><span class="line">     * larger capacity.  This method is called automatically when the</span><br><span class="line">     * number of keys in this map reaches its threshold.</span><br><span class="line">     *</span><br><span class="line">     * If current capacity is MAXIMUM_CAPACITY, this method does not</span><br><span class="line">     * resize the map, but sets threshold to Integer.MAX_VALUE.</span><br><span class="line">     * This has the effect of preventing future calls.</span><br><span class="line">     *</span><br><span class="line">     * @param newCapacity the new capacity, MUST be a power of two;</span><br><span class="line">     *        must be greater than current capacity unless current</span><br><span class="line">     *        capacity is MAXIMUM_CAPACITY (in which case value</span><br><span class="line">     *        is irrelevant).</span><br><span class="line">     */</span><br><span class="line">    void resize(int newCapacity) &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        int oldCapacity = oldTable.length;</span><br><span class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Transfers all entries from current table to newTable.</span><br><span class="line">     */</span><br><span class="line">    void transfer(Entry[] newTable) &#123;</span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        int newCapacity = newTable.length;</span><br><span class="line">        for (int j = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                src[j] = null;</span><br><span class="line">                do &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    //重新计算index</span><br><span class="line">                    int i = indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next = newTable[i];</span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; while (e != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="noopener">HashMap实现原理分析</a></li><li><a href="http://www.cnblogs.com/chenssy/p/3521565.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3521565.html</a></li><li><a href="http://www.importnew.com/10620.html" target="_blank" rel="noopener">http://www.importnew.com/10620.html</a></li><li><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-HashMap的数据结构&quot;&gt;&lt;a href=&quot;#1-HashMap的数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. HashMap的数据结构&quot;&gt;&lt;/a&gt;1. HashMap的数据结构&lt;/h2&gt;&lt;p&gt;JDK1.8之前数据结构是&lt;strong
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Servlet的线程安全问题</title>
    <link href="http://yoursite.com/2017/07/09/Servlet%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/07/09/Servlet的线程安全问题/</id>
    <published>2017-07-09T03:36:48.000Z</published>
    <updated>2017-07-09T03:37:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了有效利用JVM允许多个线程访问同一个实例的特性，来提高服务器性能。在非分布式系统中，Servlet容器只会维护一个Servlet的实例。</p><blockquote><p>如果 Web 应用中的 Servlet 被标注为分布式的,容器应该为每一个分布式应用程序的 JVM 维护一个 Servlet 实例池。</p></blockquote><p>Servlet容器通过维护一个线程池来处理多个请求，线程池中维护的是一组工作者线程（Worker Thread）。Servlet容器通过一个调度线程（Dispatcher Thread）来调度线程池中的线程。</p><p>当客户端的servlet请求到来时，调度线程会从线程池中选出一个工作者线程并将请求传递给该线程，该线程就会执行对应servlet实例的service方法。同样，当客户端发起另一个servlet请求时，调度线程会从线程池中选出另一个线程去执行servlet实例的service方法。Servlet容器并不关心这些线程访问的是同一个servlet还是不同的servlet，当多个线程访问同一个servlet时，该servlet实例的service方法将在多个线性中并发执行。</p><p>所以，<strong>==Servlet对象是单实例多线程，Servlet不是线程安全的==</strong></p><h2 id="为什么不安全？"><a href="#为什么不安全？" class="headerlink" title="为什么不安全？"></a>为什么不安全？</h2><p>先看两个定义：<br><strong>实例变量</strong>：实例变量在类中定义。类的每一个实例都拥有自己的实例变量，如果多个线程同时访问该实例的方法，而该方法又使用到实例变量，那么这些线程同时访问的是同一个实例变量，会共享该实例变量。</p><p><strong>局部变量</strong>：局部变量在方法中定义。每当一个线程访问局部变量所在的方法时，在线程的堆栈中就会创建这个局部变量，线程执行完这个方法时，该局部变量就被销毁。所有多个线程同时访问该方法时，每个线程都有自己的局部变量，不会共享。</p><p>看如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyServlet extends HttpServlet&#123;</span><br><span class="line"> private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line"> private String userName1 = null;//实例变量</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void doGet(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">         throws ServletException, IOException&#123;</span><br><span class="line">  userName1 = req.getParameter(&quot;userName1&quot;);</span><br><span class="line"></span><br><span class="line">  String userName2 = req.getParameter(&quot;userName2&quot;);//局部变量</span><br><span class="line"></span><br><span class="line">  //TODO 其他处理</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>userName1则是共享变量，多个线程会同时访问该变量，是线程不安全的。</p><p>userName2是局部变量，不管多少个线程同时访问，都是线程安全的。</p><h2 id="解决Servlet的线程安全问题"><a href="#解决Servlet的线程安全问题" class="headerlink" title="解决Servlet的线程安全问题"></a>解决Servlet的线程安全问题</h2><p>如果不涉及到全局共享变量，就直接使用局部变量</p><p>如果使用到全局共享的场景，可以使用加锁的方式.对全局变量的读写操作置于synchronized同步块中，这样不同线程排队依次执行该代码块，从而避免线程不安全情况发生。还可以使用线程安全的数据类型。比如hashtable,blockQueue等</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.hollischuang.com/archives/849" target="_blank" rel="noopener">Servlet 3.1规范学习笔记（一）——Servlet生命周期和线程安全性问题</a></li><li><a href="http://www.charlestech.info/2014/04/13/servlet-thread-security/" target="_blank" rel="noopener">Servlet的线程安全问题</a></li><li><a href="http://haoran-10.iteye.com/blog/2245065" target="_blank" rel="noopener">java servlet拾遗（3）-servlet 线程安全问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了有效利用JVM允许多个线程访问同一个实例的特性，来提高服务器性能。在非分布式系统中，Servlet容器只会维护一个Servlet的实例。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 Web 应用中的 Servlet 被标注为分布式的,容器应该为每一个分布式应用程序的 
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="servlet" scheme="http://yoursite.com/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet开发实战</title>
    <link href="http://yoursite.com/2017/07/09/Servlet%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2017/07/09/Servlet开发实战/</id>
    <published>2017-07-09T03:36:32.000Z</published>
    <updated>2017-07-16T08:19:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Web框架是开发者在使用某种语言编写Web应用服务端时关于架构的最佳实践。很多Web框架是从实际的Web项目抽取出来的，仅和Web的请求和响应处理有关，形成一个基础，在开发别的应用项目的时候则可以从这个剥离出来的基础做起，让开发者更关注更具体的业务问题，而不是Web的请求和响应的控制。 </p><p>框架很多，但套路基本类似，帮你隐藏很多关于 HTTP 协议细节内容，专注功能开发。 </p><p>但对一个初学者来说，过早的接触框架往往是事倍功半！同样一个问题，换一种框架你可能需要从头开始研究。 </p><p>下面是针对初学 Java 开发 Web 过程一些个人见解和思路，高手可略过。</p><p>然后将下面 XML 内容替换 Tomcat 下的 conf/server.xml 文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;</span><br><span class="line">Server&quot;8005&quot;shutdown&quot;SHUTDOWN&quot;</span><br><span class="line">  Service&quot;Catalina&quot;</span><br><span class="line">    Connector&quot;8080&quot;protocol&quot;HTTP/1.1&quot;connectionTimeout&quot;20000&quot;redirectPort&quot;8443&quot;URIEncoding&quot;UTF-8&quot;/&gt;</span><br><span class="line">    Engine&quot;Catalina&quot;defaultHost&quot;localhost&quot;</span><br><span class="line">      &quot;localhost&quot;</span><br><span class="line">    ContextdocBase&quot;D:\WORKDIR\ServletDemo\webapp&quot;reloadable&quot;true&quot;/&gt;</span><br><span class="line">      &lt;/</span><br><span class="line">    &lt;/Engine</span><br><span class="line">  &lt;/Service</span><br><span class="line">&lt;/Server</span><br></pre></td></tr></table></figure><p>再次启动 Tomcat 后在浏览器打开 <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 便可看到 Hello World 的输出信息。</p><h2 id="了解-Servlet-和-Filter"><a href="#了解-Servlet-和-Filter" class="headerlink" title="了解 Servlet 和 Filter"></a>了解 Servlet 和 Filter</h2><p>好了，我已经把环境搭起来了，接下来该干嘛呢？</p><p>前面的步骤为的是搭建一个测试的环境，然后让你了解一个最基本的 Java Web 项目的结构。</p><p>一个最基本的 Java Web 项目所需的 jar 包只需要一个 servlet-api.jar ，这个 jar 包中的类大部分都是接口，还有一些工具类，共有 2 个包，分别是 javax.servlet 和 javax.servlet.http。我把这个jar包放到了 webapp 目录外的一个独立 packages 文件夹里，这是因为所有的 Servlet 容器都带有这个包，你无需再放到Web项目里，我们放到这里只不过是编译的需要，运行是不需要的。如果你硬是把 servlet-api.jar 放到 webapp/WEB-INF/lib 目录下，那么 Tomcat 启动时还会报一个警告信息。</p><p>Java Web 项目还需要一个非常重要的配置文件 web.xml ，在这个项目中已经被我最小化了，只保留有用的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; </span><br><span class="line">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;demo.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>每个 servlet 都必须在 web.xml 中定义并进行 URL 映射配置，早期 Java 开发 Web 在没有框架满天飞的时候，这个文件会定义了大量的 servlet，或者有人为了省事干脆来一个 /servlet/* 来通过类名直接调用 Servlet。</p><p>Servlet 规范里还有另外一个非常重要而且非常有用的接口那就是 Filter 过滤器。</p><p>下面是一个最简单的 Filter 类以及相应的定义方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package demo;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">public class HelloFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void init(FilterConfig arg0) throws ServletException &#123;</span><br><span class="line">System.out.println(&quot;Filter 初始化&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest req, ServletResponse res,</span><br><span class="line">FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest)req;</span><br><span class="line">System.out.println(&quot;拦截 URI=&quot;+request.getRequestURI());</span><br><span class="line">chain.doFilter(req, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void destroy() &#123;</span><br><span class="line">System.out.println(&quot;Filter 结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 web.xml 中的配置必须放在 Servlet 的前面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; </span><br><span class="line"> &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;helloFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;demo.HelloFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;helloFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;demo.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;hello_world&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 时看看 Tomcat 控制台有何输出信息。</p><h2 id="Servlet-和-HTTP-的对应关系"><a href="#Servlet-和-HTTP-的对应关系" class="headerlink" title="Servlet 和 HTTP 的对应关系"></a>Servlet 和 HTTP 的对应关系</h2><p>Servlet 是 J2EE 最重要的一部分，有了 Servlet 你就是 J2EE 了，J2EE 的其他方面的内容择需采用。而 Servlet 规范你需要掌握的就是 servlet 和 filter 这两项技术。绝大多数框架不是基于 servlet 就是基于 filter，如果它要在 Servlet 容器上运行，就永远也脱离不开这个模型。</p><p>为什么 Servlet 规范会有两个包，javax.servlet 和 javax.servlet.http ，早先设计该规范的人认为 Servlet 是一种服务模型，不一定是依赖某种网络协议之上，因此就抽象出了一个 javax.servlet ，同时在提供一个基于 HTTP 协议上的接口扩展。但是从实际运行这么多年来看，似乎没有发现有在其他协议上实现的 Servlet 技术。</p><p>javax.servlet 和 javax.servlet.http 这两个包总共加起来也不过是三十四个接口和类。你需要通过 J2EE 的 JavaDoc 文档 熟知每个类和接口的具体意思。特别是下面几个接口必须熟知每个方法的意思和用途：</p><ul><li>HttpServlet</li><li>ServetConfig</li><li>ServletContext</li><li>Filter</li><li>FilterConfig</li><li>FilterChain</li><li>RequestDispatcher</li><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>一些 Listenser 类</li></ul><p>再次强调 HttpServletRequest 和 HttpServletResponse 这两个接口更应该是烂熟于心。</p><p>如果你从字面上无法理解某个方法的意思，你可以在前面那个项目的基础上做实验看看其输出，再不行你可以到讨论区提问，这样的提问非常明确，很多人都可以帮到你。</p><p>为什么我这么强调 HttpServletRequest 和 HttpServletResponse 这两个接口，因为 Web 开发是离不开 HTTP 协议的，而 Servlet 规范其实就是对 HTTP 协议做面向对象的封装，HTTP协议中的请求和响应就是对应了 HttpServletRequest 和 HttpServletResponse 这两个接口。</p><p>你可以通过 HttpServletRequest 来获取所有请求相关的信息，包括 URI、Cookie、Header、请求参数等等，别无它路。因此当你使用某个框架时，你想获取HTTP请求的相关信息，只要拿到 HttpServletRequest 实例即可。</p><p>而 HttpServletResponse接口是用来生产 HTTP 回应，包含 Cookie、Header 以及回应的内容等等。</p><h2 id="再谈谈-Session"><a href="#再谈谈-Session" class="headerlink" title="再谈谈 Session"></a>再谈谈 Session</h2><p>HTTP 协议里是没有关于 Session 会话的定义，Session 是各种编程语言根据 HTTP 协议的无状态这种特点而产生的。其实现无非就是服务器端的一个哈希表，哈希表的Key就是传递给浏览器的名为 jsessionid 的 Cookie 值。</p><p>当需要将某个值保存到 session 时，容器会执行如下几步：</p><p>a. 获取 jsessionid 值，没有的话就生成一个，也就是 request.getSession() 这个方法<br>b. 拿到的 HttpSession 对象实例就相当于一个哈希表，你可以往哈希表里存放数据(setAttribute)<br>c. 你也可以通过 getAttribute 来获取某个值</p><p>而这个名为 jsessionid 的 Cookie 在浏览器关闭时会自动删除。把 Cookie 的 MaxAge 值设为 -1 就能达到浏览器关闭自动删除的效果。</p><h2 id="关于-JSP"><a href="#关于-JSP" class="headerlink" title="关于 JSP"></a>关于 JSP</h2><p>任何一个 JSP 页面在执行的时候都会编译成一个 Servlet 类文件，如果是 Tomcat 的话，这些生成的 java 文件会放置在 {TOMCAT}/work 目录下对应项目的子目录中，例如 Tomcat 生成的类文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.jsp;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import javax.servlet.jsp.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public final class test_jsp extends org.apache.jasper.runtime.HttpJspBase</span><br><span class="line">    implements org.apache.jasper.runtime.JspSourceDependent &#123;</span><br><span class="line"></span><br><span class="line">  private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();</span><br><span class="line"></span><br><span class="line">  private static java.util.List&lt;String&gt; _jspx_dependants;</span><br><span class="line"></span><br><span class="line">  private javax.el.ExpressionFactory _el_expressionfactory;</span><br><span class="line">  private org.apache.tomcat.InstanceManager _jsp_instancemanager;</span><br><span class="line"></span><br><span class="line">  public java.util.List&lt;String&gt; getDependants() &#123;</span><br><span class="line">    return _jspx_dependants;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspInit() &#123;</span><br><span class="line">    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();</span><br><span class="line">    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspDestroy() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspService(final HttpServletRequest request, final HttpServletResponse response)</span><br><span class="line">        throws java.io.IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    final PageContext pageContext;</span><br><span class="line">    HttpSession session = null;</span><br><span class="line">    final ServletContext application;</span><br><span class="line">    final ServletConfig config;</span><br><span class="line">    JspWriter out = null;</span><br><span class="line">    final Object page = this;</span><br><span class="line">    JspWriter _jspx_out = null;</span><br><span class="line">    PageContext _jspx_page_context = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">      pageContext = _jspxFactory.getPageContext(this, request, response,</span><br><span class="line">      null, true, 8192, true);</span><br><span class="line">      _jspx_page_context = pageContext;</span><br><span class="line">      application = pageContext.getServletContext();</span><br><span class="line">      config = pageContext.getServletConfig();</span><br><span class="line">      session = pageContext.getSession();</span><br><span class="line">      out = pageContext.getOut();</span><br><span class="line">      _jspx_out = out;</span><br><span class="line"></span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;html&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;    &lt;title&gt;Test&lt;/title&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;    &lt;style&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;    &lt;/style&gt; \r\n&quot;);</span><br><span class="line">      out.write(&quot;  &lt;body&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;h1&gt;Test Demo (oschina)&lt;/h1&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;table cellspacing=\&quot;1\&quot; cellpadding=\&quot;5\&quot;&gt;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">Enumeration Names=request.getHeaderNames();</span><br><span class="line">while(Names.hasMoreElements())</span><br><span class="line">&#123;String name=(String)Names.nextElement();</span><br><span class="line">String value=request.getHeader(name);</span><br><span class="line"> </span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot; &lt;tr&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot; &lt;td&gt;&quot;);</span><br><span class="line">      out.print(name);</span><br><span class="line">      out.write(&quot;&lt;/td&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;  &lt;td&gt;&quot;);</span><br><span class="line">      out.print(value);</span><br><span class="line">      out.write(&quot;&lt;/td&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot; \r\n&quot;);</span><br><span class="line">      out.write(&quot; &lt;/tr&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot; &quot;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;/table&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;  &lt;/body&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">      if (!(t instanceof SkipPageException))&#123;</span><br><span class="line">        out = _jspx_out;</span><br><span class="line">        if (out != null &amp;&amp; out.getBufferSize() != 0)</span><br><span class="line">          try &#123; out.clearBuffer(); &#125; catch (java.io.IOException e) &#123;&#125;</span><br><span class="line">        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _jspxFactory.releasePageContext(_jspx_page_context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 servlet 中有一个包 javax.servlet.jsp 是跟 JSP 相关的一些接口规范定义。JSP 比 Servlet 方便的地方在于可直接修改立即生效，不像 Servlet 修改后必须重启容器才能生效。</p><p>因此 JSP 适合用来做视图，而 Servlet 则适合做控制层。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>罗哩罗嗦一大堆，归纳一下就是下面几点：</p><p>熟知 Servlet 规范之前，请不要学习任何框架<br>使用最简单的工具，不要任何向导和可视化<br>熟知 HTTP 协议<br>等你真的掌握了 Servlet 规范再去看框架，便会觉得一些都小菜。总之一点：不要被框架牵着鼻子走，框架是你的工具，它应该听你的！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.oschina.net/question/12_52027" target="_blank" rel="noopener">初学 Java Web 开发，请远离各种框架，从 Servlet 开发</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web框架是开发者在使用某种语言编写Web应用服务端时关于架构的最佳实践。很多Web框架是从实际的Web项目抽取出来的，仅和Web的请求和响应处理有关，形成一个基础，在开发别的应用项目的时候则可以从这个剥离出来的基础做起，让开发者更关注更具体的业务问题，而不是Web的请求和
      
    
    </summary>
    
      <category term="软件开发" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="servlet" scheme="http://yoursite.com/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet生命周期和工作原理</title>
    <link href="http://yoursite.com/2017/07/09/Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/07/09/Servlet生命周期和工作原理/</id>
    <published>2017-07-09T03:36:11.000Z</published>
    <updated>2017-07-09T03:38:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>名词解释：</p><ul><li>web.xml = 部署描述符（Deployment Descriptor ）</li><li>容器 = Servlet Container/Engine</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>主要有四个过程：init-&gt;service-&gt;doGet/doPost-&gt;destory</p><p>第一步：加载和实例化</p><ol><li>Servlet容器启动时自动装载某些Servlet，实现它只需要在web.XML文件中的<code>&lt;Servlet&gt;&lt;/Servlet&gt;</code>之间添加如下代码：<br><code>&lt;loadon-startup&gt;1&lt;/loadon-startup&gt;</code></li><li>在Servlet容器启动后，客户首次向Servlet发送请求</li><li>Servlet类文件被更新后，重新装载Servlet</li></ol><p>Servlet被装载后，Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化。在Servlet的整个生命周期内，init()方法只被调用一次。</p><p>第二步：初始化 </p><p>实例化后会立马进行初始化，并传递实现ServletConfig接口的对象。也就是执行init方法。在init（）方法中，Servlet可以部署描述符中读取配置参数，或者执行任何其他一次性活动。在Servlet的整个生命周期类，init（）方法只被调用一次。</p><p>第三步：请求处理</p><p>初始化后，Servlet就可以接受请求了。<br>基本方式是执行Servlet接口中的service方法。并把请求和响应对象作为参数传递。当并行的请求到来时，多个service（）方法能够同时运行在独立的线程中。<br>service()方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet()、doPost()、doPut()，doDelete() 等方法。<br>当然，API也提供了HttpServlet抽象类，其中有doGet、doPost等特殊方法。<br>注意：任意的容器按照规范必须实现上述几种方法，所以你的代码写在这几个方法中都可以。</p><p>第四步：终止服务</p><p>容器会在合适的时候销毁某个Servlet对象，这个策略取决于容器的开发者/商。<br>在容器关闭的时候Servlet对象一定会被销毁。<br>当1或2发生时，也就是Servlet对象被销毁时，destroy方法会被调用</p><p><img src="http://oo501cyv7.bkt.clouddn.com/14995681398150.png" alt=""></p><p>PS:<strong>Servlet的生命（周期）是由容器管理的，换句话说，Servlet程序员不能用代码控制其生命。</strong></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>首先简单解释一下Servlet接收和响应客户请求的过程，首先客户发送一个请求，Servlet是调用service()方法对请求进行响应的，通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet,doPost等这些方法，然后再进入对应的方法中调用逻辑层的方法，实现对客户的响应。在Servlet接口和GenericServlet中是没有doGet,doPost等等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息，所以，我们每次定义一个Servlet的时候，都必须实现doGet或doPost等这些方法。</p><p>每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。所以我们定义Servlet的时候只需要继承HttpServlet即可。</p><p>Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类，所以HttpServlet中实现了service()方法，并将请求ServletRequest,ServletResponse强转为HttpRequest和HttpResponse。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void service(ServletRequest req,ServletResponse res) </span><br><span class="line">  throws ServletException,IOException</span><br><span class="line">&#123;</span><br><span class="line">      HttpRequest request;</span><br><span class="line">      HttpResponse response;</span><br><span class="line"> </span><br><span class="line">     try</span><br><span class="line">     &#123;</span><br><span class="line">         req = (HttpRequest)request;</span><br><span class="line">         res = (HttpResponse)response;</span><br><span class="line">      &#125;catch(ClassCastException e)</span><br><span class="line">      &#123;</span><br><span class="line">         throw new ServletException(&quot;non-HTTP request response&quot;); </span><br><span class="line">      &#125;</span><br><span class="line">      service(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的最后调用了HTTPServlet自己的service(request,response)方法，然后根据请求去调用对应的doXXX方法，因为HttpServlet中的doXXX方法都是返回错误信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest res,HttpServletResponse resp)</span><br><span class="line">  throws ServletException,IOException</span><br><span class="line">&#123;</span><br><span class="line">   String protocol = req.getProtocol();</span><br><span class="line">   String msg = IStrings.getString(&quot;http.method_get_not_supported&quot;);</span><br><span class="line">   if(protocol.equals(&quot;1.1&quot;))</span><br><span class="line">   &#123;</span><br><span class="line">      resp.sendError(HttpServletResponse.SC.METHOD.NOT.ALLOWED,msg);</span><br><span class="line">    &#125;</span><br><span class="line">   esle</span><br><span class="line">    &#123;</span><br><span class="line">      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以需要我们在自定义的Servlet中override这些方法！</p><h3 id="Servlet响应请求阶段"><a href="#Servlet响应请求阶段" class="headerlink" title="Servlet响应请求阶段"></a>Servlet响应请求阶段</h3><p>对于用户到达Servlet的请求，Servlet容器会创建特定于这个请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service方法。service方法从ServletRequest对象获得客户请求信息，处理该请求，并通过ServletResponse对象向客户返回响应信息。</p><p>对于Tomcat来说，它会将传递过来的参数放在一个Hashtable中，该Hashtable的定义是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Hashtable&lt;String String[]&gt; paramHashStringArray = new Hashtable&lt;String String[]&gt;();</span><br></pre></td></tr></table></figure><p>这是一个String–&gt;String[]的键值映射。</p><p>HashMap线程不安全的，Hashtable线程安全。</p><h3 id="Servlet终止阶段"><a href="#Servlet终止阶段" class="headerlink" title="Servlet终止阶段"></a>Servlet终止阶段</h3><p>当WEB应用被终止，或Servlet容器终止运行，或Servlet容器重新装载Servlet新实例时，Servlet容器会先调用Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。</p><h3 id="Servlet何时被创建"><a href="#Servlet何时被创建" class="headerlink" title="Servlet何时被创建"></a>Servlet何时被创建</h3><ol><li><p>默认情况下，当WEB客户第一次请求访问某个Servlet的时候，WEB容器将创建这个Servlet的实例。</p></li><li><p>当web.xml文件中如果<servlet>元素中指定了<load-on-startup>子元素时，Servlet容器在启动web服务器时，将按照顺序创建并初始化Servlet对象。</load-on-startup></servlet></p></li></ol><p>注意：在web.xml文件中，某些Servlet只有<serlvet>元素，没有<servlet-mapping>元素，这样我们无法通过url的方式访问这些Servlet，这种Servlet通常会在<servlet>元素中配置一个<load-on-startup>子元素，让容器在启动的时候自动加载这些Servlet并调用init()方法，完成一些全局性的初始化工作。</load-on-startup></servlet></servlet-mapping></serlvet></p><h3 id="Web应用何时被启动"><a href="#Web应用何时被启动" class="headerlink" title="Web应用何时被启动"></a>Web应用何时被启动</h3><ol><li>当Servlet容器启动的时候，所有的Web应用都会被启动</li><li>控制器启动web应用</li></ol><h2 id="JSP运行原理"><a href="#JSP运行原理" class="headerlink" title="JSP运行原理"></a>JSP运行原理</h2><p>当Web服务器上的JSP页面第一次被请求执行时，JSP引擎先将JSP页面文件转译成一个Java文件，即Servlet，Java Servlet是基于服务器端编程的API，用Java Servlet编写的Java程序称为servlet，servlet通过HTML与客户交互。服务器将前面转译成的Java文件编译成字节码文件，再执行这个字节码文件来响应客户的请求。当这个JSP页面再次被请求时，只要该JSP文件没有被改动，JSP引擎就直接调用已装载的Servlet。</p><p>JSP工作原理<br>所有JSP页面，在执行的时候都会被服务器端的JSP引擎转换为Servelet（.java），然后又由JSP引擎调用Java编译器，将Servelet（.java）编译为Class文件（.class），并由Java虚拟机（JVM）解释执行。下面验证这一点：<br>有一个JSP页面Test.jsp，在浏览器地址栏中输入<a href="http://localhost:8080/Test.jsp" target="_blank" rel="noopener">http://localhost:8080/Test.jsp</a> ,将会出现执行结果。同时在%CATALINA_HOME%/work/Catalina/localhost下多出两个文件：_Test_jsp.java和_Test_jsp.class，他们分别就是Servelet和Class文件</p><h2 id="JSP和servlet的运行原理探讨"><a href="#JSP和servlet的运行原理探讨" class="headerlink" title="JSP和servlet的运行原理探讨"></a>JSP和servlet的运行原理探讨</h2><p>&lt;%page language=”java”%&gt;在服务器端执行.<br>客户端用户填写 HTML 表单，发送请求。将请求发送给 服务器端servlet(tomcat是servlet的容器)。 servlet 将该 HTTP 请求转换成一个 MQSeries 消息，并将其放入一个队列。 后端应用程序处理该消息，然后通过消息队列发回一个应答。 servlet 从队列中检索消息，并将其存放在一个 Java Bean 中。 然后 servlet 调用编译过的 Java Server Page(JSP) 并动态生成结果 HTML 页面。 JSP 从 Java Bean 检索出该页面需要的数据，将其合并到 HTML，然后将结果页面发送给客户端。</p><p>JSP中的html代码和javascrīpt代码不会在服务器端执行，servlet 调用编译过的 Java Server Page(JSP) ，也就是运行由JSP编译成的class文件(运行的代码包括actionBean,formBean,一般的bean 和内嵌在JSP的Java代码).</p><p>一个Web运行程序（网站）可以有多个servlet，一般认为一个action就是一个servlet.</p><p>所谓Servlet是指运行在服务器端的Java小程序。用于响应客户端的请求。在默认情况下，Servlet采用一种无状态的请求-响应处理方式。Servlet代码的主要作用是为了增强Java服务器端的功能，它运行在服务器端，用于接收并且处理浏览器客户端发出的请求，该请求是通过配置文件web.xml的相关配置进行转发。也就是说Servlet是一个标准的Java类，它符合Java类的一般规则。和一般的Java类不同之处只是在于Servlet可以处理Http请求。</p><ol><li>servlet是持久的。servlet只需Web服务器加载一次,后续又用到这个servlet，就不需要再加载。(所谓加载是指servlet加载进JVM运行)</li><li>servlet是与平台无关的。</li><li>servlet是可扩展的。</li></ol><h2 id="Servlet与JSP的比较"><a href="#Servlet与JSP的比较" class="headerlink" title="Servlet与JSP的比较"></a>Servlet与JSP的比较</h2><ul><li>有许多相似之处，都可以生成动态网页。</li><li>JSP的优点是擅长于网页制作，生成动态页面比较直观，缺点是不容易跟踪与排错。</li><li>Servlet是纯Java语言，擅长于处理流程和业务逻辑，缺点是生成动态网页不直观。</li></ul><p>参考：</p><ul><li><a href="http://blog.csdn.net/u010297957/article/details/51498018" target="_blank" rel="noopener">Servlet的历史与规范</a></li><li><a href="http://www.hollischuang.com/archives/849" target="_blank" rel="noopener">Servlet 3.1规范学习笔记（一）——Servlet生命周期和线程安全性问题</a></li><li><a href="http://www.cnblogs.com/cuiliang/archive/2011/10/21/2220671.html" target="_blank" rel="noopener">Servlet生命周期与工作原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;名词解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;web.xml = 部署描述符（Deployment Descriptor ）&lt;/li&gt;
&lt;li&gt;容器 = Servlet Container/Engine&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="servlet" scheme="http://yoursite.com/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet容器详解</title>
    <link href="http://yoursite.com/2017/07/09/Servlet%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/07/09/Servlet容器详解/</id>
    <published>2017-07-09T03:34:54.000Z</published>
    <updated>2017-07-09T03:35:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Servlet-容器？"><a href="#什么是-Servlet-容器？" class="headerlink" title="什么是 Servlet 容器？"></a>什么是 Servlet 容器？</h2><p>容器就是你的程序运行时需要的环境。<br>Servlet Container（Servlet 容器） 是 Web 服务器或者应用服务器的一部分，用于提供基于请求/响应发送模式的网络服务，解码基于 MIME 的请求，并且格式化基于 MIME 的响应。Servlet 容器同时也包含和管理他们的生命周期里Servlet。</p><p>Servlet容器可以嵌入到宿主的 Web 服务器中，或者通过 Web 服务器的本地扩展 API 单独作为附加组件安装。Servelt 容器也可能内嵌或安装到启用 Web 功能的应用服务器中。</p><p>所有的 Servlet 容器必须支持 HTTP 协议用于请求和响应，但额外的基于 请求/响应 的协议，如 HTTPS (HTTP over SSL)的支持是可选的。对于 HTTP 规范需要版本，容器必须支持 HTTP/1.0 和 HTTP/1.1。因为容器或许支持 RFC2616 (HTTP/1.1)描述的缓存机制，缓存机制可能在将客户端请求交给 Servlet 处理之前修改它们，也可能在将 Servlet 生成的响应发送给客户端之前修改它们，或者可能根据 RFC2616 规范直接对请求作出响应而不交给 Servlet 进行处理。</p><p>Servlet 容器应该使 Servlet 执行在一个安全限制的环境中。在 Java 平台标准版（J2SE, v.1.3 或更高） 或者 Java平台企业版(Java EE, v.1.3 或更高) 的环境下，这些限制应该被放置在 Java 平台定义的安全许可架构中。比如，高端的应用服务器为了保证容器的其他组件不受到负面影响可能会限制 Thread 对象的创建。</p><p>Java SE 7 是构建 Servlet 容器最低的 Java平 台版本。</p><h2 id="常见的Servlet容器"><a href="#常见的Servlet容器" class="headerlink" title="常见的Servlet容器"></a>常见的Servlet容器</h2><p>Tomcat，apache,Jetty是Servlet的运行环境，即一个Servlet容器,做过java web开发的应该都知道。 </p><h2 id="Servlet的执行流程"><a href="#Servlet的执行流程" class="headerlink" title="Servlet的执行流程"></a>Servlet的执行流程</h2><ol><li>Servlet容器的作用是负责处理客户请求，当客户请求来到时，Servlet容器获取请求，然后调用某个Servlet，并把Servlet的执行结果返回给客户</li><li>Servlet容器的工作过程是：当客户请求某个资源时，Servlet容器使用ServletRequest对象把客户的请求信息封装起来，然后调用java Servlet API中定义的Servlet的一些生命周期方法，完成Servlet的执行，接着把Servlet执行的要返回给客户的结果封装到 ServletResponse对象中，最后Servlet容器把客户的请求发送给客户，完成为客户的一次服务过程。每一个Servlet的类都执行 init（）、service（）、destory（）三个函数的自动调用，在启动时调用一次init（）函数用以进行参数的初始化，在服务期间每当接收到对该Servlet的请求时都会调用Service（）函数执行该Servlet的服务操作，当容器销毁时调用一次destory（）函数。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-Servlet-容器？&quot;&gt;&lt;a href=&quot;#什么是-Servlet-容器？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Servlet 容器？&quot;&gt;&lt;/a&gt;什么是 Servlet 容器？&lt;/h2&gt;&lt;p&gt;容器就是你的程序运行时需要的环境。&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="servlet" scheme="http://yoursite.com/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet的概述</title>
    <link href="http://yoursite.com/2017/07/08/Servlet%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/07/08/Servlet的概述/</id>
    <published>2017-07-08T13:51:05.000Z</published>
    <updated>2017-07-08T13:57:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Servlet？"><a href="#什么是Servlet？" class="headerlink" title="什么是Servlet？"></a>什么是Servlet？</h2><p>servlet 是基于 Java 的 Web 组件，由容器（Servlet容器）进行管理，来生成动态内容。像其他基于 Java 的组件技术一样，servlet 也是基于平台无关的 Java 类格式，被编译为平台无关的字节码，可以被基于 Java 技术的 Web 服务器动态加载并运行。容器（Container），有时候也叫做 servlet 引擎，是 Web 服务器为支持 servlet 功能扩展的部分。客户端通过 servlet 容器实现的 request/response paradigm（请求/应答模式） 与 Servlet 进行交互。</p><h2 id="Servlet与其他技术的对比"><a href="#Servlet与其他技术的对比" class="headerlink" title="Servlet与其他技术的对比"></a>Servlet与其他技术的对比</h2><p>从功能上看，servlet 位于Common Gateway Interface（公共网关接口，简称 CGI）程序和私有的服务器扩展如 Netscape Server API（NSAPI）或 Apache Modules 这两者之间。<br>相对于其他服务器扩展机制 Servlet 有如下优势：</p><ul><li>它们通常比 CGI 脚本更快，因为采用不同的处理模型。</li><li>它们采用标准的 API 从而支持更多的Web 服务器。</li><li>它们拥有 Java 编程语言的所有优势，包括容易开发和平台无关。</li><li>它们可以访问 Java 平台提供的大量的 API。</li></ul><h2 id="Servlet的历史"><a href="#Servlet的历史" class="headerlink" title="Servlet的历史"></a>Servlet的历史</h2><h3 id="Servlet的由来"><a href="#Servlet的由来" class="headerlink" title="Servlet的由来"></a>Servlet的由来</h3><ul><li>背景<br>上世纪90年代，随着Internet和浏览器的飞速发展，基于浏览器的B/S模式随之火爆发展起来。<br>最初，用户使用浏览器向WEB服务器发送的请求都是请求静态的资源，比如html、css等。<br>但是可以想象：根据用户请求的不同动态的处理并返回资源是理所当然必须的要求。</li><li><p>CGI （现在几乎不用了）<br>必须要满足上述需求，所以CGI（Common Gateway Interface）出现了。CGI程序使用C、Shell Script或Perl编写，CGI是为特定操作系统编写的（如UNIX或Windows），不可移植，CGI程序对每个请求产生新的进程去处理。步骤如下：</p><ol><li>WEB服务器接收一个用户请求；</li><li>WEB服务器将请求转交给CGI程序处理；</li><li>CGI程序将处理结果返回给WEB服务器；</li><li>WEB服务器把结果送回用户； </li></ol></li><li><p>Java<br>与此同时，Java语言也在迅速发展。必然的，Java要支持上述需求。<br>Java有两种方案来实现动态需求，它们都属于JavaEE技术的一部分。</p></li></ul><ol><li>applet （中文意思：小程序）<br>这是纯客户端（浏览器）方案（基本被flash、ajax和HTMLL5替代），applet就是浏览器中的Java插件，浏览器通过它就能够解释执行WEB服务器发过来的Java代码，从而实现动态。但是，显然这种方案不好，既需要浏览器必须安装插件，又受限于浏览器，所以Java代码不能太多和太复杂。<br>比如，如果安装了JRE，虽然IE浏览器会自动启用Java插件，但是你可以轻易禁止。再比如Chrome还需要你手动去安装插件才行，普通用户连Java是什么都不知道他怎么会去装呢？<br>IE如下图：<br><img src="http://oo501cyv7.bkt.clouddn.com/14995213644794.png" alt=""></li><li>Servlet<br>既然浏览器不方便执行Java代码，那自然还是服务端来执行了，所以Servlet出现了，Servlet就是server端的applet的意思。</li></ol><h3 id="Servlet的工作原理概述"><a href="#Servlet的工作原理概述" class="headerlink" title="Servlet的工作原理概述"></a>Servlet的工作原理概述</h3><p>其实Servlet的工作原理基本类似上面的CGI，不过Servlet比CGI更好。</p><ol><li><p>WEB服务器接收一个用户请求；</p></li><li><p>WEB服务器将请求转交给WEB服务器关联的Servlet容器；</p></li><li><p>Servlet容器找到对应的Servlet并执行这个Servlet；</p></li><li><p>Servlet容器将处理结果返回给WEB服务器；</p></li><li><p>WEB服务器把结果送回用户；</p></li></ol><h3 id="Servlet的发展"><a href="#Servlet的发展" class="headerlink" title="Servlet的发展"></a>Servlet的发展</h3><ol><li><p>Servlet诞生后，SUN公司很快发现了Servlet编程非常繁琐，这是因为：</p><ul><li>Servlet代码中有大量冗余代码，每个Servlet都有一模一样的或基本近似的代码，比如out输出你可能就得写成百遍；</li><li>开发Servlet必须精通网页前端和美工，你得非常不直观的在Servlet中写前端代码，这使得实现各种页面效果和风格非常困难。</li></ul></li><li><p>所以，SUN借鉴了Microsoft的ASP，正式提出JSP（Servlet1.1），已期望能代替Servlet。但是很快，SUN发现JSP也有问题：</p><ul><li>前端开发人员需要看JSP中大量的令他困惑的后端代码；</li><li>同样，Servlet开发人员也得在复杂的前端代码中找到其能写Servlet代码的地方；</li></ul></li><li><p>所以，Servlet1.2出现了，这个版本的Servlet倡导了MVC思想：</p><ul><li>JSP（V）：将后端代码封装在标签中，使用大量的标签，JSP只用来写前端代码而不要有后台代码；</li><li>Servlet（C）：Servlet完成Controller的功能再加上部分代码逻辑；</li><li>Model（M）：Servlet将数据发送给Model，Model包括部分代码逻辑，最主要的Model也代表着被组织好的用于返回的数据。最终，Model数据会被显示在JSP上（V）。<br>基本上到这里Servlet的大方向已经固定了，随之，成熟的发展至今 - 2016年5月26日…</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Servlet？&quot;&gt;&lt;a href=&quot;#什么是Servlet？&quot; class=&quot;headerlink&quot; title=&quot;什么是Servlet？&quot;&gt;&lt;/a&gt;什么是Servlet？&lt;/h2&gt;&lt;p&gt;servlet 是基于 Java 的 Web 组件，由容器（Serv
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="servlet" scheme="http://yoursite.com/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>java之NIO编程</title>
    <link href="http://yoursite.com/2017/07/04/java%E4%B9%8BNIO%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/07/04/java之NIO编程/</id>
    <published>2017-07-03T16:30:59.000Z</published>
    <updated>2017-07-03T17:14:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>NIO（Non-blocking I/O，在Java领域，也称为New I/O，从 Java 1.4 开始），是一种==同步非阻塞的I/O模型==，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p><p>主要包括三个核心组件：<br>NIO的工具包提出了基于Selector（选择器）、Buffer（缓冲区）、Channel（通道）的新模式；Selector（选择器）、可选择的Channel（通道）和SelectionKey（选择键）配合起来使用，可以实现并发的非阻塞型I/O能力。</p><p>NI/O 是一种同步非阻塞的 I/O 模型。同步是指线程不断轮询 I/O 事件是否就绪，非阻塞是指线程在等待 I/O 的时候，可以同时做其他任务。同步的核心就是 Selector，Selector 代替了线程本身轮询 I/O 事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区，当 I/O 事件就绪时，可以通过写道缓冲区，保证 I/O 的成功，而无需线程阻塞式地等待。</p><h2 id="优缺点？"><a href="#优缺点？" class="headerlink" title="优缺点？"></a>优缺点？</h2><p>相较之前的io，效率更高，提升了并发量</p><p>I/O相比于BI/O,采用一种基于通道和缓存区的I/O方式 ,它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆的 DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在 Java 堆和 Native 堆中来回复制数据。</p><h3 id="Java-NIO-和-IO-的主要区别"><a href="#Java-NIO-和-IO-的主要区别" class="headerlink" title="Java NIO 和 IO 的主要区别"></a>Java NIO 和 IO 的主要区别</h3><p>下表总结了 Java NIO 和 IO 之间的主要差别，我会更详细地描述表中每部分的差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IO                NIO</span><br><span class="line">面向流            面向缓冲</span><br><span class="line">阻塞IO            非阻塞IO</span><br><span class="line">无                选择器</span><br></pre></td></tr></table></figure><p>面向流I/O的系统，一次处理一个字节的数据。一个输入流会产生一个字节的数据，而一个输出流同样一次消费一个字节的数据。对于流式数据，很容易创建过滤器。可以相对简单地把几个过滤器连接在一起，每个过滤器完成自己的工作，也是按字节进行过滤，精细的处理机制。另一方面，面向流I/O的通信往往比较缓慢。</p><p>面向块I/O的系统，以块为单位处理数据。每个操作步骤会生成或消费一个块的数据。以块为单位处理数据，其处理速度远快于以字节流为单位的方式。但是，与面向流I/O的通信相比，面向块I/O的通信缺乏优雅和简洁。</p><h3 id="什么时候应该使用java-io？什么时候又该使用java-nio呢？"><a href="#什么时候应该使用java-io？什么时候又该使用java-nio呢？" class="headerlink" title="什么时候应该使用java.io？什么时候又该使用java.nio呢？"></a>什么时候应该使用java.io？什么时候又该使用java.nio呢？</h3><p>1、 可扩展性。这可能会促使你选择不同的软件包。Java.net需要每个Socket通信都有一个线程。编码将大为简化。java.nio更富有效率，但相对难以编码。</p><p>2、 在处理成千上万的连接时，你可能需要更好的扩展性；但是如果连接数较低时，你可能更注重块I/O的高吞吐率。</p><p>3、当使用SSL (Secure Sockets Layer，安全套接字层) 工作时，选择java.nio则实现难度很大。</p><h2 id="内部的原理？"><a href="#内部的原理？" class="headerlink" title="内部的原理？"></a>内部的原理？</h2><p>假设某银行只有10个职员。该银行的业务流程分为以下4个步骤：</p><p>1） 顾客填申请表（5分钟）；</p><p>2） 职员审核（1分钟）；</p><p>3） 职员叫保安去金库取钱（3分钟）；</p><p>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。</p><p>　　我们看看银行不同的工作方式对其工作效率到底有何影响。</p><p>1 BIO方式<br>　　每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。</p><p>　　我们算算这个银行一个小时到底能处理多少顾客？一个职员处理一个顾客需要10分钟（5+1+3+1）时间，一个小时（60分钟）能处理6个顾客，一共10个职员，那就是只能处理60个顾客。</p><p>　　可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。</p><p>　　这种工作其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待 。</p><p>2 NIO方式<br>　　如何提高银行的吞吐量呢？</p><p>　　思路：分而治之，将任务拆分开来，由专门的人负责专门的任务。</p><p>　　具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写，每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。</p><p>　　我们计算下这种工作方式下银行一个小时到底能处理多少顾客？</p><p>　　假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理，柜台一个职员5分钟能处理完一个顾客，一个小时9名职员能处理：9*（60/5）=108。</p><p>　　可见工作方式的转变能带来效率的极大提升。</p><p>  这种工作方式其实就NIO的思路。下图是非常经典的NIO说明图，mainReactor线程负责监听server socket，accept新连接，并将建立的socket分派给subReactor；subReactor可以是一个线程，也可以是线程池（一般可以设置为CPU核数），负责多路分离已连接的socket，读写网络数据，这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成。</p><p>　　可以看到典型NIO有三类线程，分别是mainReactor线程、subReactor线程、work线程。不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。</p><p><img src="http://oo501cyv7.bkt.clouddn.com/14991017840585.jpg" alt=""></p><h2 id="具体的用法是什么？"><a href="#具体的用法是什么？" class="headerlink" title="具体的用法是什么？"></a>具体的用法是什么？</h2><h2 id="应用场景？"><a href="#应用场景？" class="headerlink" title="应用场景？"></a>应用场景？</h2><p>netty</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.itpub.net/thread-1372775-1-1.html" target="_blank" rel="noopener">Java NIO与Java IO的分析比较</a></li><li><a href="http://www.cnblogs.com/LBSer/p/4622749.html" target="_blank" rel="noopener">一个故事讲清楚NIO</a><br><a href="https://yq.aliyun.com/articles/2371" target="_blank" rel="noopener">https://yq.aliyun.com/articles/2371</a><br><a href="http://www.yangyong.me/java-nio%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">http://www.yangyong.me/java-nio%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AF%A6%E8%A7%A3/</a><br><a href="http://www.hollischuang.com/archives/184" target="_blank" rel="noopener">http://www.hollischuang.com/archives/184</a><br><a href="http://wiki.jikexueyuan.com/project/java-nio/nio-io.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/java-nio/nio-io.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;是什么？&quot;&gt;&lt;a href=&quot;#是什么？&quot; class=&quot;headerlink&quot; title=&quot;是什么？&quot;&gt;&lt;/a&gt;是什么？&lt;/h2&gt;&lt;p&gt;NIO（Non-blocking I/O，在Java领域，也称为New I/O，从 Java 1.4 开始），是一种==同步
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>网络协议进阶2——TCP/UDP协议详解</title>
    <link href="http://yoursite.com/2017/07/02/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E8%BF%9B%E9%98%B62%E2%80%94%E2%80%94TCP-UDP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/07/02/网络协议进阶2——TCP-UDP协议详解/</id>
    <published>2017-07-02T03:17:47.000Z</published>
    <updated>2017-07-16T08:39:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>分开叙述tcp、ip、http/https等协议</p><p>这个协议在java中的体现？</p><p>分为应用层、传输层、网络层和实体层<br><img src="http://oo501cyv7.bkt.clouddn.com/14816321462047.jpg" alt=""></p><p>一、TCP/IP协议</p><p>TCP/IP协议（传输控制协议）由网络层的IP协议和传输层的TCP协议组成。IP层负责网络主机的定位，数据传输的路由，由IP地址可以唯一的确定Internet上的一台主机。TCP层负责面向应用的可靠的或非可靠的数据传输机制，这是网络编程的主要对象。</p><p>二、TCP与UDP</p><p>TCP是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。</p><p>　　UDP是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p><p><img src="http://oo501cyv7.bkt.clouddn.com/14816330764039.jpg" alt=""></p><p>TCP与UDP区别：</p><p><img src="http://oo501cyv7.bkt.clouddn.com/14816332469431.jpg" alt=""></p><p>TCP特点：</p><p>　　1、TCP是面向连接的协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接协议，所以只能用于点对点的通讯。而且建立连接也需要消耗时间和开销。</p><p>　　2、TCP传输数据无大小限制，进行大数据传输。</p><p>　　3、TCP是一个可靠的协议，它能保证接收方能够完整正确地接收到发送方发送的全部数据。</p><p><img src="http://oo501cyv7.bkt.clouddn.com/14816333163774.jpg" alt=""></p><p>UDP特点：</p><p>　　1、UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</p><p>　　2、UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。</p><p>　　3、UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。</p><p><img src="http://oo501cyv7.bkt.clouddn.com/14816333420719.jpg" alt=""></p><p>TCP与UDP应用：</p><p>　　1、TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。</p><p>　　2，UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些</p><p>TCP通信需要服务器端侦听listen、接收客户端连接请求accept，等待客户端connect建立连接后才能进行数据包的收发(recv/send)工作。</p><p>而UDP则服务器和客户端的概念不明显，服务器端即接收端需要绑定端口，等待客户端的数据的到来。后续便可以进行数据的收发(recvfrom/sendto)工作。</p><p><img src="http://oo501cyv7.bkt.clouddn.com/14816331321116.jpg" alt=""></p><p>参考</p><ul><li><a href="http://www.cnblogs.com/ghj1976/p/4295346.html" target="_blank" rel="noopener">HTTP TCP UDP Socket 关系的几个经典图</a></li><li><a href="https://krystalchisholm.wordpress.com/2010/11/24/chapter-17/" target="_blank" rel="noopener">Chapter 7 – ISP Services</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分开叙述tcp、ip、http/https等协议&lt;/p&gt;
&lt;p&gt;这个协议在java中的体现？&lt;/p&gt;
&lt;p&gt;分为应用层、传输层、网络层和实体层&lt;br&gt;&lt;img src=&quot;http://oo501cyv7.bkt.clouddn.com/14816321462047.jpg&quot;
      
    
    </summary>
    
      <category term="理解计算器机" scheme="http://yoursite.com/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E5%99%A8%E6%9C%BA/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E5%99%A8%E6%9C%BA/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="理解计算机" scheme="http://yoursite.com/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
      <category term="UDP" scheme="http://yoursite.com/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路</title>
    <link href="http://yoursite.com/2017/07/02/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E8%BF%9B%E9%98%B61%E2%80%94%E2%80%94HTTP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%86%E5%8F%B2%E6%BC%94%E5%8F%98%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2017/07/02/网络协议进阶1——HTTP协议入门之HTTP协议的历史演变和设计思路/</id>
    <published>2017-07-02T03:16:14.000Z</published>
    <updated>2017-07-16T08:32:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oo501cyv7.bkt.clouddn.com/14816335778945.jpg" alt=""></p><p>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。</p><p>本文介绍 HTTP协议的历史演变和设计思路。</p><p><img src="http://oo501cyv7.bkt.clouddn.com/14816948261078.jpg" alt=""></p><h2 id="一、HTTP-0-9"><a href="#一、HTTP-0-9" class="headerlink" title="一、HTTP/0.9"></a>一、HTTP/0.9</h2><p>HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>服务器发送完毕，就关闭TCP连接。</p><h2 id="二、HTTP-1-0"><a href="#二、HTTP-1-0" class="headerlink" title="二、HTTP/1.0"></a>二、HTTP/1.0</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。<br>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><h3 id="2-2-请求格式"><a href="#2-2-请求格式" class="headerlink" title="2.2 请求格式"></a>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>可以看到，这个格式与0.9版有很大变化。<br>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p><h3 id="2-3-回应格式"><a href="#2-3-回应格式" class="headerlink" title="2.3 回应格式"></a>2.3 回应格式</h3><p>服务器的回应如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>回应的格式是”头信息 + 一个空行（<code>\r\n</code>） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p><h3 id="2-4-Content-Type-字段"><a href="#2-4-Content-Type-字段" class="headerlink" title="2.4 Content-Type 字段"></a>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。<br>下面是一些常见的<code>Content-Type</code>字段的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* text/plain</span><br><span class="line">* text/html</span><br><span class="line">* text/css</span><br><span class="line">* image/jpeg</span><br><span class="line">* image/png</span><br><span class="line">* image/svg+xml</span><br><span class="line">* audio/mp4</span><br><span class="line">* video/mp4</span><br><span class="line">* application/javascript</span><br><span class="line">* application/pdf</span><br><span class="line">* application/zip</span><br><span class="line">* application/atom+xml</span><br></pre></td></tr></table></figure><p>这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。<br>除了预定义的类型，厂商也可以自定义类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.debian.binary-package</span><br></pre></td></tr></table></figure><p>上面的类型表明，发送的是Debian系统的二进制数据包。<br>MIME type还可以在尾部使用分号，添加参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的类型表明，发送的是网页，而且编码是UTF-8。<br>客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>上面代码中，客户端声明自己可以接受任何格式的数据。<br>MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="2-5-Content-Encoding-字段"><a href="#2-5-Content-Encoding-字段" class="headerlink" title="2.5 Content-Encoding 字段"></a>2.5 Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure><p>客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><h3 id="2-6-缺点"><a href="#2-6-缺点" class="headerlink" title="2.6 缺点"></a>2.6 缺点</h3><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。<br>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。<br>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h2 id="三、HTTP-1-1"><a href="#三、HTTP-1-1" class="headerlink" title="三、HTTP/1.1"></a>三、HTTP/1.1</h2><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p><h3 id="3-1-持久连接"><a href="#3-1-持久连接" class="headerlink" title="3.1 持久连接"></a>3.1 持久连接</h3><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。<br>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p><h3 id="3-2-管道机制"><a href="#3-2-管道机制" class="headerlink" title="3.2 管道机制"></a>3.2 管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><h3 id="3-3-Content-Length-字段"><a href="#3-3-Content-Length-字段" class="headerlink" title="3.3 Content-Length 字段"></a>3.3 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。<br>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><h3 id="3-4-分块传输编码"><a href="#3-4-分块传输编码" class="headerlink" title="3.4 分块传输编码"></a>3.4 分块传输编码</h3><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p><p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="3-5-其他功能"><a href="#3-5-其他功能" class="headerlink" title="3.5 其他功能"></a>3.5 其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p><p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure><p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h3 id="3-6-缺点"><a href="#3-6-缺点" class="headerlink" title="3.6 缺点"></a>3.6 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank" rel="noopener">队头堵塞</a>“（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><h2 id="四、SPDY-协议"><a href="#四、SPDY-协议" class="headerlink" title="四、SPDY 协议"></a>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。<br>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><h2 id="五、HTTP-2"><a href="#五、HTTP-2" class="headerlink" title="五、HTTP/2"></a>五、HTTP/2</h2><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p><h3 id="5-1-二进制协议"><a href="#5-1-二进制协议" class="headerlink" title="5.1 二进制协议"></a>5.1 二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h3 id="5-2-多工"><a href="#5-2-多工" class="headerlink" title="5.2 多工"></a>5.2 多工</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h3 id="5-3-数据流"><a href="#5-3-数据流" class="headerlink" title="5.3 数据流"></a>5.3 数据流</h3><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h3 id="5-4-头信息压缩"><a href="#5-4-头信息压缩" class="headerlink" title="5.4 头信息压缩"></a>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h3 id="5-5-服务器推送"><a href="#5-5-服务器推送" class="headerlink" title="5.5 服务器推送"></a>5.5 服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a></li><li><a href="http://www.open-open.com/solution/view/1455863940495" target="_blank" rel="noopener">http协议和tcp协议的区别是什么</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://oo501cyv7.bkt.clouddn.com/14816335778945.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="理解计算器机" scheme="http://yoursite.com/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E5%99%A8%E6%9C%BA/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E5%99%A8%E6%9C%BA/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="理解计算机" scheme="http://yoursite.com/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="HTTP协议" scheme="http://yoursite.com/tags/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
</feed>
